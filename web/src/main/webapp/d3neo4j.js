function uiCodemirrorDirective($timeout, uiCodemirrorConfig) {
    function postLink(scope, iElement, iAttrs, ngModel) {
        var codemirrorOptions = angular.extend({value: iElement.text()}, uiCodemirrorConfig.codemirror || {}, scope.$eval(iAttrs.uiCodemirror), scope.$eval(iAttrs.uiCodemirrorOpts)), codemirror = newCodemirrorEditor(iElement, codemirrorOptions);
        configOptionsWatcher(codemirror, iAttrs.uiCodemirror || iAttrs.uiCodemirrorOpts, scope), configNgModelLink(codemirror, ngModel, scope), configUiRefreshAttribute(codemirror, iAttrs.uiRefresh, scope), scope.$on("CodeMirror", function (event, callback) {
            if (!angular.isFunction(callback))
                throw new Error("the CodeMirror event requires a callback function");
            callback(codemirror)
        }), angular.isFunction(codemirrorOptions.onLoad) && codemirrorOptions.onLoad(codemirror)
    }
    function newCodemirrorEditor(iElement, codemirrorOptions) {
        var codemirrot;
        return"TEXTAREA" === iElement[0].tagName ? codemirrot = window.CodeMirror.fromTextArea(iElement[0], codemirrorOptions) : (iElement.html(""), codemirrot = new window.CodeMirror(function (cm_el) {
            iElement.append(cm_el)
        }, codemirrorOptions)), codemirrot
    }
    function configOptionsWatcher(codemirrot, uiCodemirrorAttr, scope) {
        function updateOptions(newValues, oldValue) {
            angular.isObject(newValues) && codemirrorDefaultsKeys.forEach(function (key) {
                if (newValues.hasOwnProperty(key)) {
                    if (oldValue && newValues[key] === oldValue[key])
                        return;
                    codemirrot.setOption(key, newValues[key])
                }
            })
        }
        if (uiCodemirrorAttr) {
            var codemirrorDefaultsKeys = Object.keys(window.CodeMirror.defaults);
            scope.$watch(uiCodemirrorAttr, updateOptions, !0)
        }
    }
    function configNgModelLink(codemirror, ngModel, scope) {
        ngModel && (ngModel.$formatters.push(function (value) {
            if (angular.isUndefined(value) || null === value)
                return"";
            if (angular.isObject(value) || angular.isArray(value))
                throw new Error("ui-codemirror cannot use an object or an array as a model");
            return value
        }), ngModel.$render = function () {
            var safeViewValue = ngModel.$viewValue || "";
            codemirror.setValue(safeViewValue)
        }, codemirror.on("change", function (instance) {
            var newValue = instance.getValue();
            newValue !== ngModel.$viewValue && scope.$applyAsync(function () {
                ngModel.$setViewValue(newValue)
            })
        }))
    }
    function configUiRefreshAttribute(codeMirror, uiRefreshAttr, scope) {
        uiRefreshAttr && scope.$watch(uiRefreshAttr, function (newVal, oldVal) {
            newVal !== oldVal && $timeout(function () {
                codeMirror.refresh()
            })
        })
    }
    return{restrict: "EA", require: "?ngModel", compile: function () {
            if (angular.isUndefined(window.CodeMirror))
                throw new Error("ui-codemirror need CodeMirror to work... (o rly?)");
            return postLink
        }}
}
function RGBColor(color_string) {
    this.ok = !1, "#" == color_string.charAt(0) && (color_string = color_string.substr(1, 6)), color_string = color_string.replace(/ /g, ""), color_string = color_string.toLowerCase();
    var simple_colors = {aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32"};
    for (var key in simple_colors)
        color_string == key && (color_string = simple_colors[key]);
    for (var color_defs = [{re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function (bits) {
                return[parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3])]
            }}, {re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function (bits) {
                return[parseInt(bits[1], 16), parseInt(bits[2], 16), parseInt(bits[3], 16)]
            }}, {re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function (bits) {
                return[parseInt(bits[1] + bits[1], 16), parseInt(bits[2] + bits[2], 16), parseInt(bits[3] + bits[3], 16)]
            }}], i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re, processor = color_defs[i].process, bits = re.exec(color_string);
        bits && (channels = processor(bits), this.r = channels[0], this.g = channels[1], this.b = channels[2], this.ok = !0)
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function () {
        return"rgb(" + this.r + ", " + this.g + ", " + this.b + ")"
    }, this.toHex = function () {
        var r = this.r.toString(16), g = this.g.toString(16), b = this.b.toString(16);
        return 1 == r.length && (r = "0" + r), 1 == g.length && (g = "0" + g), 1 == b.length && (b = "0" + b), "#" + r + g + b
    }, this.getHelpXML = function () {
        for (var examples = new Array, i = 0; i < color_defs.length; i++)
            for (var example = color_defs[i].example, j = 0; j < example.length; j++)
                examples[examples.length] = example[j];
        for (var sc in simple_colors)
            examples[examples.length] = sc;
        var xml = document.createElement("ul");
        xml.setAttribute("id", "rgbcolor-examples");
        for (var i = 0; i < examples.length; i++)
            try {
                var list_item = document.createElement("li"), list_color = new RGBColor(examples[i]), example_div = document.createElement("div");
                example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex(), example_div.appendChild(document.createTextNode("test"));
                var list_item_value = document.createTextNode(" " + examples[i] + " -> " + list_color.toRGB() + " -> " + list_color.toHex());
                list_item.appendChild(example_div), list_item.appendChild(list_item_value), xml.appendChild(list_item)
            } catch (e) {
            }
        return xml
    }
}
function stackBlurImage(imageID, canvasID, radius, blurAlphaChannel) {
    var img = document.getElementById(imageID), w = img.naturalWidth, h = img.naturalHeight, canvas = document.getElementById(canvasID);
    canvas.style.width = w + "px", canvas.style.height = h + "px", canvas.width = w, canvas.height = h;
    var context = canvas.getContext("2d");
    context.clearRect(0, 0, w, h), context.drawImage(img, 0, 0), isNaN(radius) || 1 > radius || (blurAlphaChannel ? stackBlurCanvasRGBA(canvasID, 0, 0, w, h, radius) : stackBlurCanvasRGB(canvasID, 0, 0, w, h, radius))
}
function stackBlurCanvasRGBA(id, top_x, top_y, width, height, radius) {
    if (!(isNaN(radius) || 1 > radius)) {
        radius |= 0;
        var imageData, canvas = document.getElementById(id), context = canvas.getContext("2d");
        try {
            try {
                imageData = context.getImageData(top_x, top_y, width, height)
            } catch (e) {
                try {
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead"), imageData = context.getImageData(top_x, top_y, width, height)
                } catch (e) {
                    throw alert("Cannot access local image"), new Error("unable to access local image data: " + e)
                }
            }
        } catch (e) {
            throw alert("Cannot access image"), new Error("unable to access image data: " + e)
        }
        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs, pixels = imageData.data, div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2, stackStart = new BlurStack, stack = stackStart;
        for (i = 1; div > i; i++)
            if (stack = stack.next = new BlurStack, i == radiusPlus1)
                var stackEnd = stack;
        stack.next = stackStart;
        var stackIn = null, stackOut = null;
        yw = yi = 0;
        var mul_sum = mul_table[radius], shg_sum = shg_table[radius];
        for (y = 0; height > y; y++) {
            for (r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0, r_out_sum = radiusPlus1 * (pr = pixels[yi]), g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]), b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]), a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]), r_sum += sumFactor * pr, g_sum += sumFactor * pg, b_sum += sumFactor * pb, a_sum += sumFactor * pa, stack = stackStart, i = 0; radiusPlus1 > i; i++)
                stack.r = pr, stack.g = pg, stack.b = pb, stack.a = pa, stack = stack.next;
            for (i = 1; radiusPlus1 > i; i++)
                p = yi + ((i > widthMinus1 ? widthMinus1 : i) << 2), r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i), g_sum += (stack.g = pg = pixels[p + 1]) * rbs, b_sum += (stack.b = pb = pixels[p + 2]) * rbs, a_sum += (stack.a = pa = pixels[p + 3]) * rbs, r_in_sum += pr, g_in_sum += pg, b_in_sum += pb, a_in_sum += pa, stack = stack.next;
            for (stackIn = stackStart, stackOut = stackEnd, x = 0; width > x; x++)
                pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum, 0 != pa ? (pa = 255 / pa, pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa, pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa, pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa) : pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0, r_sum -= r_out_sum, g_sum -= g_out_sum, b_sum -= b_out_sum, a_sum -= a_out_sum, r_out_sum -= stackIn.r, g_out_sum -= stackIn.g, b_out_sum -= stackIn.b, a_out_sum -= stackIn.a, p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2, r_in_sum += stackIn.r = pixels[p], g_in_sum += stackIn.g = pixels[p + 1], b_in_sum += stackIn.b = pixels[p + 2], a_in_sum += stackIn.a = pixels[p + 3], r_sum += r_in_sum, g_sum += g_in_sum, b_sum += b_in_sum, a_sum += a_in_sum, stackIn = stackIn.next, r_out_sum += pr = stackOut.r, g_out_sum += pg = stackOut.g, b_out_sum += pb = stackOut.b, a_out_sum += pa = stackOut.a, r_in_sum -= pr, g_in_sum -= pg, b_in_sum -= pb, a_in_sum -= pa, stackOut = stackOut.next, yi += 4;
            yw += width
        }
        for (x = 0; width > x; x++) {
            for (g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0, yi = x << 2, r_out_sum = radiusPlus1 * (pr = pixels[yi]), g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]), b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]), a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]), r_sum += sumFactor * pr, g_sum += sumFactor * pg, b_sum += sumFactor * pb, a_sum += sumFactor * pa, stack = stackStart, i = 0; radiusPlus1 > i; i++)
                stack.r = pr, stack.g = pg, stack.b = pb, stack.a = pa, stack = stack.next;
            for (yp = width, i = 1; radius >= i; i++)
                yi = yp + x << 2, r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i), g_sum += (stack.g = pg = pixels[yi + 1]) * rbs, b_sum += (stack.b = pb = pixels[yi + 2]) * rbs, a_sum += (stack.a = pa = pixels[yi + 3]) * rbs, r_in_sum += pr, g_in_sum += pg, b_in_sum += pb, a_in_sum += pa, stack = stack.next, heightMinus1 > i && (yp += width);
            for (yi = x, stackIn = stackStart, stackOut = stackEnd, y = 0; height > y; y++)
                p = yi << 2, pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum, pa > 0 ? (pa = 255 / pa, pixels[p] = (r_sum * mul_sum >> shg_sum) * pa, pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa, pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa) : pixels[p] = pixels[p + 1] = pixels[p + 2] = 0, r_sum -= r_out_sum, g_sum -= g_out_sum, b_sum -= b_out_sum, a_sum -= a_out_sum, r_out_sum -= stackIn.r, g_out_sum -= stackIn.g, b_out_sum -= stackIn.b, a_out_sum -= stackIn.a, p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2, r_sum += r_in_sum += stackIn.r = pixels[p], g_sum += g_in_sum += stackIn.g = pixels[p + 1], b_sum += b_in_sum += stackIn.b = pixels[p + 2], a_sum += a_in_sum += stackIn.a = pixels[p + 3], stackIn = stackIn.next, r_out_sum += pr = stackOut.r, g_out_sum += pg = stackOut.g, b_out_sum += pb = stackOut.b, a_out_sum += pa = stackOut.a, r_in_sum -= pr, g_in_sum -= pg, b_in_sum -= pb, a_in_sum -= pa, stackOut = stackOut.next, yi += width
        }
        context.putImageData(imageData, top_x, top_y)
    }
}
function stackBlurCanvasRGB(id, top_x, top_y, width, height, radius) {
    if (!(isNaN(radius) || 1 > radius)) {
        radius |= 0;
        var imageData, canvas = document.getElementById(id), context = canvas.getContext("2d");
        try {
            try {
                imageData = context.getImageData(top_x, top_y, width, height)
            } catch (e) {
                try {
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead"), imageData = context.getImageData(top_x, top_y, width, height)
                } catch (e) {
                    throw alert("Cannot access local image"), new Error("unable to access local image data: " + e)
                }
            }
        } catch (e) {
            throw alert("Cannot access image"), new Error("unable to access image data: " + e)
        }
        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, r_out_sum, g_out_sum, b_out_sum, r_in_sum, g_in_sum, b_in_sum, pr, pg, pb, rbs, pixels = imageData.data, div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2, stackStart = new BlurStack, stack = stackStart;
        for (i = 1; div > i; i++)
            if (stack = stack.next = new BlurStack, i == radiusPlus1)
                var stackEnd = stack;
        stack.next = stackStart;
        var stackIn = null, stackOut = null;
        yw = yi = 0;
        var mul_sum = mul_table[radius], shg_sum = shg_table[radius];
        for (y = 0; height > y; y++) {
            for (r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0, r_out_sum = radiusPlus1 * (pr = pixels[yi]), g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]), b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]), r_sum += sumFactor * pr, g_sum += sumFactor * pg, b_sum += sumFactor * pb, stack = stackStart, i = 0; radiusPlus1 > i; i++)
                stack.r = pr, stack.g = pg, stack.b = pb, stack = stack.next;
            for (i = 1; radiusPlus1 > i; i++)
                p = yi + ((i > widthMinus1 ? widthMinus1 : i) << 2), r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i), g_sum += (stack.g = pg = pixels[p + 1]) * rbs, b_sum += (stack.b = pb = pixels[p + 2]) * rbs, r_in_sum += pr, g_in_sum += pg, b_in_sum += pb, stack = stack.next;
            for (stackIn = stackStart, stackOut = stackEnd, x = 0; width > x; x++)
                pixels[yi] = r_sum * mul_sum >> shg_sum, pixels[yi + 1] = g_sum * mul_sum >> shg_sum, pixels[yi + 2] = b_sum * mul_sum >> shg_sum, r_sum -= r_out_sum, g_sum -= g_out_sum, b_sum -= b_out_sum, r_out_sum -= stackIn.r, g_out_sum -= stackIn.g, b_out_sum -= stackIn.b, p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2, r_in_sum += stackIn.r = pixels[p], g_in_sum += stackIn.g = pixels[p + 1], b_in_sum += stackIn.b = pixels[p + 2], r_sum += r_in_sum, g_sum += g_in_sum, b_sum += b_in_sum, stackIn = stackIn.next, r_out_sum += pr = stackOut.r, g_out_sum += pg = stackOut.g, b_out_sum += pb = stackOut.b, r_in_sum -= pr, g_in_sum -= pg, b_in_sum -= pb, stackOut = stackOut.next, yi += 4;
            yw += width
        }
        for (x = 0; width > x; x++) {
            for (g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0, yi = x << 2, r_out_sum = radiusPlus1 * (pr = pixels[yi]), g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]), b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]), r_sum += sumFactor * pr, g_sum += sumFactor * pg, b_sum += sumFactor * pb, stack = stackStart, i = 0; radiusPlus1 > i; i++)
                stack.r = pr, stack.g = pg, stack.b = pb, stack = stack.next;
            for (yp = width, i = 1; radius >= i; i++)
                yi = yp + x << 2, r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i), g_sum += (stack.g = pg = pixels[yi + 1]) * rbs, b_sum += (stack.b = pb = pixels[yi + 2]) * rbs, r_in_sum += pr, g_in_sum += pg, b_in_sum += pb, stack = stack.next, heightMinus1 > i && (yp += width);
            for (yi = x, stackIn = stackStart, stackOut = stackEnd, y = 0; height > y; y++)
                p = yi << 2, pixels[p] = r_sum * mul_sum >> shg_sum, pixels[p + 1] = g_sum * mul_sum >> shg_sum, pixels[p + 2] = b_sum * mul_sum >> shg_sum, r_sum -= r_out_sum, g_sum -= g_out_sum, b_sum -= b_out_sum, r_out_sum -= stackIn.r, g_out_sum -= stackIn.g, b_out_sum -= stackIn.b, p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2, r_sum += r_in_sum += stackIn.r = pixels[p], g_sum += g_in_sum += stackIn.g = pixels[p + 1], b_sum += b_in_sum += stackIn.b = pixels[p + 2], stackIn = stackIn.next, r_out_sum += pr = stackOut.r, g_out_sum += pg = stackOut.g, b_out_sum += pb = stackOut.b, r_in_sum -= pr, g_in_sum -= pg, b_in_sum -= pb, stackOut = stackOut.next, yi += width
        }
        context.putImageData(imageData, top_x, top_y)
    }
}
function BlurStack() {
    this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null
}
!function (global, factory) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function (w) {
        if (!w.document)
            throw new Error("jQuery requires a window with a document");
        return factory(w)
    } : factory(global)
}("undefined" != typeof window ? window : this, function (window, noGlobal) {
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        return"function" === type || jQuery.isWindow(obj) ? !1 : 1 === obj.nodeType && length ? !0 : "array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj
    }
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier))
            return jQuery.grep(elements, function (elem, i) {
                return!!qualifier.call(elem, i, elem) !== not
            });
        if (qualifier.nodeType)
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not
            });
        if ("string" == typeof qualifier) {
            if (risSimple.test(qualifier))
                return jQuery.filter(qualifier, elements, not);
            qualifier = jQuery.filter(qualifier, elements)
        }
        return jQuery.grep(elements, function (elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not
        })
    }
    function sibling(cur, dir) {
        for (; (cur = cur[dir]) && 1 !== cur.nodeType; )
            ;
        return cur
    }
    function createOptions(options) {
        var object = optionsCache[options] = {};
        return jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = !0
        }), object
    }
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, !1), window.removeEventListener("load", completed, !1), jQuery.ready()
    }
    function Data() {
        Object.defineProperty(this.cache = {}, 0, {get: function () {
                return{}
            }}), this.expando = jQuery.expando + Data.uid++
    }
    function dataAttr(elem, key, data) {
        var name;
        if (void 0 === data && 1 === elem.nodeType)
            if (name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase(), data = elem.getAttribute(name), "string" == typeof data) {
                try {
                    data = "true" === data ? !0 : "false" === data ? !1 : "null" === data ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data
                } catch (e) {
                }
                data_user.set(elem, key, data)
            } else
                data = void 0;
        return data
    }
    function returnTrue() {
        return!0
    }
    function returnFalse() {
        return!1
    }
    function safeActiveElement() {
        try {
            return document.activeElement
        } catch (err) {
        }
    }
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem
    }
    function disableScript(elem) {
        return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        return match ? elem.type = match[1] : elem.removeAttribute("type"), elem
    }
    function setGlobalEval(elems, refElements) {
        for (var i = 0, l = elems.length; l > i; i++)
            data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"))
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (1 === dest.nodeType) {
            if (data_priv.hasData(src) && (pdataOld = data_priv.access(src), pdataCur = data_priv.set(dest, pdataOld), events = pdataOld.events)) {
                delete pdataCur.handle, pdataCur.events = {};
                for (type in events)
                    for (i = 0, l = events[type].length; l > i; i++)
                        jQuery.event.add(dest, type, events[type][i])
            }
            data_user.hasData(src) && (udataOld = data_user.access(src), udataCur = jQuery.extend({}, udataOld), data_user.set(dest, udataCur))
        }
    }
    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return void 0 === tag || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : ("input" === nodeName || "textarea" === nodeName) && (dest.defaultValue = src.defaultValue)
    }
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
        return elem.detach(), display
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        return display || (display = actualDisplay(nodeName, doc), "none" !== display && display || (iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement), doc = iframe[0].contentDocument, doc.write(), doc.close(), display = actualDisplay(nodeName, doc), iframe.detach()), elemdisplay[nodeName] = display), display
    }
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        return computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name]), computed && ("" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), void 0 !== ret ? ret + "" : ret
    }
    function addGetHookIf(conditionFn, hookFn) {
        return{get: function () {
                return conditionFn() ? void delete this.get : (this.get = hookFn).apply(this, arguments)
            }}
    }
    function vendorPropName(style, name) {
        if (name in style)
            return name;
        for (var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length; i--; )
            if (name = cssPrefixes[i] + capName, name in style)
                return name;
        return origName
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        for (var i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0, val = 0; 4 > i; i += 2)
            "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
        return val
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = !0, val = "width" === name ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
        if (0 >= val || null == val) {
            if (val = curCSS(elem, name, styles), (0 > val || null == val) && (val = elem.style[name]), rnumnonpx.test(val))
                return val;
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), val = parseFloat(val) || 0
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px"
    }
    function showHide(elements, show) {
        for (var display, elem, hidden, values = [], index = 0, length = elements.length; length > index; index++)
            elem = elements[index], elem.style && (values[index] = data_priv.get(elem, "olddisplay"), display = elem.style.display, show ? (values[index] || "none" !== display || (elem.style.display = ""), "" === elem.style.display && isHidden(elem) && (values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName)))) : (hidden = isHidden(elem), "none" === display && hidden || data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"))));
        for (index = 0; length > index; index++)
            elem = elements[index], elem.style && (show && "none" !== elem.style.display && "" !== elem.style.display || (elem.style.display = show ? values[index] || "" : "none"));
        return elements
    }
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing)
    }
    function createFxNow() {
        return setTimeout(function () {
            fxNow = void 0
        }), fxNow = jQuery.now()
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {height: type};
        for (includeWidth = includeWidth?1:0; 4 > i; i += 2 - includeWidth)
            which = cssExpand[i], attrs["margin" + which] = attrs["padding" + which] = type;
        return includeWidth && (attrs.opacity = attrs.width = type), attrs
    }
    function createTween(value, prop, animation) {
        for (var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length; length > index; index++)
            if (tween = collection[index].call(animation, prop, value))
                return tween
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
        opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, oldfire = hooks.empty.fire, hooks.empty.fire = function () {
            hooks.unqueued || oldfire()
        }), hooks.unqueued++, anim.always(function () {
            anim.always(function () {
                hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire()
            })
        })), 1 === elem.nodeType && ("height"in props || "width"in props) && (opts.overflow = [style.overflow, style.overflowX, style.overflowY], display = jQuery.css(elem, "display"), checkDisplay = "none" === display ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display, "inline" === checkDisplay && "none" === jQuery.css(elem, "float") && (style.display = "inline-block")), opts.overflow && (style.overflow = "hidden", anim.always(function () {
            style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2]
        }));
        for (prop in props)
            if (value = props[prop], rfxtypes.exec(value)) {
                if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                    if ("show" !== value || !dataShow || void 0 === dataShow[prop])
                        continue;
                    hidden = !0
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
            } else
                display = void 0;
        if (jQuery.isEmptyObject(orig))
            "inline" === ("none" === display ? defaultDisplay(elem.nodeName) : display) && (style.display = display);
        else {
            dataShow ? "hidden"in dataShow && (hidden = dataShow.hidden) : dataShow = data_priv.access(elem, "fxshow", {}), toggle && (dataShow.hidden = !hidden), hidden ? jQuery(elem).show() : anim.done(function () {
                jQuery(elem).hide()
            }), anim.done(function () {
                var prop;
                data_priv.remove(elem, "fxshow");
                for (prop in orig)
                    jQuery.style(elem, prop, orig[prop])
            });
            for (prop in orig)
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = tween.start, hidden && (tween.end = tween.start, tween.start = "width" === prop || "height" === prop ? 1 : 0))
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props)
            if (name = jQuery.camelCase(index), easing = specialEasing[name], value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), index !== name && (props[name] = value, delete props[index]), hooks = jQuery.cssHooks[name], hooks && "expand"in hooks) {
                value = hooks.expand(value), delete props[name];
                for (index in value)
                    index in props || (props[index] = value[index], specialEasing[index] = easing)
            } else
                specialEasing[name] = easing
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
            delete tick.elem
        }), tick = function () {
            if (stopped)
                return!1;
            for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; length > index; index++)
                animation.tweens[index].run(percent);
            return deferred.notifyWith(elem, [animation, percent, remaining]), 1 > percent && length ? remaining : (deferred.resolveWith(elem, [animation]), !1)
        }, animation = deferred.promise({elem: elem, props: jQuery.extend({}, properties), opts: jQuery.extend(!0, {specialEasing: {}}, options), originalProperties: properties, originalOptions: options, startTime: fxNow || createFxNow(), duration: options.duration, tweens: [], createTween: function (prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                return animation.tweens.push(tween), tween
            }, stop: function (gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped)
                    return this;
                for (stopped = !0; length > index; index++)
                    animation.tweens[index].run(1);
                return gotoEnd ? deferred.resolveWith(elem, [animation, gotoEnd]) : deferred.rejectWith(elem, [animation, gotoEnd]), this
            }}), props = animation.props;
        for (propFilter(props, animation.opts.specialEasing); length > index; index++)
            if (result = animationPrefilters[index].call(animation, elem, props, animation.opts))
                return result;
        return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), jQuery.fx.timer(jQuery.extend(tick, {elem: elem, anim: animation, queue: animation.opts.queue})), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always)
    }
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func))
                for (; dataType = dataTypes[i++]; )
                    "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func)
        }
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        function inspect(dataType) {
            var selected;
            return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                return"string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), inspect(dataTypeOrTransport), !1)
            }), selected
        }
        var inspected = {}, seekingTransport = structure === transports;
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src)
            void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
        return deep && jQuery.extend(!0, target, deep), target
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; )
            dataTypes.shift(), void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
        if (ct)
            for (type in contents)
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break
                }
        if (dataTypes[0]in responses)
            finalDataType = dataTypes[0];
        else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break
                }
                firstDataType || (firstDataType = type)
            }
            finalDataType = finalDataType || firstDataType
        }
        return finalDataType ? (finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), responses[finalDataType]) : void 0
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1])
            for (conv in s.converters)
                converters[conv.toLowerCase()] = s.converters[conv];
        for (current = dataTypes.shift(); current; )
            if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), prev = current, current = dataTypes.shift())
                if ("*" === current)
                    current = prev;
                else if ("*" !== prev && prev !== current) {
                    if (conv = converters[prev + " " + current] || converters["* " + current], !conv)
                        for (conv2 in converters)
                            if (tmp = conv2.split(" "), tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                                conv === !0 ? conv = converters[conv2] : converters[conv2] !== !0 && (current = tmp[0], dataTypes.unshift(tmp[1]));
                                break
                            }
                    if (conv !== !0)
                        if (conv && s["throws"])
                            response = conv(response);
                        else
                            try {
                                response = conv(response)
                            } catch (e) {
                                return{state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current}
                            }
                }
        return{state: "success", data: response}
    }
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj))
            jQuery.each(obj, function (i, v) {
                traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v ? i : "") + "]", v, traditional, add)
            });
        else if (traditional || "object" !== jQuery.type(obj))
            add(prefix, obj);
        else
            for (name in obj)
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
    }
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : 9 === elem.nodeType && elem.defaultView;
    }
    var arr = [], slice = arr.slice, concat = arr.concat, push = arr.push, indexOf = arr.indexOf, class2type = {}, toString = class2type.toString, hasOwn = class2type.hasOwnProperty, support = {}, document = window.document, version = "2.1.3", jQuery = function (selector, context) {
        return new jQuery.fn.init(selector, context)
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
        return letter.toUpperCase()
    };
    jQuery.fn = jQuery.prototype = {jquery: version, constructor: jQuery, selector: "", length: 0, toArray: function () {
            return slice.call(this)
        }, get: function (num) {
            return null != num ? 0 > num ? this[num + this.length] : this[num] : slice.call(this)
        }, pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            return ret.prevObject = this, ret.context = this.context, ret
        }, each: function (callback, args) {
            return jQuery.each(this, callback, args)
        }, map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem)
            }))
        }, slice: function () {
            return this.pushStack(slice.apply(this, arguments))
        }, first: function () {
            return this.eq(0)
        }, last: function () {
            return this.eq(-1)
        }, eq: function (i) {
            var len = this.length, j = +i + (0 > i ? len : 0);
            return this.pushStack(j >= 0 && len > j ? [this[j]] : [])
        }, end: function () {
            return this.prevObject || this.constructor(null)
        }, push: push, sort: arr.sort, splice: arr.splice}, jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
        for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, i++), "object" == typeof target || jQuery.isFunction(target) || (target = {}), i === length && (target = this, i--); length > i; i++)
            if (null != (options = arguments[i]))
                for (name in options)
                    src = target[name], copy = options[name], target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, clone = src && jQuery.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
        return target
    }, jQuery.extend({expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (msg) {
            throw new Error(msg)
        }, noop: function () {
        }, isFunction: function (obj) {
            return"function" === jQuery.type(obj)
        }, isArray: Array.isArray, isWindow: function (obj) {
            return null != obj && obj === obj.window
        }, isNumeric: function (obj) {
            return!jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0
        }, isPlainObject: function (obj) {
            return"object" !== jQuery.type(obj) || obj.nodeType || jQuery.isWindow(obj) ? !1 : obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ? !1 : !0
        }, isEmptyObject: function (obj) {
            var name;
            for (name in obj)
                return!1;
            return!0
        }, type: function (obj) {
            return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj
        }, globalEval: function (code) {
            var script, indirect = eval;
            code = jQuery.trim(code), code && (1 === code.indexOf("use strict") ? (script = document.createElement("script"), script.text = code, document.head.appendChild(script).parentNode.removeChild(script)) : indirect(code))
        }, camelCase: function (string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
        }, nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
        }, each: function (obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray)
                    for (; length > i && (value = callback.apply(obj[i], args), value !== !1); i++)
                        ;
                else
                    for (i in obj)
                        if (value = callback.apply(obj[i], args), value === !1)
                            break
            } else if (isArray)
                for (; length > i && (value = callback.call(obj[i], i, obj[i]), value !== !1); i++)
                    ;
            else
                for (i in obj)
                    if (value = callback.call(obj[i], i, obj[i]), value === !1)
                        break;
            return obj
        }, trim: function (text) {
            return null == text ? "" : (text + "").replace(rtrim, "")
        }, makeArray: function (arr, results) {
            var ret = results || [];
            return null != arr && (isArraylike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [arr] : arr) : push.call(ret, arr)), ret
        }, inArray: function (elem, arr, i) {
            return null == arr ? -1 : indexOf.call(arr, elem, i)
        }, merge: function (first, second) {
            for (var len = +second.length, j = 0, i = first.length; len > j; j++)
                first[i++] = second[j];
            return first.length = i, first
        }, grep: function (elems, callback, invert) {
            for (var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert; length > i; i++)
                callbackInverse = !callback(elems[i], i), callbackInverse !== callbackExpect && matches.push(elems[i]);
            return matches
        }, map: function (elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray)
                for (; length > i; i++)
                    value = callback(elems[i], i, arg), null != value && ret.push(value);
            else
                for (i in elems)
                    value = callback(elems[i], i, arg), null != value && ret.push(value);
            return concat.apply([], ret)
        }, guid: 1, proxy: function (fn, context) {
            var tmp, args, proxy;
            return"string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), jQuery.isFunction(fn) ? (args = slice.call(arguments, 2), proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)))
            }, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy) : void 0
        }, now: Date.now, support: support}), jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase()
    });
    var Sizzle = function (window) {
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), context = context || document, results = results || [], nodeType = context.nodeType, "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType)
                return results;
            if (!seed && documentIsHTML) {
                if (11 !== nodeType && (match = rquickExpr.exec(selector)))
                    if (m = match[1]) {
                        if (9 === nodeType) {
                            if (elem = context.getElementById(m), !elem || !elem.parentNode)
                                return results;
                            if (elem.id === m)
                                return results.push(elem), results
                        } else if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m)
                            return results.push(elem), results
                    } else {
                        if (match[2])
                            return push.apply(results, context.getElementsByTagName(selector)), results;
                        if ((m = match[3]) && support.getElementsByClassName)
                            return push.apply(results, context.getElementsByClassName(m)), results
                    }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    if (nid = old = expando, newContext = context, newSelector = 1 !== nodeType && selector, 1 === nodeType && "object" !== context.nodeName.toLowerCase()) {
                        for (groups = tokenize(selector), (old = context.getAttribute("id"))?nid = old.replace(rescape, "\\$&"):context.setAttribute("id", nid), nid = "[id='" + nid + "'] ", i = groups.length; i--; )
                            groups[i] = nid + toSelector(groups[i]);
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context, newSelector = groups.join(",")
                    }
                    if (newSelector)
                        try {
                            return push.apply(results, newContext.querySelectorAll(newSelector)), results
                        } catch (qsaError) {
                        } finally {
                            old || context.removeAttribute("id")
                        }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed)
        }
        function createCache() {
            function cache(key, value) {
                return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value
            }
            var keys = [];
            return cache
        }
        function markFunction(fn) {
            return fn[expando] = !0, fn
        }
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return!!fn(div)
            } catch (e) {
                return!1
            } finally {
                div.parentNode && div.parentNode.removeChild(div), div = null
            }
        }
        function addHandle(attrs, handler) {
            for (var arr = attrs.split("|"), i = attrs.length; i--; )
                Expr.attrHandle[arr[i]] = handler
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff)
                return diff;
            if (cur)
                for (; cur = cur.nextSibling; )
                    if (cur === b)
                        return-1;
            return a ? 1 : -1
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return"input" === name && elem.type === type
            }
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return("input" === name || "button" === name) && elem.type === type
            }
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                return argument = +argument, markFunction(function (seed, matches) {
                    for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; )
                        seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
                })
            })
        }
        function testContext(context) {
            return context && "undefined" != typeof context.getElementsByTagName && context
        }
        function setFilters() {
        }
        function toSelector(tokens) {
            for (var i = 0, len = tokens.length, selector = ""; len > i; i++)
                selector += tokens[i].value;
            return selector
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && "parentNode" === dir, doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                for (; elem = elem[dir]; )
                    if (1 === elem.nodeType || checkNonElements)
                        return matcher(elem, context, xml)
            } : function (elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                if (xml) {
                    for (; elem = elem[dir]; )
                        if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml))
                            return!0
                } else
                    for (; elem = elem[dir]; )
                        if (1 === elem.nodeType || checkNonElements) {
                            if (outerCache = elem[expando] || (elem[expando] = {}), (oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName)
                                return newCache[2] = oldCache[2];
                            if (outerCache[dir] = newCache, newCache[2] = matcher(elem, context, xml))
                                return!0
                        }
            }
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                for (var i = matchers.length; i--; )
                    if (!matchers[i](elem, context, xml))
                        return!1;
                return!0
            } : matchers[0]
        }
        function multipleContexts(selector, contexts, results) {
            for (var i = 0, len = contexts.length; len > i; i++)
                Sizzle(selector, contexts[i], results);
            return results
        }
        function condense(unmatched, map, filter, context, xml) {
            for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; len > i; i++)
                (elem = unmatched[i]) && (!filter || filter(elem, context, xml)) && (newUnmatched.push(elem), mapped && map.push(i));
            return newUnmatched
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter)
                    for (temp = condense(matcherOut, postMap), postFilter(temp, [], context, xml), i = temp.length; i--; )
                        (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            for (temp = [], i = matcherOut.length; i--; )
                                (elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml)
                        }
                        for (i = matcherOut.length; i--; )
                            (elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem))
                    }
                } else
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
            })
        }
        function matcherFromTokens(tokens) {
            for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                return elem === checkContext
            }, implicitRelative, !0), matchAnyContext = addCombinator(function (elem) {
                return indexOf(checkContext, elem) > -1
            }, implicitRelative, !0), matchers = [function (elem, context, xml) {
                    var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    return checkContext = null, ret
                }]; len > i; i++)
                if (matcher = Expr.relative[tokens[i].type])
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                else {
                    if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                        for (j = ++i; len > j && !Expr.relative[tokens[j].type]; j++)
                            ;
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: " " === tokens[i - 2].type ? "*" : ""})).replace(rtrim, "$1"), matcher, j > i && matcherFromTokens(tokens.slice(i, j)), len > j && matcherFromTokens(tokens = tokens.slice(j)), len > j && toSelector(tokens))
                    }
                    matchers.push(matcher)
                }
            return elementMatcher(matchers)
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                for (outermost && (outermostContext = context !== document && context); i !== len && null != (elem = elems[i]); i++) {
                    if (byElement && elem) {
                        for (j = 0; matcher = elementMatchers[j++]; )
                            if (matcher(elem, context, xml)) {
                                results.push(elem);
                                break
                            }
                        outermost && (dirruns = dirrunsUnique)
                    }
                    bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem))
                }
                if (matchedCount += i, bySet && i !== matchedCount) {
                    for (j = 0; matcher = setMatchers[j++]; )
                        matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        if (matchedCount > 0)
                            for (; i--; )
                                unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                        setMatched = condense(setMatched)
                    }
                    push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results)
                }
                return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), unmatched
            };
            return bySet ? markFunction(superMatcher) : superMatcher
        }
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date, preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
            return a === b && (hasDuplicate = !0), 0
        }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
            for (var i = 0, len = list.length; len > i; i++)
                if (list[i] === elem)
                    return i;
            return-1
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {ID: new RegExp("^#(" + characterEncoding + ")"), CLASS: new RegExp("^\\.(" + characterEncoding + ")"), TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"), ATTR: new RegExp("^" + attributes), PSEUDO: new RegExp("^" + pseudos), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"), bool: new RegExp("^(?:" + booleans + ")$", "i"), needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")}, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function (_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : 0 > high ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320)
        }, unloadHandler = function () {
            setDocument()
        };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), arr[preferredDoc.childNodes.length].nodeType
        } catch (e) {
            push = {apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els))
                } : function (target, els) {
                    for (var j = target.length, i = 0; target[j++] = els[i++]; )
                        ;
                    target.length = j - 1
                }}
        }
        support = Sizzle.support = {}, isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? "HTML" !== documentElement.nodeName : !1
        }, setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, docElem = doc.documentElement, parent = doc.defaultView, parent && parent !== parent.top && (parent.addEventListener ? parent.addEventListener("unload", unloadHandler, !1) : parent.attachEvent && parent.attachEvent("onunload", unloadHandler)), documentIsHTML = !isXML(doc), support.attributes = assert(function (div) {
                return div.className = "i", !div.getAttribute("className")
            }), support.getElementsByTagName = assert(function (div) {
                return div.appendChild(doc.createComment("")), !div.getElementsByTagName("*").length
            }), support.getElementsByClassName = rnative.test(doc.getElementsByClassName), support.getById = assert(function (div) {
                return docElem.appendChild(div).id = expando, !doc.getElementsByName || !doc.getElementsByName(expando).length
            }), support.getById ? (Expr.find.ID = function (id, context) {
                if ("undefined" != typeof context.getElementById && documentIsHTML) {
                    var m = context.getElementById(id);
                    return m && m.parentNode ? [m] : []
                }
            }, Expr.filter.ID = function (id) {
                var attrId = id.replace(runescape, funescape);
                return function (elem) {
                    return elem.getAttribute("id") === attrId
                }
            }) : (delete Expr.find.ID, Expr.filter.ID = function (id) {
                var attrId = id.replace(runescape, funescape);
                return function (elem) {
                    var node = "undefined" != typeof elem.getAttributeNode && elem.getAttributeNode("id");
                    return node && node.value === attrId
                }
            }), Expr.find.TAG = support.getElementsByTagName ? function (tag, context) {
                return"undefined" != typeof context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if ("*" === tag) {
                    for (; elem = results[i++]; )
                        1 === elem.nodeType && tmp.push(elem);
                    return tmp
                }
                return results
            }, Expr.find.CLASS = support.getElementsByClassName && function (className, context) {
                return documentIsHTML ? context.getElementsByClassName(className) : void 0
            }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(doc.querySelectorAll)) && (assert(function (div) {
                docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\f]' msallowcapture=''><option selected=''></option></select>", div.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), div.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), div.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), div.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), div.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]")
            }), assert(function (div) {
                var input = doc.createElement("input");
                input.setAttribute("type", "hidden"), div.appendChild(input).setAttribute("name", "D"), div.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), div.querySelectorAll(":enabled").length || rbuggyQSA.push(":enabled", ":disabled"), div.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:")
            })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function (div) {
                support.disconnectedMatch = matches.call(div, "div"), matches.call(div, "[s!='']:x"), rbuggyMatches.push("!=", pseudos)
            }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
            } : function (a, b) {
                if (b)
                    for (; b = b.parentNode; )
                        if (b === a)
                            return!0;
                return!1
            }, sortOrder = hasCompare ? function (a, b) {
                if (a === b)
                    return hasDuplicate = !0, 0;
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return compare ? compare : (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1)
            } : function (a, b) {
                if (a === b)
                    return hasDuplicate = !0, 0;
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup)
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                if (aup === bup)
                    return siblingCheck(a, b);
                for (cur = a; cur = cur.parentNode; )
                    ap.unshift(cur);
                for (cur = b; cur = cur.parentNode; )
                    bp.unshift(cur);
                for (; ap[i] === bp[i]; )
                    i++;
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
            }, doc) : document
        }, Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements)
        }, Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), !(!support.matchesSelector || !documentIsHTML || rbuggyMatches && rbuggyMatches.test(expr) || rbuggyQSA && rbuggyQSA.test(expr)))
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType)
                        return ret
                } catch (e) {
                }
            return Sizzle(expr, document, null, [elem]).length > 0
        }, Sizzle.contains = function (context, elem) {
            return(context.ownerDocument || context) !== document && setDocument(context), contains(context, elem)
        }, Sizzle.attr = function (elem, name) {
            (elem.ownerDocument || elem) !== document && setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        }, Sizzle.error = function (msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg)
        }, Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), results.sort(sortOrder), hasDuplicate) {
                for (; elem = results[i++]; )
                    elem === results[i] && (j = duplicates.push(i));
                for (; j--; )
                    results.splice(duplicates[j], 1)
            }
            return sortInput = null, results
        }, getText = Sizzle.getText = function (elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (nodeType) {
                if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                    if ("string" == typeof elem.textContent)
                        return elem.textContent;
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                        ret += getText(elem)
                } else if (3 === nodeType || 4 === nodeType)
                    return elem.nodeValue
            } else
                for (; node = elem[i++]; )
                    ret += getText(node);
            return ret
        }, Expr = Sizzle.selectors = {cacheLength: 50, createPseudo: markFunction, match: matchExpr, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", first: !0}, " ": {dir: "parentNode"}, "+": {dir: "previousSibling", first: !0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (match) {
                    return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4)
                }, CHILD: function (match) {
                    return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), match
                }, PSEUDO: function (match) {
                    var excess, unquoted = !match[6] && match[2];
                    return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), match[2] = unquoted.slice(0, excess)), match.slice(0, 3))
                }}, filter: {TAG: function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return"*" === nodeNameSelector ? function () {
                        return!0
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                    }
                }, CLASS: function (className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
                        return pattern.test("string" == typeof elem.className && elem.className || "undefined" != typeof elem.getAttribute && elem.getAttribute("class") || "")
                    })
                }, ATTR: function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        return null == result ? "!=" === operator : operator ? (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator ? result === check || result.slice(0, check.length + 1) === check + "-" : !1) : !0
                    }
                }, CHILD: function (type, what, argument, first, last) {
                    var simple = "nth" !== type.slice(0, 3), forward = "last" !== type.slice(-4), ofType = "of-type" === what;
                    return 1 === first && 0 === last ? function (elem) {
                        return!!elem.parentNode
                    } : function (elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                for (; dir; ) {
                                    for (node = elem; node = node[dir]; )
                                        if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType)
                                            return!1;
                                    start = dir = "only" === type && !start && "nextSibling"
                                }
                                return!0
                            }
                            if (start = [forward ? parent.firstChild : parent.lastChild], forward && useCache) {
                                for (outerCache = parent[expando] || (parent[expando] = {}), cache = outerCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = cache[0] === dirruns && cache[2], node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); )
                                    if (1 === node.nodeType && ++diff && node === elem) {
                                        outerCache[type] = [dirruns, nodeIndex, diff];
                                        break
                                    }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns)
                                diff = cache[1];
                            else
                                for (; (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType?node.nodeName.toLowerCase() !== name:1 !== node.nodeType) || !++diff || (useCache && ((node[expando] || (node[expando] = {}))[type] = [dirruns, diff]), node !== elem)); )
                                    ;
                            return diff -= last, diff === first || diff % first === 0 && diff / first >= 0
                        }
                    }
                }, PSEUDO: function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [pseudo, pseudo, "", argument], Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                        for (var idx, matched = fn(seed, argument), i = matched.length; i--; )
                            idx = indexOf(seed, matched[i]), seed[idx] = !(matches[idx] = matched[i])
                    }) : function (elem) {
                        return fn(elem, 0, args)
                    }) : fn
                }}, pseudos: {not: markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; )
                            (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                    }) : function (elem, context, xml) {
                        return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop()
                    }
                }), has: markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0
                    }
                }), contains: markFunction(function (text) {
                    return text = text.replace(runescape, funescape), function (elem) {
                        return(elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                    }
                }), lang: markFunction(function (lang) {
                    return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), lang = lang.replace(runescape, funescape).toLowerCase(), function (elem) {
                        var elemLang;
                        do
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))
                                return elemLang = elemLang.toLowerCase(), elemLang === lang || 0 === elemLang.indexOf(lang + "-");
                        while ((elem = elem.parentNode) && 1 === elem.nodeType);
                        return!1
                    }
                }), target: function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id
                }, root: function (elem) {
                    return elem === docElem
                }, focus: function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                }, enabled: function (elem) {
                    return elem.disabled === !1
                }, disabled: function (elem) {
                    return elem.disabled === !0
                }, checked: function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return"input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
                }, selected: function (elem) {
                    return elem.parentNode && elem.parentNode.selectedIndex, elem.selected === !0
                }, empty: function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                        if (elem.nodeType < 6)
                            return!1;
                    return!0
                }, parent: function (elem) {
                    return!Expr.pseudos.empty(elem)
                }, header: function (elem) {
                    return rheader.test(elem.nodeName)
                }, input: function (elem) {
                    return rinputs.test(elem.nodeName)
                }, button: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return"input" === name && "button" === elem.type || "button" === name
                }, text: function (elem) {
                    var attr;
                    return"input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase())
                }, first: createPositionalPseudo(function () {
                    return[0]
                }), last: createPositionalPseudo(function (matchIndexes, length) {
                    return[length - 1]
                }), eq: createPositionalPseudo(function (matchIndexes, length, argument) {
                    return[0 > argument ? argument + length : argument]
                }), even: createPositionalPseudo(function (matchIndexes, length) {
                    for (var i = 0; length > i; i += 2)
                        matchIndexes.push(i);
                    return matchIndexes
                }), odd: createPositionalPseudo(function (matchIndexes, length) {
                    for (var i = 1; length > i; i += 2)
                        matchIndexes.push(i);
                    return matchIndexes
                }), lt: createPositionalPseudo(function (matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; --i >= 0; )
                        matchIndexes.push(i);
                    return matchIndexes
                }), gt: createPositionalPseudo(function (matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; ++i < length; )
                        matchIndexes.push(i);
                    return matchIndexes
                })}}, Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in{radio:!0, checkbox:!0, file:!0, password:!0, image:!0})
            Expr.pseudos[i] = createInputPseudo(i);
        for (i in{submit:!0, reset:!0})
            Expr.pseudos[i] = createButtonPseudo(i);
        return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters, tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached)
                return parseOnly ? 0 : cached.slice(0);
            for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar; ) {
                (!matched || (match = rcomma.exec(soFar))) && (match && (soFar = soFar.slice(match[0].length) || soFar), groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), tokens.push({value: matched, type: match[0].replace(rtrim, " ")}), soFar = soFar.slice(matched.length));
                for (type in Expr.filter)
                    !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), tokens.push({value: matched, type: type, matches: match}), soFar = soFar.slice(matched.length));
                if (!matched)
                    break
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
        }, compile = Sizzle.compile = function (selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                for (match || (match = tokenize(selector)), i = match.length; i--; )
                    cached = matcherFromTokens(match[i]), cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), cached.selector = selector
            }
            return cached
        }, select = Sizzle.select = function (selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            if (results = results || [], 1 === match.length) {
                if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && support.getById && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                    if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], !context)
                        return results;
                    compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length)
                }
                for (i = matchExpr.needsContext.test(selector)?0:tokens.length; i-- && (token = tokens[i], !Expr.relative[type = token.type]); )
                    if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                        if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector)
                            return push.apply(results, seed), results;
                        break
                    }
            }
            return(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context), results
        }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function (div1) {
            return 1 & div1.compareDocumentPosition(document.createElement("div"))
        }), assert(function (div) {
            return div.innerHTML = "<a href='#'></a>", "#" === div.firstChild.getAttribute("href")
        }) || addHandle("type|href|height|width", function (elem, name, isXML) {
            return isXML ? void 0 : elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
        }), support.attributes && assert(function (div) {
            return div.innerHTML = "<input/>", div.firstChild.setAttribute("value", ""), "" === div.firstChild.getAttribute("value")
        }) || addHandle("value", function (elem, name, isXML) {
            return isXML || "input" !== elem.nodeName.toLowerCase() ? void 0 : elem.defaultValue
        }), assert(function (div) {
            return null == div.getAttribute("disabled")
        }) || addHandle(booleans, function (elem, name, isXML) {
            var val;
            return isXML ? void 0 : elem[name] === !0 ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        }), Sizzle
    }(window);
    jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, risSimple = /^.[^:#\[\.,]*$/;
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return 1 === elem.nodeType
        }))
    }, jQuery.fn.extend({find: function (selector) {
            var i, len = this.length, ret = [], self = this;
            if ("string" != typeof selector)
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; len > i; i++)
                        if (jQuery.contains(self[i], this))
                            return!0
                }));
            for (i = 0; len > i; i++)
                jQuery.find(selector, self[i], ret);
            return ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret), ret.selector = this.selector ? this.selector + " " + selector : selector, ret
        }, filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], !1))
        }, not: function (selector) {
            return this.pushStack(winnow(this, selector || [], !0))
        }, is: function (selector) {
            return!!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length
        }});
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context) {
        var match, elem;
        if (!selector)
            return this;
        if ("string" == typeof selector) {
            if (match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [null, selector, null] : rquickExpr.exec(selector), !match || !match[1] && context)
                return!context || context.jquery ? (context || rootjQuery).find(selector) : this.constructor(context).find(selector);
            if (match[1]) {
                if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), rsingleTag.test(match[1]) && jQuery.isPlainObject(context))
                    for (match in context)
                        jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                return this
            }
            return elem = document.getElementById(match[2]), elem && elem.parentNode && (this.length = 1, this[0] = elem), this.context = document, this.selector = selector, this
        }
        return selector.nodeType ? (this.context = this[0] = selector, this.length = 1, this) : jQuery.isFunction(selector) ? "undefined" != typeof rootjQuery.ready ? rootjQuery.ready(selector) : selector(jQuery) : (void 0 !== selector.selector && (this.selector = selector.selector, this.context = selector.context), jQuery.makeArray(selector, this))
    };
    init.prototype = jQuery.fn, rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {children: !0, contents: !0, next: !0, prev: !0};
    jQuery.extend({dir: function (elem, dir, until) {
            for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType; )
                if (1 === elem.nodeType) {
                    if (truncate && jQuery(elem).is(until))
                        break;
                    matched.push(elem)
                }
            return matched
        }, sibling: function (n, elem) {
            for (var matched = []; n; n = n.nextSibling)
                1 === n.nodeType && n !== elem && matched.push(n);
            return matched
        }}), jQuery.fn.extend({has: function (target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function () {
                for (var i = 0; l > i; i++)
                    if (jQuery.contains(this, targets[i]))
                        return!0
            })
        }, closest: function (selectors, context) {
            for (var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || "string" != typeof selectors ? jQuery(selectors, context || this.context) : 0; l > i; i++)
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break
                    }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched)
        }, index: function (elem) {
            return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        }, add: function (selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))))
        }, addBack: function (selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
        }}), jQuery.each({parent: function (elem) {
            var parent = elem.parentNode;
            return parent && 11 !== parent.nodeType ? parent : null
        }, parents: function (elem) {
            return jQuery.dir(elem, "parentNode")
        }, parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until)
        }, next: function (elem) {
            return sibling(elem, "nextSibling")
        }, prev: function (elem) {
            return sibling(elem, "previousSibling")
        }, nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling")
        }, prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling")
        }, nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until)
        }, prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until)
        }, siblings: function (elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem)
        }, children: function (elem) {
            return jQuery.sibling(elem.firstChild)
        }, contents: function (elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes)
        }}, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);
            return"Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), this.length > 1 && (guaranteedUnique[name] || jQuery.unique(matched), rparentsprev.test(name) && matched.reverse()), this.pushStack(matched)
        }
    });
    var rnotwhite = /\S+/g, optionsCache = {};
    jQuery.Callbacks = function (options) {
        options = "string" == typeof options ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function (data) {
            for (memory = options.memory && data, fired = !0, firingIndex = firingStart || 0, firingStart = 0, firingLength = list.length, firing = !0; list && firingLength > firingIndex; firingIndex++)
                if (list[firingIndex].apply(data[0], data[1]) === !1 && options.stopOnFalse) {
                    memory = !1;
                    break
                }
            firing = !1, list && (stack ? stack.length && fire(stack.shift()) : memory ? list = [] : self.disable())
        }, self = {add: function () {
                if (list) {
                    var start = list.length;
                    !function add(args) {
                        jQuery.each(args, function (_, arg) {
                            var type = jQuery.type(arg);
                            "function" === type ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== type && add(arg)
                        })
                    }(arguments), firing ? firingLength = list.length : memory && (firingStart = start, fire(memory))
                }
                return this
            }, remove: function () {
                return list && jQuery.each(arguments, function (_, arg) {
                    for (var index; (index = jQuery.inArray(arg, list, index)) > - 1; )
                        list.splice(index, 1), firing && (firingLength >= index && firingLength--, firingIndex >= index && firingIndex--)
                }), this
            }, has: function (fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !(!list || !list.length)
            }, empty: function () {
                return list = [], firingLength = 0, this
            }, disable: function () {
                return list = stack = memory = void 0, this
            }, disabled: function () {
                return!list
            }, lock: function () {
                return stack = void 0, memory || self.disable(), this
            }, locked: function () {
                return!stack
            }, fireWith: function (context, args) {
                return!list || fired && !stack || (args = args || [], args = [context, args.slice ? args.slice() : args], firing ? stack.push(args) : fire(args)), this
            }, fire: function () {
                return self.fireWith(this, arguments), this
            }, fired: function () {
                return!!fired
            }};
        return self
    }, jQuery.extend({Deferred: function (func) {
            var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]], state = "pending", promise = {state: function () {
                    return state
                }, always: function () {
                    return deferred.done(arguments).fail(arguments), this
                }, then: function () {
                    var fns = arguments;
                    return jQuery.Deferred(function (newDefer) {
                        jQuery.each(tuples, function (i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            deferred[tuple[1]](function () {
                                var returned = fn && fn.apply(this, arguments);
                                returned && jQuery.isFunction(returned.promise) ? returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify) : newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments)
                            })
                        }), fns = null
                    }).promise()
                }, promise: function (obj) {
                    return null != obj ? jQuery.extend(obj, promise) : promise
                }}, deferred = {};
            return promise.pipe = promise.then, jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add, stateString && list.add(function () {
                    state = stateString
                }, tuples[1 ^ i][2].disable, tuples[2][2].lock), deferred[tuple[0]] = function () {
                    return deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments), this
                }, deferred[tuple[0] + "With"] = list.fireWith
            }), promise.promise(deferred), func && func.call(deferred, deferred), deferred
        }, when: function (subordinate) {
            var progressValues, progressContexts, resolveContexts, i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = 1 !== length || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = 1 === remaining ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                return function (value) {
                    contexts[i] = this, values[i] = arguments.length > 1 ? slice.call(arguments) : value, values === progressValues ? deferred.notifyWith(contexts, values) : --remaining || deferred.resolveWith(contexts, values)
                }
            };
            if (length > 1)
                for (progressValues = new Array(length), progressContexts = new Array(length), resolveContexts = new Array(length); length > i; i++)
                    resolveValues[i] && jQuery.isFunction(resolveValues[i].promise) ? resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues)) : --remaining;
            return remaining || deferred.resolveWith(resolveContexts, resolveValues), deferred.promise()
        }});
    var readyList;
    jQuery.fn.ready = function (fn) {
        return jQuery.ready.promise().done(fn), this
    }, jQuery.extend({isReady: !1, readyWait: 1, holdReady: function (hold) {
            hold ? jQuery.readyWait++ : jQuery.ready(!0)
        }, ready: function (wait) {
            (wait === !0 ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, wait !== !0 && --jQuery.readyWait > 0 || (readyList.resolveWith(document, [jQuery]), jQuery.fn.triggerHandler && (jQuery(document).triggerHandler("ready"), jQuery(document).off("ready"))))
        }}), jQuery.ready.promise = function (obj) {
        return readyList || (readyList = jQuery.Deferred(), "complete" === document.readyState ? setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed, !1), window.addEventListener("load", completed, !1))), readyList.promise(obj)
    }, jQuery.ready.promise();
    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = null == key;
        if ("object" === jQuery.type(key)) {
            chainable = !0;
            for (i in key)
                jQuery.access(elems, fn, i, key[i], !0, emptyGet, raw)
        } else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function (elem, key, value) {
            return bulk.call(jQuery(elem), value)
        })), fn))
            for (; len > i; i++)
                fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet
    };
    jQuery.acceptData = function (owner) {
        return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType
    }, Data.uid = 1, Data.accepts = jQuery.acceptData, Data.prototype = {key: function (owner) {
            if (!Data.accepts(owner))
                return 0;
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = {value: unlock}, Object.defineProperties(owner, descriptor)
                } catch (e) {
                    descriptor[this.expando] = unlock, jQuery.extend(owner, descriptor)
                }
            }
            return this.cache[unlock] || (this.cache[unlock] = {}), unlock
        }, set: function (owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if ("string" == typeof data)
                cache[data] = value;
            else if (jQuery.isEmptyObject(cache))
                jQuery.extend(this.cache[unlock], data);
            else
                for (prop in data)
                    cache[prop] = data[prop];
            return cache
        }, get: function (owner, key) {
            var cache = this.cache[this.key(owner)];
            return void 0 === key ? cache : cache[key]
        }, access: function (owner, key, value) {
            var stored;
            return void 0 === key || key && "string" == typeof key && void 0 === value ? (stored = this.get(owner, key), void 0 !== stored ? stored : this.get(owner, jQuery.camelCase(key))) : (this.set(owner, key, value), void 0 !== value ? value : key)
        }, remove: function (owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (void 0 === key)
                this.cache[unlock] = {};
            else {
                jQuery.isArray(key) ? name = key.concat(key.map(jQuery.camelCase)) : (camel = jQuery.camelCase(key), key in cache ? name = [key, camel] : (name = camel, name = name in cache ? [name] : name.match(rnotwhite) || [])), i = name.length;
                for (; i--; )
                    delete cache[name[i]]
            }
        }, hasData: function (owner) {
            return!jQuery.isEmptyObject(this.cache[owner[this.expando]] || {})
        }, discard: function (owner) {
            owner[this.expando] && delete this.cache[owner[this.expando]]
        }};
    var data_priv = new Data, data_user = new Data, rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    jQuery.extend({hasData: function (elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem)
        }, data: function (elem, name, data) {
            return data_user.access(elem, name, data)
        }, removeData: function (elem, name) {
            data_user.remove(elem, name)
        }, _data: function (elem, name, data) {
            return data_priv.access(elem, name, data)
        }, _removeData: function (elem, name) {
            data_priv.remove(elem, name)
        }}), jQuery.fn.extend({data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (void 0 === key) {
                if (this.length && (data = data_user.get(elem), 1 === elem.nodeType && !data_priv.get(elem, "hasDataAttrs"))) {
                    for (i = attrs.length; i--; )
                        attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), dataAttr(elem, name, data[name])));
                    data_priv.set(elem, "hasDataAttrs", !0)
                }
                return data
            }
            return"object" == typeof key ? this.each(function () {
                data_user.set(this, key)
            }) : access(this, function (value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && void 0 === value) {
                    if (data = data_user.get(elem, key), void 0 !== data)
                        return data;
                    if (data = data_user.get(elem, camelKey), void 0 !== data)
                        return data;
                    if (data = dataAttr(elem, camelKey, void 0), void 0 !== data)
                        return data
                } else
                    this.each(function () {
                        var data = data_user.get(this, camelKey);
                        data_user.set(this, camelKey, value), -1 !== key.indexOf("-") && void 0 !== data && data_user.set(this, key, value)
                    })
            }, null, value, arguments.length > 1, null, !0)
        }, removeData: function (key) {
            return this.each(function () {
                data_user.remove(this, key)
            })
        }}), jQuery.extend({queue: function (elem, type, data) {
            var queue;
            return elem ? (type = (type || "fx") + "queue", queue = data_priv.get(elem, type), data && (!queue || jQuery.isArray(data) ? queue = data_priv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), queue || []) : void 0
        }, dequeue: function (elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                jQuery.dequeue(elem, type)
            };
            "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire()
        }, _queueHooks: function (elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function () {
                    data_priv.remove(elem, [type + "queue", key])
                })})
        }}), jQuery.fn.extend({queue: function (type, data) {
            var setter = 2;
            return"string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type)
            })
        }, dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type)
            })
        }, clearQueue: function (type) {
            return this.queue(type || "fx", [])
        }, promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                --count || defer.resolveWith(elements, [elements])
            };
            for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--; )
                tmp = data_priv.get(elements[i], type + "queueHooks"), tmp && tmp.empty && (count++, tmp.empty.add(resolve));
            return resolve(), defer.promise(obj)
        }});
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, cssExpand = ["Top", "Right", "Bottom", "Left"], isHidden = function (elem, el) {
        return elem = el || elem, "none" === jQuery.css(elem, "display") || !jQuery.contains(elem.ownerDocument, elem)
    }, rcheckableType = /^(?:checkbox|radio)$/i;
    !function () {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue
    }();
    var strundefined = "undefined";
    support.focusinBubbles = "onfocusin"in window;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    jQuery.event = {global: {}, add: function (elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (elemData)
                for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, selector = handleObjIn.selector), handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}), (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0
                }), types = (types || "").match(rnotwhite) || [""], t = types.length; t--; )
                    tmp = rtypenamespace.exec(types[t]) || [], type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, handleObj = jQuery.extend({type: type, origType: origType, data: data, handler: handler, guid: handler.guid, selector: selector, needsContext: selector && jQuery.expr.match.needsContext.test(selector), namespace: namespaces.join(".")}, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, special.setup && special.setup.call(elem, data, namespaces, eventHandle) !== !1 || elem.addEventListener && elem.addEventListener(type, eventHandle, !1)), special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), jQuery.event.global[type] = !0)
        }, remove: function (elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (elemData && (events = elemData.events)) {
                for (types = (types || "").match(rnotwhite) || [""], t = types.length; t--; )
                    if (tmp = rtypenamespace.exec(types[t]) || [], type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                        for (special = jQuery.event.special[type] || {}, type = (selector?special.delegateType:special.bindType) || type, handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), origCount = j = handlers.length; j--; )
                            handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                        origCount && !handlers.length && (special.teardown && special.teardown.call(elem, namespaces, elemData.handle) !== !1 || jQuery.removeEvent(elem, type, elemData.handle), delete events[type])
                    } else
                        for (type in events)
                            jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                jQuery.isEmptyObject(events) && (delete elemData.handle, data_priv.remove(elem, "events"))
            }
        }, trigger: function (event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") >= 0 && (namespaces = type.split("."), type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event), event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, event.result = void 0, event.target || (event.target = elem), data = null == data ? [event] : jQuery.makeArray(data, [event]), special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || special.trigger.apply(elem, data) !== !1)) {
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode)
                        eventPath.push(cur), tmp = cur;
                    tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                }
                for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); )
                    event.type = i > 1 ? bubbleType : special.bindType || type, handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle"), handle && handle.apply(cur, data), handle = ontype && cur[ontype], handle && handle.apply && jQuery.acceptData(cur) && (event.result = handle.apply(cur, data), event.result === !1 && event.preventDefault());
                return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && special._default.apply(eventPath.pop(), data) !== !1 || !jQuery.acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype], tmp && (elem[ontype] = null), jQuery.event.triggered = type, elem[type](), jQuery.event.triggered = void 0, tmp && (elem[ontype] = tmp)), event.result
            }
        }, dispatch: function (event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            if (args[0] = event, event.delegateTarget = this, !special.preDispatch || special.preDispatch.call(this, event) !== !1) {
                for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); )
                    for (event.currentTarget = matched.elem, j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); )
                        (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) && (event.handleObj = handleObj, event.data = handleObj.data, ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args), void 0 !== ret && (event.result = ret) === !1 && (event.preventDefault(), event.stopPropagation()));
                return special.postDispatch && special.postDispatch.call(this, event), event.result
            }
        }, handlers: function (event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || "click" !== event.type))
                for (; cur !== this; cur = cur.parentNode || this)
                    if (cur.disabled !== !0 || "click" !== event.type) {
                        for (matches = [], i = 0; delegateCount > i; i++)
                            handleObj = handlers[i], sel = handleObj.selector + " ", void 0 === matches[sel] && (matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length), matches[sel] && matches.push(handleObj);
                        matches.length && handlerQueue.push({elem: cur, handlers: matches})
                    }
            return delegateCount < handlers.length && handlerQueue.push({elem: this, handlers: handlers.slice(delegateCount)}), handlerQueue
        }, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: {props: "char charCode key keyCode".split(" "), filter: function (event, original) {
                return null == event.which && (event.which = null != original.charCode ? original.charCode : original.keyCode), event
            }}, mouseHooks: {props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function (event, original) {
                var eventDoc, doc, body, button = original.button;
                return null == event.pageX && null != original.clientX && (eventDoc = event.target.ownerDocument || document, doc = eventDoc.documentElement, body = eventDoc.body, event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0), event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)), event.which || void 0 === button || (event.which = 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0), event
            }}, fix: function (event) {
            if (event[jQuery.expando])
                return event;
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            for (fixHook || (this.fixHooks[type] = fixHook = rmouseEvent.test(type)?this.mouseHooks:rkeyEvent.test(type)?this.keyHooks:{}), copy = fixHook.props?this.props.concat(fixHook.props):this.props, event = new jQuery.Event(originalEvent), i = copy.length; i--; )
                prop = copy[i], event[prop] = originalEvent[prop];
            return event.target || (event.target = document), 3 === event.target.nodeType && (event.target = event.target.parentNode), fixHook.filter ? fixHook.filter(event, originalEvent) : event
        }, special: {load: {noBubble: !0}, focus: {trigger: function () {
                    return this !== safeActiveElement() && this.focus ? (this.focus(), !1) : void 0
                }, delegateType: "focusin"}, blur: {trigger: function () {
                    return this === safeActiveElement() && this.blur ? (this.blur(), !1) : void 0
                }, delegateType: "focusout"}, click: {trigger: function () {
                    return"checkbox" === this.type && this.click && jQuery.nodeName(this, "input") ? (this.click(), !1) : void 0
                }, _default: function (event) {
                    return jQuery.nodeName(event.target, "a")
                }}, beforeunload: {postDispatch: function (event) {
                    void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result)
                }}}, simulate: function (type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event, event, {type: type, isSimulated: !0, originalEvent: {}});
            bubble ? jQuery.event.trigger(e, null, elem) : jQuery.event.dispatch.call(elem, e), e.isDefaultPrevented() && event.preventDefault()
        }}, jQuery.removeEvent = function (elem, type, handle) {
        elem.removeEventListener && elem.removeEventListener(type, handle, !1)
    }, jQuery.Event = function (src, props) {
        return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && src.returnValue === !1 ? returnTrue : returnFalse) : this.type = src, props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), void(this[jQuery.expando] = !0)) : new jQuery.Event(src, props)
    }, jQuery.Event.prototype = {isDefaultPrevented: returnFalse, isPropagationStopped: returnFalse, isImmediatePropagationStopped: returnFalse, preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue, e && e.preventDefault && e.preventDefault()
        }, stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue, e && e.stopPropagation && e.stopPropagation()
        }, stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), this.stopPropagation()
        }}, jQuery.each({mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"}, function (orig, fix) {
        jQuery.event.special[orig] = {delegateType: fix, bindType: fix, handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                return(!related || related !== target && !jQuery.contains(target, related)) && (event.type = handleObj.origType, ret = handleObj.handler.apply(this, arguments), event.type = fix), ret
            }}
    }), support.focusinBubbles || jQuery.each({focus: "focusin", blur: "focusout"}, function (orig, fix) {
        var handler = function (event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), !0)
        };
        jQuery.event.special[fix] = {setup: function () {
                var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                attaches || doc.addEventListener(orig, handler, !0), data_priv.access(doc, fix, (attaches || 0) + 1)
            }, teardown: function () {
                var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                attaches ? data_priv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), data_priv.remove(doc, fix))
            }}
    }), jQuery.fn.extend({on: function (types, selector, data, fn, one) {
            var origFn, type;
            if ("object" == typeof types) {
                "string" != typeof selector && (data = data || selector, selector = void 0);
                for (type in types)
                    this.on(type, selector, data, types[type], one);
                return this
            }
            if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, data = void 0) : (fn = data, data = selector, selector = void 0)), fn === !1)
                fn = returnFalse;
            else if (!fn)
                return this;
            return 1 === one && (origFn = fn, fn = function (event) {
                return jQuery().off(event), origFn.apply(this, arguments)
            }, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), this.each(function () {
                jQuery.event.add(this, types, fn, data, selector)
            })
        }, one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1)
        }, off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj)
                return handleObj = types.handleObj, jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), this;
            if ("object" == typeof types) {
                for (type in types)
                    this.off(type, selector, types[type]);
                return this
            }
            return(selector === !1 || "function" == typeof selector) && (fn = selector, selector = void 0), fn === !1 && (fn = returnFalse), this.each(function () {
                jQuery.event.remove(this, types, fn, selector)
            })
        }, trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this)
            })
        }, triggerHandler: function (type, data) {
            var elem = this[0];
            return elem ? jQuery.event.trigger(type, data, elem, !0) : void 0;
        }});
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {option: [1, "<select multiple='multiple'>", "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""]};
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td, jQuery.extend({clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem)))
                for (destElements = getAll(clone), srcElements = getAll(elem), i = 0, l = srcElements.length; l > i; i++)
                    fixInput(srcElements[i], destElements[i]);
            if (dataAndEvents)
                if (deepDataAndEvents)
                    for (srcElements = srcElements || getAll(elem), destElements = destElements || getAll(clone), i = 0, l = srcElements.length; l > i; i++)
                        cloneCopyEvent(srcElements[i], destElements[i]);
                else
                    cloneCopyEvent(elem, clone);
            return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), clone
        }, buildFragment: function (elems, context, scripts, selection) {
            for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; l > i; i++)
                if (elem = elems[i], elem || 0 === elem)
                    if ("object" === jQuery.type(elem))
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    else if (rhtml.test(elem)) {
                        for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2], j = wrap[0]; j--; )
                            tmp = tmp.lastChild;
                        jQuery.merge(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = ""
                    } else
                        nodes.push(context.createTextNode(elem));
            for (fragment.textContent = "", i = 0; elem = nodes[i++]; )
                if ((!selection || -1 === jQuery.inArray(elem, selection)) && (contains = jQuery.contains(elem.ownerDocument, elem), tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), scripts))
                    for (j = 0; elem = tmp[j++]; )
                        rscriptType.test(elem.type || "") && scripts.push(elem);
            return fragment
        }, cleanData: function (elems) {
            for (var data, elem, type, key, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++) {
                if (jQuery.acceptData(elem) && (key = elem[data_priv.expando], key && (data = data_priv.cache[key]))) {
                    if (data.events)
                        for (type in data.events)
                            special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                    data_priv.cache[key] && delete data_priv.cache[key]
                }
                delete data_user.cache[elem[data_user.expando]]
            }
        }}), jQuery.fn.extend({text: function (value) {
            return access(this, function (value) {
                return void 0 === value ? jQuery.text(this) : this.empty().each(function () {
                    (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = value)
                })
            }, null, value, arguments.length)
        }, append: function () {
            return this.domManip(arguments, function (elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem)
                }
            })
        }, prepend: function () {
            return this.domManip(arguments, function (elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild)
                }
            })
        }, before: function () {
            return this.domManip(arguments, function (elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this)
            })
        }, after: function () {
            return this.domManip(arguments, function (elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling)
            })
        }, remove: function (selector, keepData) {
            for (var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0; null != (elem = elems[i]); i++)
                keepData || 1 !== elem.nodeType || jQuery.cleanData(getAll(elem)), elem.parentNode && (keepData && jQuery.contains(elem.ownerDocument, elem) && setGlobalEval(getAll(elem, "script")), elem.parentNode.removeChild(elem));
            return this
        }, empty: function () {
            for (var elem, i = 0; null != (elem = this[i]); i++)
                1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.textContent = "");
            return this
        }, clone: function (dataAndEvents, deepDataAndEvents) {
            return dataAndEvents = null == dataAndEvents ? !1 : dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
            })
        }, html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (void 0 === value && 1 === elem.nodeType)
                    return elem.innerHTML;
                if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (; l > i; i++)
                            elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.innerHTML = value);
                        elem = 0
                    } catch (e) {
                    }
                }
                elem && this.empty().append(value)
            }, null, value, arguments.length)
        }, replaceWith: function () {
            var arg = arguments[0];
            return this.domManip(arguments, function (elem) {
                arg = this.parentNode, jQuery.cleanData(getAll(this)), arg && arg.replaceChild(elem, this)
            }), arg && (arg.length || arg.nodeType) ? this : this.remove()
        }, detach: function (selector) {
            return this.remove(selector, !0)
        }, domManip: function (args, callback) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value))
                return this.each(function (index) {
                    var self = set.eq(index);
                    isFunction && (args[0] = value.call(this, index, self.html())), self.domManip(args, callback)
                });
            if (l && (fragment = jQuery.buildFragment(args, this[0].ownerDocument, !1, this), first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), first)) {
                for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; l > i; i++)
                    node = fragment, i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), callback.call(this[i], node, i);
                if (hasScripts)
                    for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), i = 0; hasScripts > i; i++)
                        node = scripts[i], rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : jQuery.globalEval(node.textContent.replace(rcleanScript, "")))
            }
            return this
        }}), jQuery.each({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, function (name, original) {
        jQuery.fn[name] = function (selector) {
            for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; last >= i; i++)
                elems = i === last ? this : this.clone(!0), jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
            return this.pushStack(ret)
        }
    });
    var iframe, elemdisplay = {}, rmargin = /^margin/, rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), getStyles = function (elem) {
        return elem.ownerDocument.defaultView.opener ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : window.getComputedStyle(elem, null)
    };
    !function () {
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", div.innerHTML = "", docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = "1%" !== divStyle.top, boxSizingReliableVal = "4px" === divStyle.width, docElem.removeChild(container)
        }
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement("div"), div = document.createElement("div");
        div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", support.clearCloneStyle = "content-box" === div.style.backgroundClip, container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", container.appendChild(div), window.getComputedStyle && jQuery.extend(support, {pixelPosition: function () {
                return computePixelPositionAndBoxSizingReliable(), pixelPositionVal
            }, boxSizingReliable: function () {
                return null == boxSizingReliableVal && computePixelPositionAndBoxSizingReliable(), boxSizingReliableVal
            }, reliableMarginRight: function () {
                var ret, marginDiv = div.appendChild(document.createElement("div"));
                return marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", marginDiv.style.marginRight = marginDiv.style.width = "0", div.style.width = "1px", docElem.appendChild(container), ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight), docElem.removeChild(container), div.removeChild(marginDiv), ret
            }}))
    }(), jQuery.swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options)
            old[name] = elem.style[name], elem.style[name] = options[name];
        ret = callback.apply(elem, args || []);
        for (name in options)
            elem.style[name] = old[name];
        return ret
    };
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {position: "absolute", visibility: "hidden", display: "block"}, cssNormalTransform = {letterSpacing: "0", fontWeight: "400"}, cssPrefixes = ["Webkit", "O", "Moz", "ms"];
    jQuery.extend({cssHooks: {opacity: {get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return"" === ret ? "1" : ret
                    }
                }}}, cssNumber: {columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0}, cssProps: {"float": "cssFloat"}, style: function (elem, name, value, extra) {
            if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value ? hooks && "get"in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name] : (type = typeof value, "string" === type && (ret = rrelNum.exec(value)) && (value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)), type = "number"), null != value && value === value && ("number" !== type || jQuery.cssNumber[origName] || (value += "px"), support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), hooks && "set"in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (style[name] = value)), void 0)
            }
        }, css: function (elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], hooks && "get"in hooks && (val = hooks.get(elem, !0, extra)), void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), "" === extra || extra ? (num = parseFloat(val), extra === !0 || jQuery.isNumeric(num) ? num || 0 : val) : val
        }}), jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {get: function (elem, computed, extra) {
                return computed ? rdisplayswap.test(jQuery.css(elem, "display")) && 0 === elem.offsetWidth ? jQuery.swap(elem, cssShow, function () {
                    return getWidthOrHeight(elem, name, extra)
                }) : getWidthOrHeight(elem, name, extra) : void 0
            }, set: function (elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles) : 0)
            }}
    }), jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
        return computed ? jQuery.swap(elem, {display: "inline-block"}, curCSS, [elem, "marginRight"]) : void 0
    }), jQuery.each({margin: "", padding: "", border: "Width"}, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {expand: function (value) {
                for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [value]; 4 > i; i++)
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded
            }}, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber)
    }), jQuery.fn.extend({css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    for (styles = getStyles(elem), len = name.length; len > i; i++)
                        map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                    return map
                }
                return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
            }, name, value, arguments.length > 1)
        }, show: function () {
            return showHide(this, !0)
        }, hide: function () {
            return showHide(this)
        }, toggle: function (state) {
            return"boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function () {
                isHidden(this) ? jQuery(this).show() : jQuery(this).hide()
            })
        }}), jQuery.Tween = Tween, Tween.prototype = {constructor: Tween, init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem, this.prop = prop, this.easing = easing || "swing", this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
        }, cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
        }, run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this
        }}, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {_default: {get: function (tween) {
                var result;
                return null == tween.elem[tween.prop] || tween.elem.style && null != tween.elem.style[tween.prop] ? (result = jQuery.css(tween.elem, tween.prop, ""), result && "auto" !== result ? result : 0) : tween.elem[tween.prop]
            }, set: function (tween) {
                jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : tween.elem.style && (null != tween.elem.style[jQuery.cssProps[tween.prop]] || jQuery.cssHooks[tween.prop]) ? jQuery.style(tween.elem, tween.prop, tween.now + tween.unit) : tween.elem[tween.prop] = tween.now
            }}}, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function (tween) {
            tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now)
        }}, jQuery.easing = {linear: function (p) {
            return p
        }, swing: function (p) {
            return.5 - Math.cos(p * Math.PI) / 2
        }}, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {"*": [function (prop, value) {
                var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), start = (jQuery.cssNumber[prop] || "px" !== unit && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                if (start && start[3] !== unit) {
                    unit = unit || start[3], parts = parts || [], start = +target || 1;
                    do
                        scale = scale || ".5", start /= scale, jQuery.style(tween.elem, prop, start + unit);
                    while (scale !== (scale = tween.cur() / target) && 1 !== scale && --maxIterations)
                }
                return parts && (start = tween.start = +start || +target || 0, tween.unit = unit, tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2]), tween
            }]};
    jQuery.Animation = jQuery.extend(Animation, {tweener: function (props, callback) {
            jQuery.isFunction(props) ? (callback = props, props = ["*"]) : props = props.split(" ");
            for (var prop, index = 0, length = props.length; length > index; index++)
                prop = props[index], tweeners[prop] = tweeners[prop] || [], tweeners[prop].unshift(callback)
        }, prefilter: function (callback, prepend) {
            prepend ? animationPrefilters.unshift(callback) : animationPrefilters.push(callback)
        }}), jQuery.speed = function (speed, easing, fn) {
        var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {complete: fn || !fn && easing || jQuery.isFunction(speed) && speed, duration: speed, easing: fn && easing || easing && !jQuery.isFunction(easing) && easing};
        return opt.duration = jQuery.fx.off ? 0 : "number" == typeof opt.duration ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default, (null == opt.queue || opt.queue === !0) && (opt.queue = "fx"), opt.old = opt.complete, opt.complete = function () {
            jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue)
        }, opt
    }, jQuery.fn.extend({fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback)
        }, animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                (empty || data_priv.get(this, "finish")) && anim.stop(!0)
            };
            return doAnimation.finish = doAnimation, empty || optall.queue === !1 ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
        }, stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop, stop(gotoEnd)
            };
            return"string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), clearQueue && type !== !1 && this.queue(type || "fx", []), this.each(function () {
                var dequeue = !0, index = null != type && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
                if (index)
                    data[index] && data[index].stop && stopQueue(data[index]);
                else
                    for (index in data)
                        data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                for (index = timers.length; index--; )
                    timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), dequeue = !1, timers.splice(index, 1));
                (dequeue || !gotoEnd) && jQuery.dequeue(this, type)
            })
        }, finish: function (type) {
            return type !== !1 && (type = type || "fx"), this.each(function () {
                var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), index = timers.length; index--; )
                    timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), timers.splice(index, 1));
                for (index = 0; length > index; index++)
                    queue[index] && queue[index].finish && queue[index].finish.call(this);
                delete data.finish
            })
        }}), jQuery.each(["toggle", "show", "hide"], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback)
        }
    }), jQuery.each({slideDown: genFx("show"), slideUp: genFx("hide"), slideToggle: genFx("toggle"), fadeIn: {opacity: "show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback)
        }
    }), jQuery.timers = [], jQuery.fx.tick = function () {
        var timer, i = 0, timers = jQuery.timers;
        for (fxNow = jQuery.now(); i < timers.length; i++)
            timer = timers[i], timer() || timers[i] !== timer || timers.splice(i--, 1);
        timers.length || jQuery.fx.stop(), fxNow = void 0
    }, jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer), timer() ? jQuery.fx.start() : jQuery.timers.pop()
    }, jQuery.fx.interval = 13, jQuery.fx.start = function () {
        timerId || (timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval))
    }, jQuery.fx.stop = function () {
        clearInterval(timerId), timerId = null
    }, jQuery.fx.speeds = {slow: 600, fast: 200, _default: 400}, jQuery.fn.delay = function (time, type) {
        return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time, type = type || "fx", this.queue(type, function (next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function () {
                clearTimeout(timeout)
            }
        })
    }, function () {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, select.disabled = !0, support.optDisabled = !opt.disabled, input = document.createElement("input"), input.value = "t", input.type = "radio", support.radioValue = "t" === input.value
    }();
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1)
        }, removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name)
            })
        }}), jQuery.extend({attr: function (elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (elem && 3 !== nType && 8 !== nType && 2 !== nType)
                return typeof elem.getAttribute === strundefined ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (name = name.toLowerCase(), hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook)), void 0 === value ? hooks && "get"in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name), null == ret ? void 0 : ret) : null !== value ? hooks && "set"in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), value) : void jQuery.removeAttr(elem, name))
        }, removeAttr: function (elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && 1 === elem.nodeType)
                for (; name = attrNames[i++]; )
                    propName = jQuery.propFix[name] || name, jQuery.expr.match.bool.test(name) && (elem[propName] = !1), elem.removeAttribute(name)
        }, attrHooks: {type: {set: function (elem, value) {
                    if (!support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        return elem.setAttribute("type", value), val && (elem.value = val), value
                    }
                }}}}), boolHook = {set: function (elem, value, name) {
            return value === !1 ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name), name
        }}, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle;
            return isXML || (handle = attrHandle[name], attrHandle[name] = ret, ret = null != getter(elem, name, isXML) ? name.toLowerCase() : null, attrHandle[name] = handle), ret
        }
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1)
        }, removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name]
            })
        }}), jQuery.extend({propFix: {"for": "htmlFor", "class": "className"}, prop: function (elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (elem && 3 !== nType && 8 !== nType && 2 !== nType)
                return notxml = 1 !== nType || !jQuery.isXMLDoc(elem), notxml && (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set"in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get"in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name]
        }, propHooks: {tabIndex: {get: function (elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1
                }}}}), support.optSelected || (jQuery.propHooks.selected = {get: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.parentNode && parent.parentNode.selectedIndex, null
        }}), jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        jQuery.propFix[this.toLowerCase()] = this
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({addClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = "string" == typeof value && value, i = 0, len = this.length;
            if (jQuery.isFunction(value))
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className))
                });
            if (proceed)
                for (classes = (value || "").match(rnotwhite) || []; len > i; i++)
                    if (elem = this[i], cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ")) {
                        for (j = 0; clazz = classes[j++]; )
                            cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                        finalValue = jQuery.trim(cur), elem.className !== finalValue && (elem.className = finalValue)
                    }
            return this
        }, removeClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = 0 === arguments.length || "string" == typeof value && value, i = 0, len = this.length;
            if (jQuery.isFunction(value))
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className))
                });
            if (proceed)
                for (classes = (value || "").match(rnotwhite) || []; len > i; i++)
                    if (elem = this[i], cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "")) {
                        for (j = 0; clazz = classes[j++]; )
                            for (; cur.indexOf(" " + clazz + " ") >= 0; )
                                cur = cur.replace(" " + clazz + " ", " ");
                        finalValue = value ? jQuery.trim(cur) : "", elem.className !== finalValue && (elem.className = finalValue)
                    }
            return this
        }, toggleClass: function (value, stateVal) {
            var type = typeof value;
            return"boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : jQuery.isFunction(value) ? this.each(function (i) {
                jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal)
            }) : this.each(function () {
                if ("string" === type)
                    for (var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || []; className = classNames[i++]; )
                        self.hasClass(className) ? self.removeClass(className) : self.addClass(className);
                else
                    (type === strundefined || "boolean" === type) && (this.className && data_priv.set(this, "__className__", this.className), this.className = this.className || value === !1 ? "" : data_priv.get(this, "__className__") || "")
            })
        }, hasClass: function (selector) {
            for (var className = " " + selector + " ", i = 0, l = this.length; l > i; i++)
                if (1 === this[i].nodeType && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0)
                    return!0;
            return!1
        }});
    var rreturn = /\r/g;
    jQuery.fn.extend({val: function (value) {
            var hooks, ret, isFunction, elem = this[0];
            {
                if (arguments.length)
                    return isFunction = jQuery.isFunction(value), this.each(function (i) {
                        var val;
                        1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value, null == val ? val = "" : "number" == typeof val ? val += "" : jQuery.isArray(val) && (val = jQuery.map(val, function (value) {
                            return null == value ? "" : value + ""
                        })), hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()], hooks && "set"in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val))
                    });
                if (elem)
                    return hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()], hooks && "get"in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value, "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret)
            }
        }}), jQuery.extend({valHooks: {option: {get: function (elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return null != val ? val : jQuery.trim(jQuery.text(elem))
                }}, select: {get: function (elem) {
                    for (var value, option, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type || 0 > index, values = one ? null : [], max = one ? index + 1 : options.length, i = 0 > index ? max : one ? index : 0; max > i; i++)
                        if (option = options[i], !(!option.selected && i !== index || (support.optDisabled ? option.disabled : null !== option.getAttribute("disabled")) || option.parentNode.disabled && jQuery.nodeName(option.parentNode, "optgroup"))) {
                            if (value = jQuery(option).val(), one)
                                return value;
                            values.push(value)
                        }
                    return values
                }, set: function (elem, value) {
                    for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; )
                        option = options[i], (option.selected = jQuery.inArray(option.value, values) >= 0) && (optionSet = !0);
                    return optionSet || (elem.selectedIndex = -1), values
                }}}}), jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {set: function (elem, value) {
                return jQuery.isArray(value) ? elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0 : void 0
            }}, support.checkOn || (jQuery.valHooks[this].get = function (elem) {
            return null === elem.getAttribute("value") ? "on" : elem.value
        })
    }), jQuery.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
        }
    }), jQuery.fn.extend({hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
        }, bind: function (types, data, fn) {
            return this.on(types, null, data, fn)
        }, unbind: function (types, fn) {
            return this.off(types, null, fn)
        }, delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn)
        }, undelegate: function (selector, types, fn) {
            return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn)
        }});
    var nonce = jQuery.now(), rquery = /\?/;
    jQuery.parseJSON = function (data) {
        return JSON.parse(data + "")
    }, jQuery.parseXML = function (data) {
        var xml, tmp;
        if (!data || "string" != typeof data)
            return null;
        try {
            tmp = new DOMParser, xml = tmp.parseFromString(data, "text/xml")
        } catch (e) {
            xml = void 0
        }
        return(!xml || xml.getElementsByTagName("parsererror").length) && jQuery.error("Invalid XML: " + data), xml
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), ajaxLocation = window.location.href, ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    jQuery.extend({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: ajaxLocation, type: "GET", isLocal: rlocalProtocol.test(ajaxLocParts[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: {"*": allTypes, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript"}, contents: {xml: /xml/, html: /html/, json: /json/}, responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"}, converters: {"* text": String, "text html": !0, "text json": jQuery.parseJSON, "text xml": jQuery.parseXML}, flatOptions: {url: !0, context: !0}}, ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
        }, ajaxPrefilter: addToPrefiltersOrTransports(prefilters), ajaxTransport: addToPrefiltersOrTransports(transports), ajax: function (url, options) {
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                2 !== state && (state = 2, timeoutTimer && clearTimeout(timeoutTimer), transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, isSuccess = status >= 200 && 300 > status || 304 === status, responses && (response = ajaxHandleResponses(s, jqXHR, responses)), response = ajaxConvert(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), modified && (jQuery.lastModified[cacheURL] = modified), modified = jqXHR.getResponseHeader("etag"), modified && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, success = response.data, error = response.error, isSuccess = !error)) : (error = statusText, (status || !statusText) && (statusText = "error", 0 > status && (status = 0))), jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [success, statusText, jqXHR]) : deferred.rejectWith(callbackContext, [jqXHR, statusText, error]), jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]), completeDeferred.fireWith(callbackContext, [jqXHR, statusText]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [jqXHR, s]), --jQuery.active || jQuery.event.trigger("ajaxStop")))
            }
            "object" == typeof url && (options = url, url = void 0), options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {readyState: 0, getResponseHeader: function (key) {
                    var match;
                    if (2 === state) {
                        if (!responseHeaders)
                            for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); )
                                responseHeaders[match[1].toLowerCase()] = match[2];
                        match = responseHeaders[key.toLowerCase()]
                    }
                    return null == match ? null : match
                }, getAllResponseHeaders: function () {
                    return 2 === state ? responseHeadersString : null
                }, setRequestHeader: function (name, value) {
                    var lname = name.toLowerCase();
                    return state || (name = requestHeadersNames[lname] = requestHeadersNames[lname] || name, requestHeaders[name] = value), this
                }, overrideMimeType: function (type) {
                    return state || (s.mimeType = type), this
                }, statusCode: function (map) {
                    var code;
                    if (map)
                        if (2 > state)
                            for (code in map)
                                statusCode[code] = [statusCode[code], map[code]];
                        else
                            jqXHR.always(map[jqXHR.status]);
                    return this
                }, abort: function (statusText) {
                    var finalText = statusText || strAbort;
                    return transport && transport.abort(finalText), done(0, finalText), this
                }};
            if (deferred.promise(jqXHR).complete = completeDeferred.add, jqXHR.success = jqXHR.done, jqXHR.error = jqXHR.fail, s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//"), s.type = options.method || options.type || s.method || s.type, s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""], null == s.crossDomain && (parts = rurl.exec(s.url.toLowerCase()), s.crossDomain = !(!parts || parts[1] === ajaxLocParts[1] && parts[2] === ajaxLocParts[2] && (parts[3] || ("http:" === parts[1] ? "80" : "443")) === (ajaxLocParts[3] || ("http:" === ajaxLocParts[1] ? "80" : "443")))), s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), 2 === state)
                return jqXHR;
            fireGlobals = jQuery.event && s.global, fireGlobals && 0 === jQuery.active++ && jQuery.event.trigger("ajaxStart"), s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url, s.hasContent || (s.data && (cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), s.cache === !1 && (s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++)), s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), (s.data && s.hasContent && s.contentType !== !1 || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers)
                jqXHR.setRequestHeader(i, s.headers[i]);
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === !1 || 2 === state))
                return jqXHR.abort();
            strAbort = "abort";
            for (i in{success:1, error:1, complete:1})
                jqXHR[i](s[i]);
            if (transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [jqXHR, s]), s.async && s.timeout > 0 && (timeoutTimer = setTimeout(function () {
                    jqXHR.abort("timeout")
                }, s.timeout));
                try {
                    state = 1, transport.send(requestHeaders, done)
                } catch (e) {
                    if (!(2 > state))
                        throw e;
                    done(-1, e)
                }
            } else
                done(-1, "No Transport");
            return jqXHR
        }, getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json")
        }, getScript: function (url, callback) {
            return jQuery.get(url, void 0, callback, "script")
        }}), jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), jQuery.ajax({url: url, type: method, dataType: type, data: data, success: callback})
        }
    }), jQuery._evalUrl = function (url) {
        return jQuery.ajax({url: url, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0})
    }, jQuery.fn.extend({wrapAll: function (html) {
            var wrap;
            return jQuery.isFunction(html) ? this.each(function (i) {
                jQuery(this).wrapAll(html.call(this, i))
            }) : (this[0] && (wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function () {
                for (var elem = this; elem.firstElementChild; )
                    elem = elem.firstElementChild;
                return elem
            }).append(this)), this)
        }, wrapInner: function (html) {
            return jQuery.isFunction(html) ? this.each(function (i) {
                jQuery(this).wrapInner(html.call(this, i))
            }) : this.each(function () {
                var self = jQuery(this), contents = self.contents();
                contents.length ? contents.wrapAll(html) : self.append(html)
            })
        }, wrap: function (html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)
            })
        }, unwrap: function () {
            return this.parent().each(function () {
                jQuery.nodeName(this, "body") || jQuery(this).replaceWith(this.childNodes)
            }).end()
        }}), jQuery.expr.filters.hidden = function (elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0
    }, jQuery.expr.filters.visible = function (elem) {
        return!jQuery.expr.filters.hidden(elem)
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, value) {
            value = jQuery.isFunction(value) ? value() : null == value ? "" : value, s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value)
        };
        if (void 0 === traditional && (traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional), jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a))
            jQuery.each(a, function () {
                add(this.name, this.value)
            });
        else
            for (prefix in a)
                buildParams(prefix, a[prefix], traditional, add);
        return s.join("&").replace(r20, "+")
    }, jQuery.fn.extend({serialize: function () {
            return jQuery.param(this.serializeArray())
        }, serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                return null == val ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                    return{name: elem.name, value: val.replace(rCRLF, "\r\n")}
                }) : {name: elem.name, value: val.replace(rCRLF, "\r\n")}
            }).get()
        }}), jQuery.ajaxSettings.xhr = function () {
        try {
            return new XMLHttpRequest
        } catch (e) {
        }
    };
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {0: 200, 1223: 204}, xhrSupported = jQuery.ajaxSettings.xhr();
    window.attachEvent && window.attachEvent("onunload", function () {
        for (var key in xhrCallbacks)
            xhrCallbacks[key]()
    }), support.cors = !!xhrSupported && "withCredentials"in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, jQuery.ajaxTransport(function (options) {
        var callback;
        return support.cors || xhrSupported && !options.crossDomain ? {send: function (headers, complete) {
                var i, xhr = options.xhr(), id = ++xhrId;
                if (xhr.open(options.type, options.url, options.async, options.username, options.password), options.xhrFields)
                    for (i in options.xhrFields)
                        xhr[i] = options.xhrFields[i];
                options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                for (i in headers)
                    xhr.setRequestHeader(i, headers[i]);
                callback = function (type) {
                    return function () {
                        callback && (delete xhrCallbacks[id], callback = xhr.onload = xhr.onerror = null, "abort" === type ? xhr.abort() : "error" === type ? complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "string" == typeof xhr.responseText ? {text: xhr.responseText} : void 0, xhr.getAllResponseHeaders()))
                    }
                }, xhr.onload = callback(), xhr.onerror = callback("error"), callback = xhrCallbacks[id] = callback("abort");
                try {
                    xhr.send(options.hasContent && options.data || null)
                } catch (e) {
                    if (callback)
                        throw e
                }
            }, abort: function () {
                callback && callback()
            }} : void 0
    }), jQuery.ajaxSetup({accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"}, contents: {script: /(?:java|ecma)script/}, converters: {"text script": function (text) {
                return jQuery.globalEval(text), text
            }}}), jQuery.ajaxPrefilter("script", function (s) {
        void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET")
    }), jQuery.ajaxTransport("script", function (s) {
        if (s.crossDomain) {
            var script, callback;
            return{send: function (_, complete) {
                    script = jQuery("<script>").prop({async: !0, charset: s.scriptCharset, src: s.url}).on("load error", callback = function (evt) {
                        script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type)
                    }), document.head.appendChild(script[0])
                }, abort: function () {
                    callback && callback()
                }}
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({jsonp: "callback", jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            return this[callback] = !0, callback
        }}), jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== !1 && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        return jsonProp || "jsonp" === s.dataTypes[0] ? (callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : s.jsonp !== !1 && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), s.converters["script json"] = function () {
            return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0]
        }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function () {
            responseContainer = arguments
        }, jqXHR.always(function () {
            window[callbackName] = overwritten, s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)), responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), responseContainer = overwritten = void 0
        }), "script") : void 0
    }), jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || "string" != typeof data)
            return null;
        "boolean" == typeof context && (keepScripts = context, context = !1), context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        return parsed ? [context.createElement(parsed[1])] : (parsed = jQuery.buildFragment([data], context, scripts), scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes))
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function (url, params, callback) {
        if ("string" != typeof url && _load)
            return _load.apply(this, arguments);
        var selector, type, response, self = this, off = url.indexOf(" ");
        return off >= 0 && (selector = jQuery.trim(url.slice(off)), url = url.slice(0, off)), jQuery.isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), self.length > 0 && jQuery.ajax({url: url, type: type, dataType: "html", data: params}).done(function (responseText) {
            response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
        }).complete(callback && function (jqXHR, status) {
            self.each(callback, response || [jqXHR.responseText, status, jqXHR])
        }), this
    }, jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn)
        }
    }), jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem
        }).length
    };
    var docElem = window.document.documentElement;
    jQuery.offset = {setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1, calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), jQuery.isFunction(options) && (options = options.call(elem, i, curOffset)), null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft), "using"in options ? options.using.call(elem, props) : curElem.css(props)
        }}, jQuery.fn.extend({offset: function (options) {
            if (arguments.length)
                return void 0 === options ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i)
                });
            var docElem, win, elem = this[0], box = {top: 0, left: 0}, doc = elem && elem.ownerDocument;
            if (doc)
                return docElem = doc.documentElement, jQuery.contains(docElem, elem) ? (typeof elem.getBoundingClientRect !== strundefined && (box = elem.getBoundingClientRect()), win = getWindow(doc), {top: box.top + win.pageYOffset - docElem.clientTop, left: box.left + win.pageXOffset - docElem.clientLeft}) : box
        }, position: function () {
            if (this[0]) {
                var offsetParent, offset, elem = this[0], parentOffset = {top: 0, left: 0};
                return"fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", !0)), {top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0), left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)}
            }
        }, offsetParent: function () {
            return this.map(function () {
                for (var offsetParent = this.offsetParent || docElem; offsetParent && !jQuery.nodeName(offsetParent, "html") && "static" === jQuery.css(offsetParent, "position"); )
                    offsetParent = offsetParent.offsetParent;
                return offsetParent || docElem
            })
        }}), jQuery.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem);
                return void 0 === val ? win ? win[prop] : elem[method] : void(win ? win.scrollTo(top ? window.pageXOffset : val, top ? val : window.pageYOffset) : elem[method] = val)
            }, method, val, arguments.length, null)
        }
    }), jQuery.each(["top", "left"], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            return computed ? (computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed) : void 0
        })
    }), jQuery.each({Height: "height", Width: "width"}, function (name, type) {
        jQuery.each({padding: "inner" + name, content: type, "": "outer" + name}, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin), extra = defaultExtra || (margin === !0 || value === !0 ? "margin" : "border");
                return access(this, function (elem, type, value) {
                    var doc;
                    return jQuery.isWindow(elem) ? elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                }, type, chainable ? margin : void 0, chainable, null)
            }
        })
    }), jQuery.fn.size = function () {
        return this.length
    }, jQuery.fn.andSelf = jQuery.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () {
        return jQuery
    });
    var _jQuery = window.jQuery, _$ = window.$;
    return jQuery.noConflict = function (deep) {
        return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), jQuery
    }, typeof noGlobal === strundefined && (window.jQuery = window.$ = jQuery), jQuery
}), function (factory) {
    "function" == typeof define && define.amd ? define(["jquery"], factory) : factory(jQuery)
}(function ($) {
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        return"area" === nodeName ? (map = element.parentNode, mapName = map.name, element.href && mapName && "map" === map.nodeName.toLowerCase() ? (img = $("img[usemap='#" + mapName + "']")[0], !!img && visible(img)) : !1) : (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element)
    }
    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
            return"hidden" === $.css(this, "visibility")
        }).length
    }
    $.ui = $.ui || {}, $.extend($.ui, {version: "1.11.2", keyCode: {BACKSPACE: 8, COMMA: 188, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, LEFT: 37, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SPACE: 32, TAB: 9, UP: 38}}), $.fn.extend({scrollParent: function (includeHidden) {
            var position = this.css("position"), excludeStaticParent = "absolute" === position, overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/, scrollParent = this.parents().filter(function () {
                var parent = $(this);
                return excludeStaticParent && "static" === parent.css("position") ? !1 : overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"))
            }).eq(0);
            return"fixed" !== position && scrollParent.length ? scrollParent : $(this[0].ownerDocument || document)
        }, uniqueId: function () {
            var uuid = 0;
            return function () {
                return this.each(function () {
                    this.id || (this.id = "ui-id-" + ++uuid)
                })
            }
        }(), removeUniqueId: function () {
            return this.each(function () {
                /^ui-id-\d+$/.test(this.id) && $(this).removeAttr("id")
            })
        }}), $.extend($.expr[":"], {data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
            return function (elem) {
                return!!$.data(elem, dataName)
            }
        }) : function (elem, i, match) {
            return!!$.data(elem, match[3])
        }, focusable: function (element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")))
        }, tabbable: function (element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return(isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN)
        }}), $("<a>").outerWidth(1).jquery || $.each(["Width", "Height"], function (i, name) {
        function reduce(elem, size, border, margin) {
            return $.each(side, function () {
                size -= parseFloat($.css(elem, "padding" + this)) || 0, border && (size -= parseFloat($.css(elem, "border" + this + "Width")) || 0), margin && (size -= parseFloat($.css(elem, "margin" + this)) || 0)
            }), size
        }
        var side = "Width" === name ? ["Left", "Right"] : ["Top", "Bottom"], type = name.toLowerCase(), orig = {innerWidth: $.fn.innerWidth, innerHeight: $.fn.innerHeight, outerWidth: $.fn.outerWidth, outerHeight: $.fn.outerHeight};
        $.fn["inner" + name] = function (size) {
            return void 0 === size ? orig["inner" + name].call(this) : this.each(function () {
                $(this).css(type, reduce(this, size) + "px")
            })
        }, $.fn["outer" + name] = function (size, margin) {
            return"number" != typeof size ? orig["outer" + name].call(this, size) : this.each(function () {
                $(this).css(type, reduce(this, size, !0, margin) + "px")
            })
        }
    }), $.fn.addBack || ($.fn.addBack = function (selector) {
        return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
    }), $("<a>").data("a-b", "a").removeData("a-b").data("a-b") && ($.fn.removeData = function (removeData) {
        return function (key) {
            return arguments.length ? removeData.call(this, $.camelCase(key)) : removeData.call(this)
        }
    }($.fn.removeData)), $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), $.fn.extend({focus: function (orig) {
            return function (delay, fn) {
                return"number" == typeof delay ? this.each(function () {
                    var elem = this;
                    setTimeout(function () {
                        $(elem).focus(), fn && fn.call(elem)
                    }, delay)
                }) : orig.apply(this, arguments)
            }
        }($.fn.focus), disableSelection: function () {
            var eventType = "onselectstart"in document.createElement("div") ? "selectstart" : "mousedown";
            return function () {
                return this.bind(eventType + ".ui-disableSelection", function (event) {
                    event.preventDefault()
                })
            }
        }(), enableSelection: function () {
            return this.unbind(".ui-disableSelection")
        }, zIndex: function (zIndex) {
            if (void 0 !== zIndex)
                return this.css("zIndex", zIndex);
            if (this.length)
                for (var position, value, elem = $(this[0]); elem.length && elem[0] !== document; ) {
                    if (position = elem.css("position"), ("absolute" === position || "relative" === position || "fixed" === position) && (value = parseInt(elem.css("zIndex"), 10), !isNaN(value) && 0 !== value))
                        return value;
                    elem = elem.parent()
                }
            return 0
        }}), $.ui.plugin = {add: function (module, option, set) {
            var i, proto = $.ui[module].prototype;
            for (i in set)
                proto.plugins[i] = proto.plugins[i] || [], proto.plugins[i].push([option, set[i]])
        }, call: function (instance, name, args, allowDisconnected) {
            var i, set = instance.plugins[name];
            if (set && (allowDisconnected || instance.element[0].parentNode && 11 !== instance.element[0].parentNode.nodeType))
                for (i = 0; i < set.length; i++)
                    instance.options[set[i][0]] && set[i][1].apply(instance.element, args)
        }}
}), function (factory) {
    "function" == typeof define && define.amd ? define(["jquery"], factory) : factory(jQuery)
}(function ($) {
    var widget_uuid = 0, widget_slice = Array.prototype.slice;
    return $.cleanData = function (orig) {
        return function (elems) {
            var events, elem, i;
            for (i = 0; null != (elem = elems[i]); i++)
                try {
                    events = $._data(elem, "events"), events && events.remove && $(elem).triggerHandler("remove")
                } catch (e) {
                }
            orig(elems)
        }
    }($.cleanData), $.widget = function (name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype, proxiedPrototype = {}, namespace = name.split(".")[0];
        return name = name.split(".")[1], fullName = namespace + "-" + name, prototype || (prototype = base, base = $.Widget), $.expr[":"][fullName.toLowerCase()] = function (elem) {
            return!!$.data(elem, fullName)
        }, $[namespace] = $[namespace] || {}, existingConstructor = $[namespace][name], constructor = $[namespace][name] = function (options, element) {
            return this._createWidget ? void(arguments.length && this._createWidget(options, element)) : new constructor(options, element)
        }, $.extend(constructor, existingConstructor, {version: prototype.version, _proto: $.extend({}, prototype), _childConstructors: []}), basePrototype = new base, basePrototype.options = $.widget.extend({}, basePrototype.options), $.each(prototype, function (prop, value) {
            return $.isFunction(value) ? void(proxiedPrototype[prop] = function () {
                var _super = function () {
                    return base.prototype[prop].apply(this, arguments)
                }, _superApply = function (args) {
                    return base.prototype[prop].apply(this, args)
                };
                return function () {
                    var returnValue, __super = this._super, __superApply = this._superApply;
                    return this._super = _super, this._superApply = _superApply, returnValue = value.apply(this, arguments), this._super = __super, this._superApply = __superApply, returnValue
                }
            }()) : void(proxiedPrototype[prop] = value)
        }), constructor.prototype = $.widget.extend(basePrototype, {widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name}, proxiedPrototype, {constructor: constructor, namespace: namespace, widgetName: name, widgetFullName: fullName}), existingConstructor ? ($.each(existingConstructor._childConstructors, function (i, child) {
            var childPrototype = child.prototype;
            $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto)
        }), delete existingConstructor._childConstructors) : base._childConstructors.push(constructor), $.widget.bridge(name, constructor), constructor
    }, $.widget.extend = function (target) {
        for (var key, value, input = widget_slice.call(arguments, 1), inputIndex = 0, inputLength = input.length; inputLength > inputIndex; inputIndex++)
            for (key in input[inputIndex])
                value = input[inputIndex][key], input[inputIndex].hasOwnProperty(key) && void 0 !== value && ($.isPlainObject(value) ? target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value) : target[key] = value);
        return target
    }, $.widget.bridge = function (name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function (options) {
            var isMethodCall = "string" == typeof options, args = widget_slice.call(arguments, 1), returnValue = this;
            return options = !isMethodCall && args.length ? $.widget.extend.apply(null, [options].concat(args)) : options, isMethodCall ? this.each(function () {
                var methodValue, instance = $.data(this, fullName);
                return"instance" === options ? (returnValue = instance, !1) : instance ? $.isFunction(instance[options]) && "_" !== options.charAt(0) ? (methodValue = instance[options].apply(instance, args), methodValue !== instance && void 0 !== methodValue ? (returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue, !1) : void 0) : $.error("no such method '" + options + "' for " + name + " widget instance") : $.error("cannot call methods on " + name + " prior to initialization; attempted to call method '" + options + "'")
            }) : this.each(function () {
                var instance = $.data(this, fullName);
                instance ? (instance.option(options || {}), instance._init && instance._init()) : $.data(this, fullName, new object(options, this))
            }), returnValue
        }
    }, $.Widget = function () {
    }, $.Widget._childConstructors = [], $.Widget.prototype = {widgetName: "widget", widgetEventPrefix: "", defaultElement: "<div>", options: {disabled: !1, create: null}, _createWidget: function (options, element) {
            element = $(element || this.defaultElement || this)[0], this.element = $(element), this.uuid = widget_uuid++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = $(), this.hoverable = $(), this.focusable = $(), element !== this && ($.data(element, this.widgetFullName, this), this._on(!0, this.element, {remove: function (event) {
                    event.target === element && this.destroy()
                }}), this.document = $(element.style ? element.ownerDocument : element.document || element), this.window = $(this.document[0].defaultView || this.document[0].parentWindow)), this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options), this._create(), this._trigger("create", null, this._getCreateEventData()), this._init()
        }, _getCreateOptions: $.noop, _getCreateEventData: $.noop, _create: $.noop, _init: $.noop, destroy: function () {
            this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName)), this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"), this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")
        }, _destroy: $.noop, widget: function () {
            return this.element
        }, option: function (key, value) {
            var parts, curOption, i, options = key;
            if (0 === arguments.length)
                return $.widget.extend({}, this.options);
            if ("string" == typeof key)
                if (options = {}, parts = key.split("."), key = parts.shift(), parts.length) {
                    for (curOption = options[key] = $.widget.extend({}, this.options[key]), i = 0; i < parts.length - 1; i++)
                        curOption[parts[i]] = curOption[parts[i]] || {}, curOption = curOption[parts[i]];
                    if (key = parts.pop(), 1 === arguments.length)
                        return void 0 === curOption[key] ? null : curOption[key];
                    curOption[key] = value
                } else {
                    if (1 === arguments.length)
                        return void 0 === this.options[key] ? null : this.options[key];
                    options[key] = value
                }
            return this._setOptions(options), this
        }, _setOptions: function (options) {
            var key;
            for (key in options)
                this._setOption(key, options[key]);
            return this
        }, _setOption: function (key, value) {
            return this.options[key] = value, "disabled" === key && (this.widget().toggleClass(this.widgetFullName + "-disabled", !!value), value && (this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus"))), this
        }, enable: function () {
            return this._setOptions({disabled: !1})
        }, disable: function () {
            return this._setOptions({disabled: !0})
        }, _on: function (suppressDisabledCheck, element, handlers) {
            var delegateElement, instance = this;
            "boolean" != typeof suppressDisabledCheck && (handlers = element, element = suppressDisabledCheck, suppressDisabledCheck = !1), handlers ? (element = delegateElement = $(element), this.bindings = this.bindings.add(element)) : (handlers = element, element = this.element, delegateElement = this.widget()), $.each(handlers, function (event, handler) {
                function handlerProxy() {
                    return suppressDisabledCheck || instance.options.disabled !== !0 && !$(this).hasClass("ui-state-disabled") ? ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments) : void 0
                }
                "string" != typeof handler && (handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++);
                var match = event.match(/^([\w:-]*)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
                selector ? delegateElement.delegate(selector, eventName, handlerProxy) : element.bind(eventName, handlerProxy)
            })
        }, _off: function (element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, element.unbind(eventName).undelegate(eventName), this.bindings = $(this.bindings.not(element).get()), this.focusable = $(this.focusable.not(element).get()), this.hoverable = $(this.hoverable.not(element).get())
        }, _delay: function (handler, delay) {
            function handlerProxy() {
                return("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments)
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0)
        }, _hoverable: function (element) {
            this.hoverable = this.hoverable.add(element), this._on(element, {mouseenter: function (event) {
                    $(event.currentTarget).addClass("ui-state-hover")
                }, mouseleave: function (event) {
                    $(event.currentTarget).removeClass("ui-state-hover")
                }})
        }, _focusable: function (element) {
            this.focusable = this.focusable.add(element), this._on(element, {focusin: function (event) {
                    $(event.currentTarget).addClass("ui-state-focus")
                }, focusout: function (event) {
                    $(event.currentTarget).removeClass("ui-state-focus")
                }})
        }, _trigger: function (type, event, data) {
            var prop, orig, callback = this.options[type];
            if (data = data || {}, event = $.Event(event), event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(), event.target = this.element[0], orig = event.originalEvent)
                for (prop in orig)
                    prop in event || (event[prop] = orig[prop]);
            return this.element.trigger(event, data), !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === !1 || event.isDefaultPrevented())
        }}, $.each({show: "fadeIn", hide: "fadeOut"}, function (method, defaultEffect) {
        $.Widget.prototype["_" + method] = function (element, options, callback) {
            "string" == typeof options && (options = {effect: options});
            var hasOptions, effectName = options ? options === !0 || "number" == typeof options ? defaultEffect : options.effect || defaultEffect : method;
            options = options || {}, "number" == typeof options && (options = {duration: options}), hasOptions = !$.isEmptyObject(options), options.complete = callback, options.delay && element.delay(options.delay), hasOptions && $.effects && $.effects.effect[effectName] ? element[method](options) : effectName !== method && element[effectName] ? element[effectName](options.duration, options.easing, callback) : element.queue(function (next) {
                $(this)[method](), callback && callback.call(element[0]), next()
            })
        }
    }), $.widget
}), function (factory) {
    "function" == typeof define && define.amd ? define(["jquery", "./widget"], factory) : factory(jQuery)
}(function ($) {
    var mouseHandled = !1;
    return $(document).mouseup(function () {
        mouseHandled = !1
    }), $.widget("ui.mouse", {version: "1.11.2", options: {cancel: "input,textarea,button,select,option", distance: 1, delay: 0}, _mouseInit: function () {
            var that = this;
            this.element.bind("mousedown." + this.widgetName, function (event) {
                return that._mouseDown(event)
            }).bind("click." + this.widgetName, function (event) {
                return!0 === $.data(event.target, that.widgetName + ".preventClickEvent") ? ($.removeData(event.target, that.widgetName + ".preventClickEvent"), event.stopImmediatePropagation(), !1) : void 0
            }), this.started = !1
        }, _mouseDestroy: function () {
            this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate)
        }, _mouseDown: function (event) {
            if (!mouseHandled) {
                this._mouseMoved = !1, this._mouseStarted && this._mouseUp(event), this._mouseDownEvent = event;
                var that = this, btnIsLeft = 1 === event.which, elIsCancel = "string" == typeof this.options.cancel && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : !1;
                return btnIsLeft && !elIsCancel && this._mouseCapture(event) ? (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
                    that.mouseDelayMet = !0
                }, this.options.delay)), this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(event) !== !1, !this._mouseStarted) ? (event.preventDefault(), !0) : (!0 === $.data(event.target, this.widgetName + ".preventClickEvent") && $.removeData(event.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (event) {
                    return that._mouseMove(event)
                }, this._mouseUpDelegate = function (event) {
                    return that._mouseUp(event)
                }, this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), event.preventDefault(), mouseHandled = !0, !0)) : !0
            }
        }, _mouseMove: function (event) {
            if (this._mouseMoved) {
                if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button)
                    return this._mouseUp(event);
                if (!event.which)
                    return this._mouseUp(event)
            }
            return(event.which || event.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(event), event.preventDefault()) : (this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== !1, this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event)), !this._mouseStarted)
        }, _mouseUp: function (event) {
            return this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, event.target === this._mouseDownEvent.target && $.data(event.target, this.widgetName + ".preventClickEvent", !0),
                    this._mouseStop(event)), mouseHandled = !1, !1
        }, _mouseDistanceMet: function (event) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance
        }, _mouseDelayMet: function () {
            return this.mouseDelayMet
        }, _mouseStart: function () {
        }, _mouseDrag: function () {
        }, _mouseStop: function () {
        }, _mouseCapture: function () {
            return!0
        }})
}), function (factory) {
    "function" == typeof define && define.amd ? define(["jquery", "./core", "./mouse", "./widget"], factory) : factory(jQuery)
}(function ($) {
    return $.widget("ui.draggable", $.ui.mouse, {version: "1.11.2", widgetEventPrefix: "drag", options: {addClasses: !0, appendTo: "parent", axis: !1, connectToSortable: !1, containment: !1, cursor: "auto", cursorAt: !1, grid: !1, handle: !1, helper: "original", iframeFix: !1, opacity: !1, refreshPositions: !1, revert: !1, revertDuration: 500, scope: "default", scroll: !0, scrollSensitivity: 20, scrollSpeed: 20, snap: !1, snapMode: "both", snapTolerance: 20, stack: !1, zIndex: !1, drag: null, start: null, stop: null}, _create: function () {
            "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this.element.addClass("ui-draggable"), this.options.disabled && this.element.addClass("ui-draggable-disabled"), this._setHandleClassName(), this._mouseInit()
        }, _setOption: function (key, value) {
            this._super(key, value), "handle" === key && (this._removeHandleClassName(), this._setHandleClassName())
        }, _destroy: function () {
            return(this.helper || this.element).is(".ui-draggable-dragging") ? void(this.destroyOnClear = !0) : (this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"), this._removeHandleClassName(), void this._mouseDestroy())
        }, _mouseCapture: function (event) {
            var o = this.options;
            return this._blurActiveElement(event), this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0 ? !1 : (this.handle = this._getHandle(event), this.handle ? (this._blockFrames(o.iframeFix === !0 ? "iframe" : o.iframeFix), !0) : !1)
        }, _blockFrames: function (selector) {
            this.iframeBlocks = this.document.find(selector).map(function () {
                var iframe = $(this);
                return $("<div>").css("position", "absolute").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0]
            })
        }, _unblockFrames: function () {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
        }, _blurActiveElement: function (event) {
            var document = this.document[0];
            if (this.handleElement.is(event.target))
                try {
                    document.activeElement && "body" !== document.activeElement.nodeName.toLowerCase() && $(document.activeElement).blur()
                } catch (error) {
                }
        }, _mouseStart: function (event) {
            var o = this.options;
            return this.helper = this._createHelper(event), this.helper.addClass("ui-draggable-dragging"), this._cacheHelperProportions(), $.ui.ddmanager && ($.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(!0), this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = this.helper.parents().filter(function () {
                return"fixed" === $(this).css("position")
            }).length > 0, this.positionAbs = this.element.offset(), this._refreshOffsets(event), this.originalPosition = this.position = this._generatePosition(event, !1), this.originalPageX = event.pageX, this.originalPageY = event.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), this._setContainment(), this._trigger("start", event) === !1 ? (this._clear(), !1) : (this._cacheHelperProportions(), $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event), this._normalizeRightBottom(), this._mouseDrag(event, !0), $.ui.ddmanager && $.ui.ddmanager.dragStart(this, event), !0)
        }, _refreshOffsets: function (event) {
            this.offset = {top: this.positionAbs.top - this.margins.top, left: this.positionAbs.left - this.margins.left, scroll: !1, parent: this._getParentOffset(), relative: this._getRelativeOffset()}, this.offset.click = {left: event.pageX - this.offset.left, top: event.pageY - this.offset.top}
        }, _mouseDrag: function (event, noPropagation) {
            if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(event, !0), this.positionAbs = this._convertPositionTo("absolute"), !noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === !1)
                    return this._mouseUp({}), !1;
                this.position = ui.position
            }
            return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", $.ui.ddmanager && $.ui.ddmanager.drag(this, event), !1
        }, _mouseStop: function (event) {
            var that = this, dropped = !1;
            return $.ui.ddmanager && !this.options.dropBehaviour && (dropped = $.ui.ddmanager.drop(this, event)), this.dropped && (dropped = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !dropped || "valid" === this.options.revert && dropped || this.options.revert === !0 || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped) ? $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
                that._trigger("stop", event) !== !1 && that._clear()
            }) : this._trigger("stop", event) !== !1 && this._clear(), !1
        }, _mouseUp: function (event) {
            return this._unblockFrames(), $.ui.ddmanager && $.ui.ddmanager.dragStop(this, event), this.handleElement.is(event.target) && this.element.focus(), $.ui.mouse.prototype._mouseUp.call(this, event)
        }, cancel: function () {
            return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(), this
        }, _getHandle: function (event) {
            return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : !0
        }, _setHandleClassName: function () {
            this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, this.handleElement.addClass("ui-draggable-handle")
        }, _removeHandleClassName: function () {
            this.handleElement.removeClass("ui-draggable-handle")
        }, _createHelper: function (event) {
            var o = this.options, helperIsFunction = $.isFunction(o.helper), helper = helperIsFunction ? $(o.helper.apply(this.element[0], [event])) : "clone" === o.helper ? this.element.clone().removeAttr("id") : this.element;
            return helper.parents("body").length || helper.appendTo("parent" === o.appendTo ? this.element[0].parentNode : o.appendTo), helperIsFunction && helper[0] === this.element[0] && this._setPositionRelative(), helper[0] === this.element[0] || /(fixed|absolute)/.test(helper.css("position")) || helper.css("position", "absolute"), helper
        }, _setPositionRelative: function () {
            /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative")
        }, _adjustOffsetFromHelper: function (obj) {
            "string" == typeof obj && (obj = obj.split(" ")), $.isArray(obj) && (obj = {left: +obj[0], top: +obj[1] || 0}), "left"in obj && (this.offset.click.left = obj.left + this.margins.left), "right"in obj && (this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left), "top"in obj && (this.offset.click.top = obj.top + this.margins.top), "bottom"in obj && (this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top)
        }, _isRootNode: function (element) {
            return/(html|body)/i.test(element.tagName) || element === this.document[0]
        }, _getParentOffset: function () {
            var po = this.offsetParent.offset(), document = this.document[0];
            return"absolute" === this.cssPosition && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) && (po.left += this.scrollParent.scrollLeft(), po.top += this.scrollParent.scrollTop()), this._isRootNode(this.offsetParent[0]) && (po = {top: 0, left: 0}), {top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0), left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)}
        }, _getRelativeOffset: function () {
            if ("relative" !== this.cssPosition)
                return{top: 0, left: 0};
            var p = this.element.position(), scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return{top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (scrollIsRootNode ? 0 : this.scrollParent.scrollTop()), left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (scrollIsRootNode ? 0 : this.scrollParent.scrollLeft())}
        }, _cacheMargins: function () {
            this.margins = {left: parseInt(this.element.css("marginLeft"), 10) || 0, top: parseInt(this.element.css("marginTop"), 10) || 0, right: parseInt(this.element.css("marginRight"), 10) || 0, bottom: parseInt(this.element.css("marginBottom"), 10) || 0}
        }, _cacheHelperProportions: function () {
            this.helperProportions = {width: this.helper.outerWidth(), height: this.helper.outerHeight()}
        }, _setContainment: function () {
            var isUserScrollable, c, ce, o = this.options, document = this.document[0];
            return this.relativeContainer = null, o.containment ? "window" === o.containment ? void(this.containment = [$(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]) : "document" === o.containment ? void(this.containment = [0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]) : o.containment.constructor === Array ? void(this.containment = o.containment) : ("parent" === o.containment && (o.containment = this.helper[0].parentNode), c = $(o.containment), ce = c[0], void(ce && (isUserScrollable = /(scroll|auto)/.test(c.css("overflow")), this.containment = [(parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relativeContainer = c))) : void(this.containment = null)
        }, _convertPositionTo: function (d, pos) {
            pos || (pos = this.position);
            var mod = "absolute" === d ? 1 : -1, scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return{top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ("fixed" === this.cssPosition ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod, left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ("fixed" === this.cssPosition ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod}
        }, _generatePosition: function (event, constrainPosition) {
            var containment, co, top, left, o = this.options, scrollIsRootNode = this._isRootNode(this.scrollParent[0]), pageX = event.pageX, pageY = event.pageY;
            return scrollIsRootNode && this.offset.scroll || (this.offset.scroll = {top: this.scrollParent.scrollTop(), left: this.scrollParent.scrollLeft()}), constrainPosition && (this.containment && (this.relativeContainer ? (co = this.relativeContainer.offset(), containment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top]) : containment = this.containment, event.pageX - this.offset.click.left < containment[0] && (pageX = containment[0] + this.offset.click.left), event.pageY - this.offset.click.top < containment[1] && (pageY = containment[1] + this.offset.click.top), event.pageX - this.offset.click.left > containment[2] && (pageX = containment[2] + this.offset.click.left), event.pageY - this.offset.click.top > containment[3] && (pageY = containment[3] + this.offset.click.top)), o.grid && (top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY, pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top, left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX, pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left), "y" === o.axis && (pageX = this.originalPageX), "x" === o.axis && (pageY = this.originalPageY)), {top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top), left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)}
        }, _clear: function () {
            this.helper.removeClass("ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy()
        }, _normalizeRightBottom: function () {
            "y" !== this.options.axis && "auto" !== this.helper.css("right") && (this.helper.width(this.helper.width()), this.helper.css("right", "auto")), "x" !== this.options.axis && "auto" !== this.helper.css("bottom") && (this.helper.height(this.helper.height()), this.helper.css("bottom", "auto"))
        }, _trigger: function (type, event, ui) {
            return ui = ui || this._uiHash(), $.ui.plugin.call(this, type, [event, ui, this], !0), /^(drag|start|stop)/.test(type) && (this.positionAbs = this._convertPositionTo("absolute"), ui.offset = this.positionAbs), $.Widget.prototype._trigger.call(this, type, event, ui)
        }, plugins: {}, _uiHash: function () {
            return{helper: this.helper, position: this.position, originalPosition: this.originalPosition, offset: this.positionAbs}
        }}), $.ui.plugin.add("draggable", "connectToSortable", {start: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {item: draggable.element});
            draggable.sortables = [], $(draggable.options.connectToSortable).each(function () {
                var sortable = $(this).sortable("instance");
                sortable && !sortable.options.disabled && (draggable.sortables.push(sortable), sortable.refreshPositions(), sortable._trigger("activate", event, uiSortable))
            })
        }, stop: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {item: draggable.element});
            draggable.cancelHelperRemoval = !1, $.each(draggable.sortables, function () {
                var sortable = this;
                sortable.isOver ? (sortable.isOver = 0, draggable.cancelHelperRemoval = !0, sortable.cancelHelperRemoval = !1, sortable._storedCSS = {position: sortable.placeholder.css("position"), top: sortable.placeholder.css("top"), left: sortable.placeholder.css("left")}, sortable._mouseStop(event), sortable.options.helper = sortable.options._helper) : (sortable.cancelHelperRemoval = !0, sortable._trigger("deactivate", event, uiSortable))
            })
        }, drag: function (event, ui, draggable) {
            $.each(draggable.sortables, function () {
                var innermostIntersecting = !1, sortable = this;
                sortable.positionAbs = draggable.positionAbs, sortable.helperProportions = draggable.helperProportions, sortable.offset.click = draggable.offset.click, sortable._intersectsWith(sortable.containerCache) && (innermostIntersecting = !0, $.each(draggable.sortables, function () {
                    return this.positionAbs = draggable.positionAbs, this.helperProportions = draggable.helperProportions, this.offset.click = draggable.offset.click, this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0]) && (innermostIntersecting = !1), innermostIntersecting
                })), innermostIntersecting ? (sortable.isOver || (sortable.isOver = 1, sortable.currentItem = ui.helper.appendTo(sortable.element).data("ui-sortable-item", !0), sortable.options._helper = sortable.options.helper, sortable.options.helper = function () {
                    return ui.helper[0]
                }, event.target = sortable.currentItem[0], sortable._mouseCapture(event, !0), sortable._mouseStart(event, !0, !0), sortable.offset.click.top = draggable.offset.click.top, sortable.offset.click.left = draggable.offset.click.left, sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left, sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top, draggable._trigger("toSortable", event), draggable.dropped = sortable.element, $.each(draggable.sortables, function () {
                    this.refreshPositions()
                }), draggable.currentItem = draggable.element, sortable.fromOutside = draggable), sortable.currentItem && (sortable._mouseDrag(event), ui.position = sortable.position)) : sortable.isOver && (sortable.isOver = 0, sortable.cancelHelperRemoval = !0, sortable.options._revert = sortable.options.revert, sortable.options.revert = !1, sortable._trigger("out", event, sortable._uiHash(sortable)), sortable._mouseStop(event, !0), sortable.options.revert = sortable.options._revert, sortable.options.helper = sortable.options._helper, sortable.placeholder && sortable.placeholder.remove(), draggable._refreshOffsets(event), ui.position = draggable._generatePosition(event, !0), draggable._trigger("fromSortable", event), draggable.dropped = !1, $.each(draggable.sortables, function () {
                    this.refreshPositions()
                }))
            })
        }}), $.ui.plugin.add("draggable", "cursor", {start: function (event, ui, instance) {
            var t = $("body"), o = instance.options;
            t.css("cursor") && (o._cursor = t.css("cursor")), t.css("cursor", o.cursor)
        }, stop: function (event, ui, instance) {
            var o = instance.options;
            o._cursor && $("body").css("cursor", o._cursor)
        }}), $.ui.plugin.add("draggable", "opacity", {start: function (event, ui, instance) {
            var t = $(ui.helper), o = instance.options;
            t.css("opacity") && (o._opacity = t.css("opacity")), t.css("opacity", o.opacity)
        }, stop: function (event, ui, instance) {
            var o = instance.options;
            o._opacity && $(ui.helper).css("opacity", o._opacity)
        }}), $.ui.plugin.add("draggable", "scroll", {start: function (event, ui, i) {
            i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)), i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset())
        }, drag: function (event, ui, i) {
            var o = i.options, scrolled = !1, scrollParent = i.scrollParentNotHidden[0], document = i.document[0];
            scrollParent !== document && "HTML" !== scrollParent.tagName ? (o.axis && "x" === o.axis || (i.overflowOffset.top + scrollParent.offsetHeight - event.pageY < o.scrollSensitivity ? scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed : event.pageY - i.overflowOffset.top < o.scrollSensitivity && (scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed)), o.axis && "y" === o.axis || (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity ? scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed : event.pageX - i.overflowOffset.left < o.scrollSensitivity && (scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed))) : (o.axis && "x" === o.axis || (event.pageY - $(document).scrollTop() < o.scrollSensitivity ? scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed) : $(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity && (scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed))), o.axis && "y" === o.axis || (event.pageX - $(document).scrollLeft() < o.scrollSensitivity ? scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed) : $(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity && (scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed)))), scrolled !== !1 && $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(i, event)
        }}), $.ui.plugin.add("draggable", "snap", {start: function (event, ui, i) {
            var o = i.options;
            i.snapElements = [], $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function () {
                var $t = $(this), $o = $t.offset();
                this !== i.element[0] && i.snapElements.push({item: this, width: $t.outerWidth(), height: $t.outerHeight(), top: $o.top, left: $o.left})
            })
        }, drag: function (event, ui, inst) {
            var ts, bs, ls, rs, l, r, t, b, i, first, o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
            for (i = inst.snapElements.length - 1; i >= 0; i--)
                l = inst.snapElements[i].left - inst.margins.left, r = l + inst.snapElements[i].width, t = inst.snapElements[i].top - inst.margins.top, b = t + inst.snapElements[i].height, l - d > x2 || x1 > r + d || t - d > y2 || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item) ? (inst.snapElements[i].snapping && inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {snapItem: inst.snapElements[i].item})), inst.snapElements[i].snapping = !1) : ("inner" !== o.snapMode && (ts = Math.abs(t - y2) <= d, bs = Math.abs(b - y1) <= d, ls = Math.abs(l - x2) <= d, rs = Math.abs(r - x1) <= d, ts && (ui.position.top = inst._convertPositionTo("relative", {top: t - inst.helperProportions.height, left: 0}).top), bs && (ui.position.top = inst._convertPositionTo("relative", {top: b, left: 0}).top), ls && (ui.position.left = inst._convertPositionTo("relative", {top: 0, left: l - inst.helperProportions.width}).left), rs && (ui.position.left = inst._convertPositionTo("relative", {top: 0, left: r}).left)), first = ts || bs || ls || rs, "outer" !== o.snapMode && (ts = Math.abs(t - y1) <= d, bs = Math.abs(b - y2) <= d, ls = Math.abs(l - x1) <= d, rs = Math.abs(r - x2) <= d, ts && (ui.position.top = inst._convertPositionTo("relative", {top: t, left: 0}).top), bs && (ui.position.top = inst._convertPositionTo("relative", {top: b - inst.helperProportions.height, left: 0}).top), ls && (ui.position.left = inst._convertPositionTo("relative", {top: 0, left: l}).left), rs && (ui.position.left = inst._convertPositionTo("relative", {top: 0, left: r - inst.helperProportions.width}).left)), !inst.snapElements[i].snapping && (ts || bs || ls || rs || first) && inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {snapItem: inst.snapElements[i].item})), inst.snapElements[i].snapping = ts || bs || ls || rs || first)
        }}), $.ui.plugin.add("draggable", "stack", {start: function (event, ui, instance) {
            var min, o = instance.options, group = $.makeArray($(o.stack)).sort(function (a, b) {
                return(parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0)
            });
            group.length && (min = parseInt($(group[0]).css("zIndex"), 10) || 0, $(group).each(function (i) {
                $(this).css("zIndex", min + i)
            }), this.css("zIndex", min + group.length))
        }}), $.ui.plugin.add("draggable", "zIndex", {start: function (event, ui, instance) {
            var t = $(ui.helper), o = instance.options;
            t.css("zIndex") && (o._zIndex = t.css("zIndex")), t.css("zIndex", o.zIndex)
        }, stop: function (event, ui, instance) {
            var o = instance.options;
            o._zIndex && $(ui.helper).css("zIndex", o._zIndex)
        }}), $.ui.draggable
}), function (factory) {
    "function" == typeof define && define.amd ? define(["jquery", "./core", "./mouse", "./widget"], factory) : factory(jQuery)
}(function ($) {
    return $.widget("ui.sortable", $.ui.mouse, {version: "1.11.2", widgetEventPrefix: "sort", ready: !1, options: {appendTo: "parent", axis: !1, connectWith: !1, containment: !1, cursor: "auto", cursorAt: !1, dropOnEmpty: !0, forcePlaceholderSize: !1, forceHelperSize: !1, grid: !1, handle: !1, helper: "original", items: "> *", opacity: !1, placeholder: !1, revert: !1, scroll: !0, scrollSensitivity: 20, scrollSpeed: 20, scope: "default", tolerance: "intersect", zIndex: 1e3, activate: null, beforeStop: null, change: null, deactivate: null, out: null, over: null, receive: null, remove: null, sort: null, start: null, stop: null, update: null}, _isOverAxis: function (x, reference, size) {
            return x >= reference && reference + size > x
        }, _isFloating: function (item) {
            return/left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"))
        }, _create: function () {
            var o = this.options;
            this.containerCache = {}, this.element.addClass("ui-sortable"), this.refresh(), this.floating = this.items.length ? "x" === o.axis || this._isFloating(this.items[0].item) : !1, this.offset = this.element.offset(), this._mouseInit(), this._setHandleClassName(), this.ready = !0
        }, _setOption: function (key, value) {
            this._super(key, value), "handle" === key && this._setHandleClassName()
        }, _setHandleClassName: function () {
            this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"), $.each(this.items, function () {
                (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass("ui-sortable-handle")
            })
        }, _destroy: function () {
            this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"), this._mouseDestroy();
            for (var i = this.items.length - 1; i >= 0; i--)
                this.items[i].item.removeData(this.widgetName + "-item");
            return this
        }, _mouseCapture: function (event, overrideHandle) {
            var currentItem = null, validHandle = !1, that = this;
            return this.reverting ? !1 : this.options.disabled || "static" === this.options.type ? !1 : (this._refreshItems(event), $(event.target).parents().each(function () {
                return $.data(this, that.widgetName + "-item") === that ? (currentItem = $(this), !1) : void 0
            }), $.data(event.target, that.widgetName + "-item") === that && (currentItem = $(event.target)), currentItem && (!this.options.handle || overrideHandle || ($(this.options.handle, currentItem).find("*").addBack().each(function () {
                this === event.target && (validHandle = !0)
            }), validHandle)) ? (this.currentItem = currentItem, this._removeCurrentsFromItems(), !0) : !1)
        }, _mouseStart: function (event, overrideHandle, noActivation) {
            var i, body, o = this.options;
            if (this.currentContainer = this, this.refreshPositions(), this.helper = this._createHelper(event), this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(), this.offset = this.currentItem.offset(), this.offset = {top: this.offset.top - this.margins.top, left: this.offset.left - this.margins.left}, $.extend(this.offset, {click: {left: event.pageX - this.offset.left, top: event.pageY - this.offset.top}, parent: this._getParentOffset(), relative: this._getRelativeOffset()}), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), this.originalPosition = this._generatePosition(event), this.originalPageX = event.pageX, this.originalPageY = event.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), this.domPosition = {prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0]}, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), o.containment && this._setContainment(), o.cursor && "auto" !== o.cursor && (body = this.document.find("body"), this.storedCursor = body.css("cursor"), body.css("cursor", o.cursor), this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body)), o.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", o.opacity)), o.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", o.zIndex)), this.scrollParent[0] !== document && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", event, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), !noActivation)
                for (i = this.containers.length - 1; i >= 0; i--)
                    this.containers[i]._trigger("activate", event, this._uiHash(this));
            return $.ui.ddmanager && ($.ui.ddmanager.current = this), $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event), this.dragging = !0, this.helper.addClass("ui-sortable-helper"), this._mouseDrag(event), !0
        }, _mouseDrag: function (event) {
            var i, item, itemElement, intersection, o = this.options, scrolled = !1;
            for (this.position = this._generatePosition(event), this.positionAbs = this._convertPositionTo("absolute"), this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs), this.options.scroll && (this.scrollParent[0] !== document && "HTML" !== this.scrollParent[0].tagName?(this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity?this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed:event.pageY - this.overflowOffset.top < o.scrollSensitivity && (this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity?this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed:event.pageX - this.overflowOffset.left < o.scrollSensitivity && (this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed)):(event.pageY - $(document).scrollTop() < o.scrollSensitivity?scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed):$(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity && (scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed)), event.pageX - $(document).scrollLeft() < o.scrollSensitivity?scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed):$(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity && (scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed))), scrolled !== !1 && $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event)), this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), i = this.items.length - 1; i >= 0; i--)
                if (item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item), intersection && item.instance === this.currentContainer && itemElement !== this.currentItem[0] && this.placeholder[1 === intersection ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && ("semi-dynamic" === this.options.type ? !$.contains(this.element[0], itemElement) : !0)) {
                    if (this.direction = 1 === intersection ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(item))
                        break;
                    this._rearrange(event, item), this._trigger("change", event, this._uiHash());
                    break
                }
            return this._contactContainers(event), $.ui.ddmanager && $.ui.ddmanager.drag(this, event), this._trigger("sort", event, this._uiHash()), this.lastPositionAbs = this.positionAbs, !1
        }, _mouseStop: function (event, noPropagation) {
            if (event) {
                if ($.ui.ddmanager && !this.options.dropBehaviour && $.ui.ddmanager.drop(this, event), this.options.revert) {
                    var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
                    axis && "x" !== axis || (animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft)), axis && "y" !== axis || (animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop)), this.reverting = !0, $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
                        that._clear(event)
                    })
                } else
                    this._clear(event, noPropagation);
                return!1
            }
        }, cancel: function () {
            if (this.dragging) {
                this._mouseUp({target: null}), "original" === this.options.helper ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") : this.currentItem.show();
                for (var i = this.containers.length - 1; i >= 0; i--)
                    this.containers[i]._trigger("deactivate", null, this._uiHash(this)), this.containers[i].containerCache.over && (this.containers[i]._trigger("out", null, this._uiHash(this)), this.containers[i].containerCache.over = 0)
            }
            return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), $.extend(this, {helper: null, dragging: !1, reverting: !1, _noFinalSort: null}), this.domPosition.prev ? $(this.domPosition.prev).after(this.currentItem) : $(this.domPosition.parent).prepend(this.currentItem)), this
        }, serialize: function (o) {
            var items = this._getItemsAsjQuery(o && o.connected), str = [];
            return o = o || {}, $(items).each(function () {
                var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                res && str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]))
            }), !str.length && o.key && str.push(o.key + "="), str.join("&")
        }, toArray: function (o) {
            var items = this._getItemsAsjQuery(o && o.connected), ret = [];
            return o = o || {}, items.each(function () {
                ret.push($(o.item || this).attr(o.attribute || "id") || "")
            }), ret
        }, _intersectsWith: function (item) {
            var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = "x" === this.options.axis || y1 + dyClick > t && b > y1 + dyClick, isOverElementWidth = "y" === this.options.axis || x1 + dxClick > l && r > x1 + dxClick, isOverElement = isOverElementHeight && isOverElementWidth;
            return"pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"] ? isOverElement : l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b
        }, _intersectsWithPointer: function (item) {
            var isOverElementHeight = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth, verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
            return isOverElement ? this.floating ? horizontalDirection && "right" === horizontalDirection || "down" === verticalDirection ? 2 : 1 : verticalDirection && ("down" === verticalDirection ? 2 : 1) : !1
        }, _intersectsWithSides: function (item) {
            var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
            return this.floating && horizontalDirection ? "right" === horizontalDirection && isOverRightHalf || "left" === horizontalDirection && !isOverRightHalf : verticalDirection && ("down" === verticalDirection && isOverBottomHalf || "up" === verticalDirection && !isOverBottomHalf)
        }, _getDragVerticalDirection: function () {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return 0 !== delta && (delta > 0 ? "down" : "up")
        }, _getDragHorizontalDirection: function () {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return 0 !== delta && (delta > 0 ? "right" : "left")
        }, refresh: function (event) {
            return this._refreshItems(event), this._setHandleClassName(), this.refreshPositions(), this
        }, _connectWith: function () {
            var options = this.options;
            return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith
        }, _getItemsAsjQuery: function (connected) {
            function addItems() {
                items.push(this)
            }
            var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
            if (connectWith && connected)
                for (i = connectWith.length - 1; i >= 0; i--)
                    for (cur = $(connectWith[i]), j = cur.length - 1; j >= 0; j--)
                        inst = $.data(cur[j], this.widgetFullName), inst && inst !== this && !inst.options.disabled && queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
            for (queries.push([$.isFunction(this.options.items)?this.options.items.call(this.element, null, {options:this.options, item:this.currentItem}):$(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]), i = queries.length - 1; i >= 0; i--)
                queries[i][0].each(addItems);
            return $(items)
        }, _removeCurrentsFromItems: function () {
            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = $.grep(this.items, function (item) {
                for (var j = 0; j < list.length; j++)
                    if (list[j] === item.item[0])
                        return!1;
                return!0
            })
        }, _refreshItems: function (event) {
            this.items = [], this.containers = [this];
            var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {item: this.currentItem}) : $(this.options.items, this.element), this]], connectWith = this._connectWith();
            if (connectWith && this.ready)
                for (i = connectWith.length - 1; i >= 0; i--)
                    for (cur = $(connectWith[i]), j = cur.length - 1; j >= 0; j--)
                        inst = $.data(cur[j], this.widgetFullName), inst && inst !== this && !inst.options.disabled && (queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {item: this.currentItem}) : $(inst.options.items, inst.element), inst]), this.containers.push(inst));
            for (i = queries.length - 1; i >= 0; i--)
                for (targetData = queries[i][1], _queries = queries[i][0], j = 0, queriesLength = _queries.length; queriesLength > j; j++)
                    item = $(_queries[j]), item.data(this.widgetName + "-item", targetData), items.push({item: item, instance: targetData, width: 0, height: 0, left: 0, top: 0})
        }, refreshPositions: function (fast) {
            this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset());
            var i, item, t, p;
            for (i = this.items.length - 1; i >= 0; i--)
                item = this.items[i], item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0] || (t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item, fast || (item.width = t.outerWidth(), item.height = t.outerHeight()), p = t.offset(), item.left = p.left, item.top = p.top);
            if (this.options.custom && this.options.custom.refreshContainers)
                this.options.custom.refreshContainers.call(this);
            else
                for (i = this.containers.length - 1; i >= 0; i--)
                    p = this.containers[i].element.offset(), this.containers[i].containerCache.left = p.left, this.containers[i].containerCache.top = p.top, this.containers[i].containerCache.width = this.containers[i].element.outerWidth(), this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
            return this
        }, _createPlaceholder: function (that) {
            that = that || this;
            var className, o = that.options;
            o.placeholder && o.placeholder.constructor !== String || (className = o.placeholder, o.placeholder = {element: function () {
                    var nodeName = that.currentItem[0].nodeName.toLowerCase(), element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                    return"tr" === nodeName ? that.currentItem.children().each(function () {
                        $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(element)
                    }) : "img" === nodeName && element.attr("src", that.currentItem.attr("src")), className || element.css("visibility", "hidden"), element
                }, update: function (container, p) {
                    (!className || o.forcePlaceholderSize) && (p.height() || p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10)), p.width() || p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10)))
                }}), that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem)), that.currentItem.after(that.placeholder), o.placeholder.update(that, that.placeholder)
        }, _contactContainers: function (event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis, innermostContainer = null, innermostIndex = null;
            for (i = this.containers.length - 1; i >= 0; i--)
                if (!$.contains(this.currentItem[0], this.containers[i].element[0]))
                    if (this._intersectsWith(this.containers[i].containerCache)) {
                        if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0]))
                            continue;
                        innermostContainer = this.containers[i], innermostIndex = i
                    } else
                        this.containers[i].containerCache.over && (this.containers[i]._trigger("out", event, this._uiHash(this)), this.containers[i].containerCache.over = 0);
            if (innermostContainer)
                if (1 === this.containers.length)
                    this.containers[innermostIndex].containerCache.over || (this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)), this.containers[innermostIndex].containerCache.over = 1);
                else {
                    for (dist = 1e4, itemWithLeastDistance = null, floating = innermostContainer.floating || this._isFloating(this.currentItem), posProperty = floating?"left":"top", sizeProperty = floating?"width":"height", axis = floating?"clientX":"clientY", j = this.items.length - 1; j >= 0; j--)
                        $.contains(this.containers[innermostIndex].element[0], this.items[j].item[0]) && this.items[j].item[0] !== this.currentItem[0] && (cur = this.items[j].item.offset()[posProperty], nearBottom = !1, event[axis] - cur > this.items[j][sizeProperty] / 2 && (nearBottom = !0), Math.abs(event[axis] - cur) < dist && (dist = Math.abs(event[axis] - cur), itemWithLeastDistance = this.items[j], this.direction = nearBottom ? "up" : "down"));
                    if (!itemWithLeastDistance && !this.options.dropOnEmpty)
                        return;
                    if (this.currentContainer === this.containers[innermostIndex])
                        return void(this.currentContainer.containerCache.over || (this.containers[innermostIndex]._trigger("over", event, this._uiHash()), this.currentContainer.containerCache.over = 1));
                    itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, !0) : this._rearrange(event, null, this.containers[innermostIndex].element, !0), this._trigger("change", event, this._uiHash()), this.containers[innermostIndex]._trigger("change", event, this._uiHash(this)), this.currentContainer = this.containers[innermostIndex], this.options.placeholder.update(this.currentContainer, this.placeholder), this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)), this.containers[innermostIndex].containerCache.over = 1
                }
        }, _createHelper: function (event) {
            var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : "clone" === o.helper ? this.currentItem.clone() : this.currentItem;
            return helper.parents("body").length || $("parent" !== o.appendTo ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]), helper[0] === this.currentItem[0] && (this._storedCSS = {width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left")}), (!helper[0].style.width || o.forceHelperSize) && helper.width(this.currentItem.width()), (!helper[0].style.height || o.forceHelperSize) && helper.height(this.currentItem.height()), helper
        }, _adjustOffsetFromHelper: function (obj) {
            "string" == typeof obj && (obj = obj.split(" ")), $.isArray(obj) && (obj = {left: +obj[0], top: +obj[1] || 0}), "left"in obj && (this.offset.click.left = obj.left + this.margins.left), "right"in obj && (this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left), "top"in obj && (this.offset.click.top = obj.top + this.margins.top), "bottom"in obj && (this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top)
        }, _getParentOffset: function () {
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();
            return"absolute" === this.cssPosition && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) && (po.left += this.scrollParent.scrollLeft(), po.top += this.scrollParent.scrollTop()), (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && $.ui.ie) && (po = {top: 0, left: 0}), {top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0), left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)}
        }, _getRelativeOffset: function () {
            if ("relative" === this.cssPosition) {
                var p = this.currentItem.position();
                return{top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(), left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()}
            }
            return{top: 0, left: 0}
        }, _cacheMargins: function () {
            this.margins = {left: parseInt(this.currentItem.css("marginLeft"), 10) || 0, top: parseInt(this.currentItem.css("marginTop"), 10) || 0}
        }, _cacheHelperProportions: function () {
            this.helperProportions = {width: this.helper.outerWidth(), height: this.helper.outerHeight()}
        }, _setContainment: function () {
            var ce, co, over, o = this.options;
            "parent" === o.containment && (o.containment = this.helper[0].parentNode), ("document" === o.containment || "window" === o.containment) && (this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, $("document" === o.containment ? document : window).width() - this.helperProportions.width - this.margins.left, ($("document" === o.containment ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]), /^(document|window|parent)$/.test(o.containment) || (ce = $(o.containment)[0], co = $(o.containment).offset(), over = "hidden" !== $(ce).css("overflow"), this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top])
        }, _convertPositionTo: function (d, pos) {
            pos || (pos = this.position);
            var mod = "absolute" === d ? 1 : -1, scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return{top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod, left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod}
        }, _generatePosition: function (event) {
            var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return"relative" !== this.cssPosition || this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), this.originalPosition && (this.containment && (event.pageX - this.offset.click.left < this.containment[0] && (pageX = this.containment[0] + this.offset.click.left), event.pageY - this.offset.click.top < this.containment[1] && (pageY = this.containment[1] + this.offset.click.top), event.pageX - this.offset.click.left > this.containment[2] && (pageX = this.containment[2] + this.offset.click.left), event.pageY - this.offset.click.top > this.containment[3] && (pageY = this.containment[3] + this.offset.click.top)), o.grid && (top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1], pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top, left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0], pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left)), {top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()), left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())}
        }, _rearrange: function (event, i, a, hardRefresh) {
            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? i.item[0] : i.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;
            this._delay(function () {
                counter === this.counter && this.refreshPositions(!hardRefresh)
            })
        }, _clear: function (event, noPropagation) {
            function delayEvent(type, instance, container) {
                return function (event) {
                    container._trigger(type, event, instance._uiHash(instance))
                }
            }
            this.reverting = !1;
            var i, delayedTriggers = [];
            if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS)
                    ("auto" === this._storedCSS[i] || "static" === this._storedCSS[i]) && (this._storedCSS[i] = "");
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")
            } else
                this.currentItem.show();
            for (this.fromOutside && !noPropagation && delayedTriggers.push(function (event) {
                this._trigger("receive", event, this._uiHash(this.fromOutside))
            }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || noPropagation || delayedTriggers.push(function (event) {
                this._trigger("update", event, this._uiHash())
            }), this !== this.currentContainer && (noPropagation || (delayedTriggers.push(function (event) {
                this._trigger("remove", event, this._uiHash())
            }), delayedTriggers.push(function (c) {
                return function (event) {
                    c._trigger("receive", event, this._uiHash(this))
                }
            }.call(this, this.currentContainer)), delayedTriggers.push(function (c) {
                return function (event) {
                    c._trigger("update", event, this._uiHash(this))
                }
            }.call(this, this.currentContainer)))), i = this.containers.length - 1; i >= 0; i--)
                noPropagation || delayedTriggers.push(delayEvent("deactivate", this, this.containers[i])), this.containers[i].containerCache.over && (delayedTriggers.push(delayEvent("out", this, this.containers[i])), this.containers[i].containerCache.over = 0);
            if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), this.dragging = !1, noPropagation || this._trigger("beforeStop", event, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(), this.helper = null), !noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++)
                    delayedTriggers[i].call(this, event);
                this._trigger("stop", event, this._uiHash())
            }
            return this.fromOutside = !1, !this.cancelHelperRemoval
        }, _trigger: function () {
            $.Widget.prototype._trigger.apply(this, arguments) === !1 && this.cancel()
        }, _uiHash: function (_inst) {
            var inst = _inst || this;
            return{helper: inst.helper, placeholder: inst.placeholder || $([]), position: inst.position, originalPosition: inst.originalPosition, offset: inst.positionAbs, item: inst.currentItem, sender: _inst ? _inst.element : null}
        }})
}), function () {
    var window = this;
    if (!window.localStorage) {
        if (window.globalStorage) {
            try {
                window.localStorage = window.globalStorage
            } catch (e) {
            }
            return
        }
        var div = document.createElement("div"), attrKey = "localStorage";
        if (div.style.display = "none", document.getElementsByTagName("head")[0].appendChild(div), div.addBehavior) {
            div.addBehavior("#default#userdata");
            var localStorage = window.localStorage = {length: 0, setItem: function (key, value) {
                    div.load(attrKey), key = cleanKey(key), div.getAttribute(key) || this.length++, div.setAttribute(key, value), div.save(attrKey)
                }, getItem: function (key) {
                    return div.load(attrKey), key = cleanKey(key), div.getAttribute(key)
                }, removeItem: function (key) {
                    div.load(attrKey), key = cleanKey(key), div.removeAttribute(key), div.save(attrKey), this.length--, this.length < 0 && (this.length = 0)
                }, clear: function () {
                    div.load(attrKey);
                    for (var i = 0; attr = div.XMLDocument.documentElement.attributes[i++]; )
                        div.removeAttribute(attr.name);
                    div.save(attrKey), this.length = 0
                }, key: function (key) {
                    return div.load(attrKey), div.XMLDocument.documentElement.attributes[key]
                }}, cleanKey = function (key) {
                return key.replace(/[^-._0-9A-Za-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u37f-\u1fff\u200c-\u200d\u203f\u2040\u2070-\u218f]/g, "-")};
            div.load(attrKey), localStorage.length = div.XMLDocument.documentElement.attributes.length
        }
    }
}(), function (window, document, undefined) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        return ErrorConstructor = ErrorConstructor || Error, function () {
            var message, i, code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments;
            for (message = prefix + template.replace(/\{\d+\}/g, function (match) {
                var index = +match.slice(1, -1);
                return index + 2 < templateArgs.length ? toDebugString(templateArgs[index + 2]) : match
            }), message = message + "\nhttp://errors.angularjs.org/1.3.10/" + (module?module + "/":"") + code, i = 2; i < arguments.length; i++)
                message = message + (2 == i ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(toDebugString(arguments[i]));
            return new ErrorConstructor(message)
        }
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj))
            return!1;
        var length = obj.length;
        return obj.nodeType === NODE_TYPE_ELEMENT && length ? !0 : isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj)
            if (isFunction(obj))
                for (key in obj)
                    "prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key, obj);
            else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = "object" != typeof obj;
                for (key = 0, length = obj.length; length > key; key++)
                    (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj)
            } else if (obj.forEach && obj.forEach !== forEach)
                obj.forEach(iterator, context, obj);
            else
                for (key in obj)
                    obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj);
        return obj
    }
    function sortedKeys(obj) {
        return Object.keys(obj).sort()
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = sortedKeys(obj), i = 0; i < keys.length; i++)
            iterator.call(context, obj[keys[i]], keys[i]);
        return keys
    }
    function reverseParams(iteratorFn) {
        return function (value, key) {
            iteratorFn(key, value)
        }
    }
    function nextUid() {
        return++uid
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey
    }
    function extend(dst) {
        for (var h = dst.$$hashKey, i = 1, ii = arguments.length; ii > i; i++) {
            var obj = arguments[i];
            if (obj)
                for (var keys = Object.keys(obj), j = 0, jj = keys.length; jj > j; j++) {
                    var key = keys[j];
                    dst[key] = obj[key]
                }
        }
        return setHashKey(dst, h), dst
    }
    function int(str) {
        return parseInt(str, 10)
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra)
    }
    function noop() {
    }
    function identity($) {
        return $
    }
    function valueFn(value) {
        return function () {
            return value
        }
    }
    function isUndefined(value) {
        return"undefined" == typeof value
    }
    function isDefined(value) {
        return"undefined" != typeof value
    }
    function isObject(value) {
        return null !== value && "object" == typeof value
    }
    function isString(value) {
        return"string" == typeof value
    }
    function isNumber(value) {
        return"number" == typeof value
    }
    function isDate(value) {
        return"[object Date]" === toString.call(value)
    }
    function isFunction(value) {
        return"function" == typeof value
    }
    function isRegExp(value) {
        return"[object RegExp]" === toString.call(value)
    }
    function isWindow(obj) {
        return obj && obj.window === obj
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch
    }
    function isFile(obj) {
        return"[object File]" === toString.call(obj)
    }
    function isFormData(obj) {
        return"[object FormData]" === toString.call(obj)
    }
    function isBlob(obj) {
        return"[object Blob]" === toString.call(obj)
    }
    function isBoolean(value) {
        return"boolean" == typeof value
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then)
    }
    function isElement(node) {
        return!(!node || !(node.nodeName || node.prop && node.attr && node.find))
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++)
            obj[items[i]] = !0;
        return obj
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName)
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        return index >= 0 && array.splice(index, 1), value
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source))
            throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        if (destination) {
            if (source === destination)
                throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            if (stackSource = stackSource || [], stackDest = stackDest || [], isObject(source)) {
                var index = stackSource.indexOf(source);
                if (-1 !== index)
                    return stackDest[index];
                stackSource.push(source), stackDest.push(destination)
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++)
                    result = copy(source[i], null, stackSource, stackDest), isObject(source[i]) && (stackSource.push(source[i]), stackDest.push(result)), destination.push(result)
            } else {
                var h = destination.$$hashKey;
                isArray(destination) ? destination.length = 0 : forEach(destination, function (value, key) {
                    delete destination[key]
                });
                for (var key in source)
                    source.hasOwnProperty(key) && (result = copy(source[key], null, stackSource, stackDest), isObject(source[key]) && (stackSource.push(source[key]), stackDest.push(result)), destination[key] = result);
                setHashKey(destination, h)
            }
        } else if (destination = source, source)
            if (isArray(source))
                destination = copy(source, [], stackSource, stackDest);
            else if (isDate(source))
                destination = new Date(source.getTime());
            else if (isRegExp(source))
                destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]), destination.lastIndex = source.lastIndex;
            else if (isObject(source)) {
                var emptyObject = Object.create(Object.getPrototypeOf(source));
                destination = copy(source, emptyObject, stackSource, stackDest)
            }
        return destination
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; ii > i; i++)
                dst[i] = src[i]
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src)
                ("$" !== key.charAt(0) || "$" !== key.charAt(1)) && (dst[key] = src[key])
        }
        return dst || src
    }
    function equals(o1, o2) {
        if (o1 === o2)
            return!0;
        if (null === o1 || null === o2)
            return!1;
        if (o1 !== o1 && o2 !== o2)
            return!0;
        var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
        if (t1 == t2 && "object" == t1) {
            if (!isArray(o1)) {
                if (isDate(o1))
                    return isDate(o2) ? equals(o1.getTime(), o2.getTime()) : !1;
                if (isRegExp(o1) && isRegExp(o2))
                    return o1.toString() == o2.toString();
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2))
                    return!1;
                keySet = {};
                for (key in o1)
                    if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                        if (!equals(o1[key], o2[key]))
                            return!1;
                        keySet[key] = !0
                    }
                for (key in o2)
                    if (!keySet.hasOwnProperty(key) && "$" !== key.charAt(0) && o2[key] !== undefined && !isFunction(o2[key]))
                        return!1;
                return!0
            }
            if (!isArray(o2))
                return!1;
            if ((length = o1.length) == o2.length) {
                for (key = 0; length > key; key++)
                    if (!equals(o1[key], o2[key]))
                        return!1;
                return!0
            }
        }
        return!1
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index))
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0)
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return!isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function () {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs)
        } : function () {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self)
        }
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return"string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = undefined : isWindow(value) ? val = "$WINDOW" : value && document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), val
    }
    function toJson(obj, pretty) {
        return"undefined" == typeof obj ? undefined : (isNumber(pretty) || (pretty = pretty ? 2 : null), JSON.stringify(obj, toJsonReplacer, pretty))
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty()
        } catch (e) {
        }
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
                return"<" + lowercase(nodeName)
            })
        } catch (e) {
            return lowercase(elemHtml)
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value)
        } catch (e) {
        }
    }
    function parseKeyValue(keyValue) {
        var key_value, key, obj = {};
        return forEach((keyValue || "").split("&"), function (keyValue) {
            if (keyValue && (key_value = keyValue.replace(/\+/g, "%20").split("="), key = tryDecodeURIComponent(key_value[0]), isDefined(key))) {
                var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : !0;
                hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [obj[key], val] : obj[key] = val
            }
        }), obj
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function (value, key) {
            isArray(value) ? forEach(value, function (arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)))
            }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)))
        }), parts.length ? parts.join("&") : ""
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
    }
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (element = jqLite(element), i = 0; ii > i; ++i)
            if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.attr(attr)))
                return attr;
        return null
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function (prefix) {
            var name = prefix + "app";
            !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, module = element.getAttribute(name))
        }), forEach(ngAttrPrefixes, function (prefix) {
            var candidate, name = prefix + "app";
            !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, module = candidate.getAttribute(name))
        }), appElement && (config.strictDi = null !== getNgAttribute(appElement, "strict-di"), bootstrap(appElement, module ? [module] : [], config))
    }
    function bootstrap(element, modules, config) {
        isObject(config) || (config = {});
        var defaultConfig = {strictDi: !1};
        config = extend(defaultConfig, config);
        var doBootstrap = function () {
            if (element = jqLite(element), element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"))
            }
            modules = modules || [], modules.unshift(["$provide", function ($provide) {
                    $provide.value("$rootElement", element)
                }]), config.debugInfoEnabled && modules.push(["$compileProvider", function ($compileProvider) {
                    $compileProvider.debugInfoEnabled(!0)
                }]), modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            return injector.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function (scope, element, compile, injector) {
                    scope.$apply(function () {
                        element.data("$injector", injector), compile(element)(scope)
                    })
                }]), injector
        }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), void(angular.resumeBootstrap = function (extraModules) {
            forEach(extraModules, function (module) {
                modules.push(module)
            }), doBootstrap()
        }))
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload()
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector)
            throw ngMinErr("test", "no injector found for element argument to getTestability");
        return injector.get("$$testability")
    }
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
            return(pos ? separator : "") + letter.toLowerCase()
        })
    }
    function bindJQuery() {
        var originalCleanData;
        bindJQueryFired || (jQuery = window.jQuery, jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {scope: JQLitePrototype.scope, isolateScope: JQLitePrototype.isolateScope, controller: JQLitePrototype.controller, injector: JQLitePrototype.injector, inheritedData: JQLitePrototype.inheritedData}), originalCleanData = jQuery.cleanData, jQuery.cleanData = function (elems) {
            var events;
            if (skipDestroyOnNextJQueryCleanData)
                skipDestroyOnNextJQueryCleanData = !1;
            else
                for (var elem, i = 0; null != (elem = elems[i]); i++)
                    events = jQuery._data(elem, "events"), events && events.$destroy && jQuery(elem).triggerHandler("$destroy");
            originalCleanData(elems)
        }) : jqLite = JQLite, angular.element = jqLite, bindJQueryFired = !0)
    }
    function assertArg(arg, name, reason) {
        if (!arg)
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), arg
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name)
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
    }
    function getter(obj, path, bindFnToScope) {
        if (!path)
            return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++)
            key = keys[i], obj && (obj = (lastInstance = obj)[key]);
        return!bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj
    }
    function getBlockNodes(nodes) {
        var node = nodes[0], endNode = nodes[nodes.length - 1], blockNodes = [node];
        do {
            if (node = node.nextSibling, !node)
                break;
            blockNodes.push(node)
        } while (node !== endNode);
        return jqLite(blockNodes)
    }
    function createMap() {
        return Object.create(null)
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory())
        }
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function () {
            var modules = {};
            return function (name, requires, configFn) {
                var assertNotHasOwnProperty = function (name, context) {
                    if ("hasOwnProperty" === name)
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
                };
                return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), ensure(modules, name, function () {
                    function invokeLater(provider, method, insertMethod, queue) {
                        return queue || (queue = invokeQueue), function () {
                            return queue[insertMethod || "push"]([provider, method, arguments]), moduleInstance
                        }
                    }
                    if (!requires)
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {_invokeQueue: invokeQueue, _configBlocks: configBlocks, _runBlocks: runBlocks, requires: requires, name: name, provider: invokeLater("$provide", "provider"), factory: invokeLater("$provide", "factory"), service: invokeLater("$provide", "service"), value: invokeLater("$provide", "value"), constant: invokeLater("$provide", "constant", "unshift"), animation: invokeLater("$animateProvider", "register"), filter: invokeLater("$filterProvider", "register"), controller: invokeLater("$controllerProvider", "register"), directive: invokeLater("$compileProvider", "directive"), config: config, run: function (block) {
                            return runBlocks.push(block), this
                        }};
                    return configFn && config(configFn), moduleInstance
                })
            }
        })
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, val) {
            if (val = toJsonReplacer(key, val), isObject(val)) {
                if (seen.indexOf(val) >= 0)
                    return"<<already seen>>";
                seen.push(val)
            }
            return val
        })
    }
    function toDebugString(obj) {
        return"function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof obj ? "undefined" : "string" != typeof obj ? serializeObject(obj) : obj
    }
    function publishExternalAPI(angular) {
        extend(angular, {bootstrap: bootstrap, copy: copy, extend: extend, equals: equals, element: jqLite, forEach: forEach, injector: createInjector, noop: noop, bind: bind, toJson: toJson, fromJson: fromJson, identity: identity, isUndefined: isUndefined, isDefined: isDefined, isString: isString, isFunction: isFunction, isObject: isObject, isNumber: isNumber, isElement: isElement, isArray: isArray, version: version, isDate: isDate, lowercase: lowercase, uppercase: uppercase, callbacks: {counter: 0}, getTestability: getTestability, $$minErr: minErr, $$csp: csp, reloadWithDebugInfo: reloadWithDebugInfo}), angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale")
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider)
        }
        angularModule("ng", ["ngLocale"], ["$provide", function ($provide) {
                $provide.provider({$$sanitizeUri: $$SanitizeUriProvider}), $provide.provider("$compile", $CompileProvider).directive({a: htmlAnchorDirective, input: inputDirective, textarea: inputDirective, form: formDirective, script: scriptDirective, select: selectDirective, style: styleDirective, option: optionDirective, ngBind: ngBindDirective, ngBindHtml: ngBindHtmlDirective, ngBindTemplate: ngBindTemplateDirective, ngClass: ngClassDirective, ngClassEven: ngClassEvenDirective, ngClassOdd: ngClassOddDirective, ngCloak: ngCloakDirective, ngController: ngControllerDirective, ngForm: ngFormDirective, ngHide: ngHideDirective, ngIf: ngIfDirective, ngInclude: ngIncludeDirective, ngInit: ngInitDirective, ngNonBindable: ngNonBindableDirective, ngPluralize: ngPluralizeDirective, ngRepeat: ngRepeatDirective, ngShow: ngShowDirective, ngStyle: ngStyleDirective, ngSwitch: ngSwitchDirective, ngSwitchWhen: ngSwitchWhenDirective, ngSwitchDefault: ngSwitchDefaultDirective, ngOptions: ngOptionsDirective, ngTransclude: ngTranscludeDirective, ngModel: ngModelDirective, ngList: ngListDirective, ngChange: ngChangeDirective, pattern: patternDirective, ngPattern: patternDirective, required: requiredDirective, ngRequired: requiredDirective, minlength: minlengthDirective, ngMinlength: minlengthDirective, maxlength: maxlengthDirective, ngMaxlength: maxlengthDirective, ngValue: ngValueDirective, ngModelOptions: ngModelOptionsDirective}).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({$anchorScroll: $AnchorScrollProvider, $animate: $AnimateProvider, $browser: $BrowserProvider, $cacheFactory: $CacheFactoryProvider, $controller: $ControllerProvider, $document: $DocumentProvider, $exceptionHandler: $ExceptionHandlerProvider, $filter: $FilterProvider, $interpolate: $InterpolateProvider, $interval: $IntervalProvider, $http: $HttpProvider, $httpBackend: $HttpBackendProvider, $location: $LocationProvider, $log: $LogProvider, $parse: $ParseProvider, $rootScope: $RootScopeProvider, $q: $QProvider, $$q: $$QProvider, $sce: $SceProvider, $sceDelegate: $SceDelegateProvider, $sniffer: $SnifferProvider, $templateCache: $TemplateCacheProvider, $templateRequest: $TemplateRequestProvider, $$testability: $$TestabilityProvider, $timeout: $TimeoutProvider, $window: $WindowProvider, $$rAF: $$RAFProvider, $$asyncCallback: $$AsyncCallbackProvider, $$jqLite: $$jqLiteProvider})
            }])
    }
    function jqNextId() {
        return++jqId
    }
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter
        }).replace(MOZ_HACK_REGEXP, "Moz$1")
    }
    function jqLiteIsTextNode(html) {
        return!HTML_REGEXP.test(html)
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html))
            nodes.push(context.createTextNode(html));
        else {
            for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], i = wrap[0]; i--; )
                tmp = tmp.lastChild;
            nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = ""
        }
        return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function (node) {
            fragment.appendChild(node)
        }), fragment
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        return(parsed = SINGLE_TAG_REGEXP.exec(html)) ? [context.createElement(parsed[1])] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : []
    }
    function JQLite(element) {
        if (element instanceof JQLite)
            return element;
        var argIsString;
        if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
            if (argIsString && "<" != element.charAt(0))
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element)
        }
        argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : jqLiteAddNodes(this, element)
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0)
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (onlyDescendants || jqLiteRemoveData(element), element.querySelectorAll)
            for (var descendants = element.querySelectorAll("*"), i = 0, l = descendants.length; l > i; i++)
                jqLiteRemoveData(descendants[i])
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
            throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
        if (handle)
            if (type)
                forEach(type.split(" "), function (type) {
                    if (isDefined(fn)) {
                        var listenerFns = events[type];
                        if (arrayRemove(listenerFns || [], fn), listenerFns && listenerFns.length > 0)
                            return
                    }
                    removeEventListenerFn(element, type, handle), delete events[type]
                });
            else
                for (type in events)
                    "$destroy" !== type && removeEventListenerFn(element, type, handle), delete events[type]
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name)
                return void delete expandoStore.data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = undefined
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(), expandoStore = jqCache[expandoId] = {events: {}, data: {}, handle: undefined}), expandoStore
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
            if (isSimpleSetter)
                data[key] = value;
            else {
                if (massGetter)
                    return data;
                if (isSimpleGetter)
                    return data && data[key];
                extend(data, key)
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1
    }
    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function (cssClass) {
            element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")))
        })
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function (cssClass) {
                cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ")
            }), element.setAttribute("class", trim(existingClasses))
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements)
            if (elements.nodeType)
                root[root.length++] = elements;
            else {
                var length = elements.length;
                if ("number" == typeof length && elements.window !== elements) {
                    if (length)
                        for (var i = 0; length > i; i++)
                            root[root.length++] = elements[i]
                } else
                    root[root.length++] = elements
            }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller")
    }
    function jqLiteInheritedData(element, name, value) {
        element.nodeType == NODE_TYPE_DOCUMENT && (element = element.documentElement);
        for (var names = isArray(name) ? name : [name]; element; ) {
            for (var i = 0, ii = names.length; ii > i; i++)
                if ((value = jqLite.data(element, names[i])) !== undefined)
                    return value;
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host
        }
    }
    function jqLiteEmpty(element) {
        for (jqLiteDealoc(element, !0); element.firstChild; )
            element.removeChild(element.firstChild)
    }
    function jqLiteRemove(element, keepData) {
        keepData || jqLiteDealoc(element);
        var parent = element.parentNode;
        parent && parent.removeChild(element)
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action)
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr
    }
    function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return("INPUT" === nodeName || "TEXTAREA" === nodeName) && ALIASED_ATTR[name]
    }
    function createEventHandler(element, events) {
        var eventHandler = function (event, type) {
            event.isDefaultPrevented = function () {
                return event.defaultPrevented
            };
            var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
            if (eventFnsLength) {
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function () {
                        event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), originalStopImmediatePropagation && originalStopImmediatePropagation.call(event)
                    }
                }
                event.isImmediatePropagationStopped = function () {
                    return event.immediatePropagationStopped === !0
                }, eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                for (var i = 0; eventFnsLength > i; i++)
                    event.isImmediatePropagationStopped() || eventFns[i].call(element, event)
            }
        };
        return eventHandler.elem = element, eventHandler
    }
    function $$jqLiteProvider() {
        this.$get = function () {
            return extend(JQLite, {hasClass: function (node, classes) {
                    return node.attr && (node = node[0]), jqLiteHasClass(node, classes)
                }, addClass: function (node, classes) {
                    return node.attr && (node = node[0]), jqLiteAddClass(node, classes)
                }, removeClass: function (node, classes) {
                    return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes)
                }})
        }
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key)
            return"function" == typeof key && (key = obj.$$hashKey()), key;
        var objType = typeof obj;
        return key = "function" == objType || "object" == objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function () {
                return++uid
            }
        }
        forEach(array, this.put, this)
    }
    function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ""), args = fnText.match(FN_ARGS);
        return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn"
    }
    function annotate(fn, strictDi, name) {
        var $inject, fnText, argDecl, last;
        if ("function" == typeof fn) {
            if (!($inject = fn.$inject)) {
                if ($inject = [], fn.length) {
                    if (strictDi)
                        throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    fnText = fn.toString().replace(STRIP_COMMENTS, ""), argDecl = fnText.match(FN_ARGS), forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                        arg.replace(FN_ARG, function (all, underscore, name) {
                            $inject.push(name)
                        })
                    })
                }
                fn.$inject = $inject
            }
        } else
            isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
        return $inject
    }
    function createInjector(modulesToLoad, strictDi) {
        function supportObject(delegate) {
            return function (key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value)
            }
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), !provider_.$get)
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_
        }
        function enforceReturnValue(name, factory) {
            return function () {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result))
                    throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                return result
            }
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {$get: enforce !== !1 ? enforceReturnValue(name, factoryFn) : factoryFn})
        }
        function service(name, constructor) {
            return factory(name, ["$injector", function ($injector) {
                    return $injector.instantiate(constructor)
                }])
        }
        function value(name, val) {
            return factory(name, valueFn(val), !1)
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function () {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {$delegate: origInstance})
            }
        }
        function loadModules(modulesToLoad) {
            var moduleFn, runBlocks = [];
            return forEach(modulesToLoad, function (module) {
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; ii > i; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2])
                    }
                }
                if (!loadedModules.get(module)) {
                    loadedModules.put(module, !0);
                    try {
                        isString(module) ? (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module")
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e)
                    }
                }
            }), runBlocks
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING)
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName]
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller)
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err
                } finally {
                    path.shift()
                }
            }
            function invoke(fn, self, locals, serviceName) {
                "string" == typeof locals && (serviceName = locals, locals = null);
                var length, i, key, args = [], $inject = annotate(fn, strictDi, serviceName);
                for (i = 0, length = $inject.length; length > i; i++) {
                    if (key = $inject[i], "string" != typeof key)
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName))
                }
                return isArray(fn) && (fn = fn[length]), fn.apply(self, args)
            }
            function instantiate(Type, locals, serviceName) {
                var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null), returnedValue = invoke(Type, instance, locals, serviceName);
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance
            }
            return{invoke: invoke, instantiate: instantiate, get: getService, annotate: annotate, has: function (name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name)
                }}
        }
        strictDi = strictDi === !0;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], !0), providerCache = {$provide: {provider: supportObject(provider), factory: supportObject(factory), service: supportObject(service), value: supportObject(value), constant: supportObject(constant), decorator: decorator}}, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function (serviceName, caller) {
            throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "))
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName)
        });
        return forEach(loadModules(modulesToLoad), function (fn) {
            instanceInjector.invoke(fn || noop)
        }), instanceInjector
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function () {
            autoScrollingEnabled = !1
        }, this.$get = ["$window", "$location", "$rootScope", function ($window, $location, $rootScope) {
                function getFirstAnchor(list) {
                    var result = null;
                    return Array.prototype.some.call(list, function (element) {
                        return"a" === nodeName_(element) ? (result = element, !0) : void 0
                    }), result
                }
                function getYOffset() {
                    var offset = scroll.yOffset;
                    if (isFunction(offset))
                        offset = offset();
                    else if (isElement(offset)) {
                        var elem = offset[0], style = $window.getComputedStyle(elem);
                        offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom
                    } else
                        isNumber(offset) || (offset = 0);
                    return offset
                }
                function scrollTo(elem) {
                    if (elem) {
                        elem.scrollIntoView();
                        var offset = getYOffset();
                        if (offset) {
                            var elemTop = elem.getBoundingClientRect().top;
                            $window.scrollBy(0, elemTop - offset)
                        }
                    } else
                        $window.scrollTo(0, 0)
                }
                function scroll() {
                    var elm, hash = $location.hash();
                    hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null)
                }
                var document = $window.document;
                return autoScrollingEnabled && $rootScope.$watch(function () {
                    return $location.hash()
                }, function (newVal, oldVal) {
                    (newVal !== oldVal || "" !== newVal) && jqLiteDocumentLoaded(function () {
                        $rootScope.$evalAsync(scroll)
                    })
                }), scroll
            }]
    }
    function $$AsyncCallbackProvider() {
        this.$get = ["$$rAF", "$timeout", function ($$rAF, $timeout) {
                return $$rAF.supported ? function (fn) {
                    return $$rAF(fn)
                } : function (fn) {
                    return $timeout(fn, 0, !1)
                }
            }]
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1))
            } finally {
                if (outstandingRequestCount--, 0 === outstandingRequestCount)
                    for (; outstandingRequestCallbacks.length; )
                        try {
                            outstandingRequestCallbacks.pop()()
                        } catch (e) {
                            $log.error(e)
                        }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return-1 === index ? "" : url.substr(index + 1)
        }
        function startPoller(interval, setTimeout) {
            !function check() {
                forEach(pollFns, function (pollFn) {
                    pollFn()
                }), pollTimeout = setTimeout(check, interval)
            }()
        }
        function cacheStateAndFireUrlChange() {
            cacheState(), fireUrlChange()
        }
        function cacheState() {
            cachedState = window.history.state, cachedState = isUndefined(cachedState) ? null : cachedState, equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState
        }
        function fireUrlChange() {
            (lastBrowserUrl !== self.url() || lastHistoryState !== cachedState) && (lastBrowserUrl = self.url(), lastHistoryState = cachedState, forEach(urlChangeListeners, function (listener) {
                listener(self.url(), cachedState)
            }))
        }
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str)
            } catch (e) {
                return str
            }
        }
        var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function () {
            outstandingRequestCount++
        }, self.notifyWhenNoOutstandingRequests = function (callback) {
            forEach(pollFns, function (pollFn) {
                pollFn()
            }), 0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback)
        };
        var pollTimeout, pollFns = [];
        self.addPollFn = function (fn) {
            return isUndefined(pollTimeout) && startPoller(100, setTimeout), pollFns.push(fn), fn
        };
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null;
        cacheState(), lastHistoryState = cachedState, self.url = function (url, replace, state) {
            if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), history !== window.history && (history = window.history), url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState))
                    return self;
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (reloadLocation = url), replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url) : (history[replace ? "replaceState" : "pushState"](state, "", url), cacheState(), lastHistoryState = cachedState), self
            }
            return reloadLocation || location.href.replace(/%27/g, "'")
        }, self.state = function () {
            return cachedState
        };
        var urlChangeListeners = [], urlChangeInit = !1, lastCachedState = null;
        self.onUrlChange = function (callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), urlChangeListeners.push(callback), callback
        }, self.$$checkUrlChange = fireUrlChange, self.baseHref = function () {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : ""
        };
        var lastCookies = {}, lastCookieString = "", cookiePath = self.baseHref();
        self.cookies = function (name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (!name) {
                if (rawDocument.cookie !== lastCookieString)
                    for (lastCookieString = rawDocument.cookie, cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++)
                        cookie = cookieArray[i], index = cookie.indexOf("="), index > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), lastCookies[name] === undefined && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
                return lastCookies
            }
            value === undefined ? rawDocument.cookie = encodeURIComponent(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT" : isString(value) && (cookieLength = (rawDocument.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + ";path=" + cookiePath).length + 1, cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"))
        }, self.defer = function (fn, delay) {
            var timeoutId;
            return outstandingRequestCount++, timeoutId = setTimeout(function () {
                delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn)
            }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId
        }, self.defer.cancel = function (deferId) {
            return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), completeOutstandingRequest(noop), !0) : !1
        }
    }
    function $BrowserProvider() {
        this.$get = ["$window", "$log", "$sniffer", "$document", function ($window, $log, $sniffer, $document) {
                return new Browser($window, $document, $log, $sniffer)
            }]
    }
    function $CacheFactoryProvider() {
        this.$get = function () {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry, link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null)
                }
                function link(nextEntry, prevEntry) {
                    nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry))
                }
                if (cacheId in caches)
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {id: cacheId}), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {put: function (key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                            refresh(lruEntry)
                        }
                        if (!isUndefined(value))
                            return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), value
                    }, get: function (key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry)
                                return;
                            refresh(lruEntry)
                        }
                        return data[key]
                    }, remove: function (key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry)
                                return;
                            lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), link(lruEntry.n, lruEntry.p), delete lruHash[key]
                        }
                        delete data[key], size--
                    }, removeAll: function () {
                        data = {}, size = 0, lruHash = {}, freshEnd = staleEnd = null
                    }, destroy: function () {
                        data = null, stats = null, lruHash = null, delete caches[cacheId]
                    }, info: function () {
                        return extend({}, stats, {size: size})
                    }}
            }
            var caches = {};
            return cacheFactory.info = function () {
                var info = {};
                return forEach(caches, function (cache, cacheId) {
                    info[cacheId] = cache.info()
                }), info
            }, cacheFactory.get = function (cacheId) {
                return caches[cacheId]
            }, cacheFactory
        }
    }
    function $TemplateCacheProvider() {
        this.$get = ["$cacheFactory", function ($cacheFactory) {
                return $cacheFactory("templates")
            }]
    }
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        function parseIsolateBindings(scope, directiveName) {
            var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/, bindings = {};
            return forEach(scope, function (definition, scopeName) {
                var match = definition.match(LOCAL_REGEXP);
                if (!match)
                    throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition);
                bindings[scopeName] = {mode: match[1][0], collection: "*" === match[2], optional: "?" === match[3], attrName: match[4] || scopeName}
            }), bindings
        }
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        this.directive = function registerDirective(name, directiveFactory) {
            return assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + Suffix, ["$injector", "$exceptionHandler", function ($injector, $exceptionHandler) {
                    var directives = [];
                    return forEach(hasDirectives[name], function (directiveFactory, index) {
                        try {
                            var directive = $injector.invoke(directiveFactory);
                            isFunction(directive) ? directive = {compile: valueFn(directive)} : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, directive.require = directive.require || directive.controller && directive.name, directive.restrict = directive.restrict || "EA", isObject(directive.scope) && (directive.$$isolateBindings = parseIsolateBindings(directive.scope, directive.name)), directives.push(directive)
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                    }), directives
                }])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), this
        }, this.aHrefSanitizationWhitelist = function (regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist()
        }, this.imgSrcSanitizationWhitelist = function (regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist()
        };
        var debugInfoEnabled = !0;
        this.debugInfoEnabled = function (enabled) {
            return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled
        }, this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
                function safeAddClass($element, className) {
                    try {
                        $element.addClass(className)
                    } catch (e) {
                    }
                }
                function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                    $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)), forEach($compileNodes, function (node, index) {
                        node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/) && ($compileNodes[index] = jqLite(node).wrap("<span></span>").parent()[0])
                    });
                    var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                    compile.$$addScopeClass($compileNodes);
                    var namespace = null;
                    return function (scope, cloneConnectFn, options) {
                        assertArg(scope, "scope"), options = options || {};
                        var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                        parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                        var $linkNode;
                        if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, transcludeControllers)
                            for (var controllerName in transcludeControllers)
                                $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                        return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), $linkNode
                    }
                }
                function detectNamespaceForChildElements(parentElement) {
                    var node = parentElement && parentElement[0];
                    return node && "foreignobject" !== nodeName_(node) && node.toString().match(/SVG/) ? "svg" : "html"
                }
                function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                    function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                        if (nodeLinkFnFound) {
                            var nodeListLength = nodeList.length;
                            for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3)
                                idx = linkFns[i], stableNodeList[idx] = nodeList[idx]
                        } else
                            stableNodeList = nodeList;
                        for (i = 0, ii = linkFns.length; ii > i; )
                            node = stableNodeList[linkFns[i++]], nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn, nodeLinkFn.elementTranscludeOnThisElement) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null,
                                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn)
                    }
                    for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], i = 0; i < nodeList.length; i++)
                        attrs = new Attributes, directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : undefined, ignoreDirective), nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                    return linkFnFound ? compositeLinkFn : null
                }
                function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn, elementTransclusion) {
                    var boundTranscludeFn = function (transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                        return transcludedScope || (transcludedScope = scope.$new(!1, containingScope), transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {parentBoundTranscludeFn: previousBoundTranscludeFn, transcludeControllers: controllers, futureParentElement: futureParentElement})
                    };
                    return boundTranscludeFn
                }
                function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                    var match, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                    switch (nodeType) {
                        case NODE_TYPE_ELEMENT:
                            addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                            for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                                var attrStartName = !1, attrEndName = !1;
                                attr = nAttrs[j], name = attr.name, value = trim(attr.value), ngAttrName = directiveNormalize(name), (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function (match, letter) {
                                    return letter.toUpperCase()
                                }));
                                var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                                directiveIsMultiElement(directiveNName) && ngAttrName === directiveNName + "Start" && (attrStartName = name, attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName)
                            }
                            if (className = node.className, isObject(className) && (className = className.animVal), isString(className) && "" !== className)
                                for (; match = CLASS_DIRECTIVE_REGEXP.exec(className); )
                                    nName = directiveNormalize(match[2]), addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), className = className.substr(match.index + match[0].length);
                            break;
                        case NODE_TYPE_TEXT:
                            addTextInterpolateDirective(directives, node.nodeValue);
                            break;
                        case NODE_TYPE_COMMENT:
                            try {
                                match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue), match && (nName = directiveNormalize(match[1]), addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])))
                            } catch (e) {
                            }
                    }
                    return directives.sort(byPriority), directives
                }
                function groupScan(node, attrStart, attrEnd) {
                    var nodes = [], depth = 0;
                    if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                        do {
                            if (!node)
                                throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                            node.nodeType == NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling
                        } while (depth > 0)
                    } else
                        nodes.push(node);
                    return jqLite(nodes)
                }
                function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                    return function (scope, element, attrs, controllers, transcludeFn) {
                        return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn)
                    }
                }
                function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                    function addLinkFns(pre, post, attrStart, attrEnd) {
                        pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {isolateScope: !0})), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {isolateScope: !0})), postLinkFns.push(post))
                    }
                    function getControllers(directiveName, require, $element, elementControllers) {
                        var value, match, retrievalMethod = "data", optional = !1, $searchElement = $element;
                        if (isString(require)) {
                            if (match = require.match(REQUIRE_PREFIX_REGEXP), require = require.substring(match[0].length), match[3] && (match[1] ? match[3] = null : match[1] = match[3]), "^" === match[1] ? retrievalMethod = "inheritedData" : "^^" === match[1] && (retrievalMethod = "inheritedData", $searchElement = $element.parent()), "?" === match[2] && (optional = !0), value = null, elementControllers && "data" === retrievalMethod && (value = elementControllers[require]) && (value = value.instance), value = value || $searchElement[retrievalMethod]("$" + require + "Controller"), !value && !optional)
                                throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                            return value || null
                        }
                        return isArray(require) && (value = [], forEach(require, function (require) {
                            value.push(getControllers(directiveName, require, $element, elementControllers))
                        })), value
                    }
                    function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                        function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                            var transcludeControllers;
                            return isScope(scope) || (futureParentElement = cloneAttachFn, cloneAttachFn = scope, scope = undefined), hasElementTranscludeDirective && (transcludeControllers = elementControllers), futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element), boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild)
                        }
                        var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element, attrs;
                        if (compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode), attrs = new Attributes($element, templateAttrs)), newIsolateScopeDirective && (isolateScope = scope.$new(!0)), boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn), controllerDirectives && (controllers = {}, elementControllers = {}, forEach(controllerDirectives, function (directive) {
                            var controllerInstance, locals = {$scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope, $element: $element, $attrs: attrs, $transclude: transcludeFn};
                            controller = directive.controller, "@" == controller && (controller = attrs[directive.name]), controllerInstance = $controller(controller, locals, !0, directive.controllerAs), elementControllers[directive.name] = controllerInstance, hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance.instance), controllers[directive.name] = controllerInstance
                        })), newIsolateScopeDirective) {
                            compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), compile.$$addScopeClass($element, !0);
                            var isolateScopeController = controllers && controllers[newIsolateScopeDirective.name], isolateBindingContext = isolateScope;
                            isolateScopeController && isolateScopeController.identifier && newIsolateScopeDirective.bindToController === !0 && (isolateBindingContext = isolateScopeController.instance), forEach(isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, function (definition, scopeName) {
                                var lastValue, parentGet, parentSet, compare, attrName = definition.attrName, optional = definition.optional, mode = definition.mode;
                                switch (mode) {
                                    case"@":
                                        attrs.$observe(attrName, function (value) {
                                            isolateBindingContext[scopeName] = value
                                        }), attrs.$$observers[attrName].$$scope = scope, attrs[attrName] && (isolateBindingContext[scopeName] = $interpolate(attrs[attrName])(scope));
                                        break;
                                    case"=":
                                        if (optional && !attrs[attrName])
                                            return;
                                        parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : function (a, b) {
                                            return a === b || a !== a && b !== b
                                        }, parentSet = parentGet.assign || function () {
                                            throw lastValue = isolateBindingContext[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name)
                                        }, lastValue = isolateBindingContext[scopeName] = parentGet(scope);
                                        var parentValueWatch = function (parentValue) {
                                            return compare(parentValue, isolateBindingContext[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = isolateBindingContext[scopeName]) : isolateBindingContext[scopeName] = parentValue), lastValue = parentValue
                                        };
                                        parentValueWatch.$stateful = !0;
                                        var unwatch;
                                        unwatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), isolateScope.$on("$destroy", unwatch);
                                        break;
                                    case"&":
                                        parentGet = $parse(attrs[attrName]), isolateBindingContext[scopeName] = function (locals) {
                                            return parentGet(scope, locals)
                                        }
                                    }
                            })
                        }
                        for (controllers && (forEach(controllers, function (controller) {
                            controller()
                        }), controllers = null), i = 0, ii = preLinkFns.length; ii > i; i++)
                            linkFn = preLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                        var scopeToChild = scope;
                        for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn), i = postLinkFns.length - 1; i >= 0; i--)
                            linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn)
                    }
                    previousCompileContext = previousCompileContext || {};
                    for (var newScopeDirective, controllers, directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; ii > i; i++) {
                        directive = directives[i];
                        var attrStart = directive.$$start, attrEnd = directive.$$end;
                        if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = undefined, terminalPriority > directive.priority)
                            break;
                        if ((directiveValue = directive.scope) && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), newScopeDirective = newScopeDirective || directive), directiveName = directive.name, !directive.templateUrl && directive.controller && (directiveValue = directive.controller, controllerDirectives = controllerDirectives || {}, assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), controllerDirectives[directiveName] = directive), (directiveValue = directive.transclude) && (hasTranscludeDirective = !0, directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), nonTlbTranscludeDirective = directive), "element" == directiveValue ? (hasElementTranscludeDirective = !0, terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")), compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective})) : ($template = jqLite(jqLiteClone(compileNode)).contents(), $compileNode.empty(), childTranscludeFn = compile($template, transcludeFn))), directive.template)
                            if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                                if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT)
                                    throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                                replaceWith(jqCollection, $compileNode, compileNode);
                                var newTemplateAttrs = {$attr: {}}, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length
                            } else
                                $compileNode.html(directiveValue);
                        if (directive.templateUrl)
                            hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directive.replace && (replaceDirective = directive), nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {controllerDirectives: controllerDirectives, newIsolateScopeDirective: newIsolateScopeDirective, templateDirective: templateDirective, nonTlbTranscludeDirective: nonTlbTranscludeDirective}), ii = directives.length;
                        else if (directive.compile)
                            try {
                                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn), isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) : linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd)
                            } catch (e) {
                                $exceptionHandler(e, startingTag($compileNode))
                            }
                        directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority))
                    }
                    return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, nodeLinkFn.elementTranscludeOnThisElement = hasElementTranscludeDirective, nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, nodeLinkFn
                }
                function markDirectivesAsIsolate(directives) {
                    for (var j = 0, jj = directives.length; jj > j; j++)
                        directives[j] = inherit(directives[j], {$$isolateScope: !0})
                }
                function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                    if (name === ignoreDirective)
                        return null;
                    var match = null;
                    if (hasDirectives.hasOwnProperty(name))
                        for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++)
                            try {
                                directive = directives[i], (maxPriority === undefined || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName})), tDirectives.push(directive), match = directive)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                    return match
                }
                function directiveIsMultiElement(name) {
                    if (hasDirectives.hasOwnProperty(name))
                        for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++)
                            if (directive = directives[i], directive.multiElement)
                                return!0;
                    return!1
                }
                function mergeTemplateAttributes(dst, src) {
                    var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                    forEach(dst, function (value, key) {
                        "$" != key.charAt(0) && (src[key] && src[key] !== value && (value += ("style" === key ? ";" : " ") + src[key]), dst.$set(key, value, !0, srcAttr[key]))
                    }), forEach(src, function (value, key) {
                        "class" == key ? (safeAddClass($element, value), dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value) : "style" == key ? ($element.attr("style", $element.attr("style") + ";" + value), dst.style = (dst.style ? dst.style + ";" : "") + value) : "$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value, dstAttr[key] = srcAttr[key])
                    })
                }
                function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                    var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective}), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                    return $compileNode.empty(), $templateRequest($sce.getTrustedResourceUrl(templateUrl)).then(function (content) {
                        var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                        if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                            if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT)
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                            tempTemplateAttrs = {$attr: {}}, replaceWith($rootElement, $compileNode, compileNode);
                            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                            isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives), directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs)
                        } else
                            compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                        for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), forEach($rootElement, function (node, i) {
                            node == compileNode && ($rootElement[i] = $compileNode[0])
                        }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                            var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                            if (!scope.$$destroyed) {
                                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                    var oldClasses = beforeTemplateLinkNode.className;
                                    previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses)
                                }
                                childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn)
                            }
                        }
                        linkQueue = null
                    }), function (ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                        var childBoundTranscludeFn = boundTranscludeFn;
                        scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)))
                    }
                }
                function byPriority(a, b) {
                    var diff = b.priority - a.priority;
                    return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index
                }
                function assertNoDuplicate(what, previousDirective, directive, element) {
                    if (previousDirective)
                        throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element))
                }
                function addTextInterpolateDirective(directives, text) {
                    var interpolateFn = $interpolate(text, !0);
                    interpolateFn && directives.push({priority: 0, compile: function (templateNode) {
                            var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                            return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function (scope, node) {
                                var parent = node.parent();
                                hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), scope.$watch(interpolateFn, function (value) {
                                    node[0].nodeValue = value
                                })
                            }
                        }})
                }
                function wrapTemplate(type, template) {
                    switch (type = lowercase(type || "html")) {
                        case"svg":
                        case"math":
                            var wrapper = document.createElement("div");
                            return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;
                        default:
                            return template
                        }
                }
                function getTrustedContext(node, attrNormalizedName) {
                    if ("srcdoc" == attrNormalizedName)
                        return $sce.HTML;
                    var tag = nodeName_(node);
                    return"xlinkHref" == attrNormalizedName || "form" == tag && "action" == attrNormalizedName || "img" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0
                }
                function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                    var trustedContext = getTrustedContext(node, name);
                    allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                    var interpolateFn = $interpolate(value, !0, trustedContext, allOrNothing);
                    if (interpolateFn) {
                        if ("multiple" === name && "select" === nodeName_(node))
                            throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                        directives.push({priority: 100, compile: function () {
                                return{pre: function (scope, element, attr) {
                                        var $$observers = attr.$$observers || (attr.$$observers = {});
                                        if (EVENT_HANDLER_ATTR_REGEXP.test(name))
                                            throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                        var newValue = attr[name];
                                        newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function (newValue, oldValue) {
                                            "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue)
                                        }))
                                    }}
                            }})
                    }
                }
                function replaceWith($rootElement, elementsToRemove, newNode) {
                    var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                    if ($rootElement)
                        for (i = 0, ii = $rootElement.length; ii > i; i++)
                            if ($rootElement[i] == firstElementToRemove) {
                                $rootElement[i++] = newNode;
                                for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, j2++)
                                    jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                                $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                                break
                            }
                    parent && parent.replaceChild(newNode, firstElementToRemove);
                    var fragment = document.createDocumentFragment();
                    fragment.appendChild(firstElementToRemove), jqLite(newNode).data(jqLite(firstElementToRemove).data()), jQuery ? (skipDestroyOnNextJQueryCleanData = !0, jQuery.cleanData([firstElementToRemove])) : delete jqLite.cache[firstElementToRemove[jqLite.expando]];
                    for (var k = 1, kk = elementsToRemove.length; kk > k; k++) {
                        var element = elementsToRemove[k];
                        jqLite(element).remove(), fragment.appendChild(element), delete elementsToRemove[k]
                    }
                    elementsToRemove[0] = newNode, elementsToRemove.length = 1
                }
                function cloneAndAnnotateFn(fn, annotation) {
                    return extend(function () {
                        return fn.apply(null, arguments)
                    }, fn, annotation)
                }
                function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                    try {
                        linkFn(scope, $element, attrs, controllers, transcludeFn)
                    } catch (e) {
                        $exceptionHandler(e, startingTag($element))
                    }
                }
                var Attributes = function (element, attributesToCopy) {
                    if (attributesToCopy) {
                        var i, l, key, keys = Object.keys(attributesToCopy);
                        for (i = 0, l = keys.length; l > i; i++)
                            key = keys[i], this[key] = attributesToCopy[key]
                    } else
                        this.$attr = {};
                    this.$$element = element
                };
                Attributes.prototype = {$normalize: directiveNormalize, $addClass: function (classVal) {
                        classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal)
                    }, $removeClass: function (classVal) {
                        classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal)
                    }, $updateClass: function (newClasses, oldClasses) {
                        var toAdd = tokenDifference(newClasses, oldClasses);
                        toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                        var toRemove = tokenDifference(oldClasses, newClasses);
                        toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove)
                    }, $set: function (key, value, writeAttr, attrName) {
                        var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(node, key), observer = key;
                        if (booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), nodeName = nodeName_(this.$$element), "a" === nodeName && "href" === key || "img" === nodeName && "src" === key)
                            this[key] = value = $$sanitizeUri(value, "src" === key);
                        else if ("img" === nodeName && "srcset" === key) {
                            for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; nbrUrisWith2parts > i; i++) {
                                var innerIdx = 2 * i;
                                result += $$sanitizeUri(trim(rawUris[innerIdx]), !0), result += " " + trim(rawUris[innerIdx + 1])
                            }
                            var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                            result += $$sanitizeUri(trim(lastTuple[0]), !0), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), this[key] = value = result
                        }
                        writeAttr !== !1 && (null === value || value === undefined ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value));
                        var $$observers = this.$$observers;
                        $$observers && forEach($$observers[observer], function (fn) {
                            try {
                                fn(value)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        })
                    }, $observe: function (key, fn) {
                        var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                        return listeners.push(fn), $rootScope.$evalAsync(function () {
                            !listeners.$$inter && attrs.hasOwnProperty(key) && fn(attrs[key])
                        }), function () {
                            arrayRemove(listeners, fn)
                        }
                    }};
                var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity : function (template) {
                    return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol)
                }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
                return compile.$$addBindingInfo = debugInfoEnabled ? function ($element, binding) {
                    var bindings = $element.data("$binding") || [];
                    isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), $element.data("$binding", bindings)
                } : noop, compile.$$addBindingClass = debugInfoEnabled ? function ($element) {
                    safeAddClass($element, "ng-binding")
                } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function ($element, scope, isolated, noTemplate) {
                    var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                    $element.data(dataName, scope)
                } : noop, compile.$$addScopeClass = debugInfoEnabled ? function ($element, isolated) {
                    safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope")
                } : noop, compile
            }]
    }
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""))
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer:for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                if (token == tokens2[j])
                    continue outer;
            values += (values.length > 0 ? " " : "") + token
        }
        return values
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (1 >= i)
            return jqNodes;
        for (; i--; ) {
            var node = jqNodes[i];
            node.nodeType === NODE_TYPE_COMMENT && splice.call(jqNodes, i, 1)
        }
        return jqNodes
    }
    function $ControllerProvider() {
        var controllers = {}, globals = !1, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function (name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor
        }, this.allowGlobals = function () {
            globals = !0
        }, this.$get = ["$injector", "$window", function ($injector, $window) {
                function addIdentifier(locals, identifier, instance, name) {
                    if (!locals || !isObject(locals.$scope))
                        throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                    locals.$scope[identifier] = instance
                }
                return function (expression, locals, later, ident) {
                    var instance, match, constructor, identifier;
                    if (later = later === !0, ident && isString(ident) && (identifier = ident), isString(expression) && (match = expression.match(CNTRL_REG), constructor = match[1], identifier = identifier || match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || (globals ? getter($window, constructor, !0) : undefined), assertArgFn(expression, constructor, !0)), later) {
                        var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                        return instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), extend(function () {
                            return $injector.invoke(expression, instance, locals, constructor), instance
                        }, {instance: instance, identifier: identifier})
                    }
                    return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), instance
                }
            }]
    }
    function $DocumentProvider() {
        this.$get = ["$window", function (window) {
                return jqLite(window.document)
            }]
    }
    function $ExceptionHandlerProvider() {
        this.$get = ["$log", function ($log) {
                return function (exception, cause) {
                    $log.error.apply($log, arguments)
                }
            }]
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                (contentType && 0 === contentType.indexOf(APPLICATION_JSON) || isJsonLike(tempData)) && (data = fromJson(tempData))
            }
        }
        return data
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str)
    }
    function parseHeaders(headers) {
        var key, val, i, parsed = createMap();
        return headers ? (forEach(headers.split("\n"), function (line) {
            i = line.indexOf(":"), key = lowercase(trim(line.substr(0, i))), val = trim(line.substr(i + 1)), key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val)
        }), parsed) : parsed
    }
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function (name) {
            if (headersObj || (headersObj = parseHeaders(headers)), name) {
                var value = headersObj[lowercase(name)];
                return void 0 === value && (value = null), value
            }
            return headersObj
        }
    }
    function transformData(data, headers, status, fns) {
        return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function (fn) {
            data = fn(data, headers, status)
        }), data)
    }
    function isSuccess(status) {
        return status >= 200 && 300 > status
    }
    function $HttpProvider() {
        var defaults = this.defaults = {transformResponse: [defaultHttpResponseTransform], transformRequest: [function (d) {
                    return!isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d)
                }], headers: {common: {Accept: "application/json, text/plain, */*"}, post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON), put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON), patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)}, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN"}, useApplyAsync = !1;
        this.useApplyAsync = function (value) {
            return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ["$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
                function $http(requestConfig) {
                    function transformResponse(response) {
                        var resp = extend({}, response);
                        return response.data ? resp.data = transformData(response.data, response.headers, response.status, config.transformResponse) : resp.data = response.data, isSuccess(response.status) ? resp : $q.reject(resp)
                    }
                    function executeHeaderFns(headers) {
                        var headerContent, processedHeaders = {};
                        return forEach(headers, function (headerFn, header) {
                            isFunction(headerFn) ? (headerContent = headerFn(), null != headerContent && (processedHeaders[header] = headerContent)) : processedHeaders[header] = headerFn
                        }), processedHeaders
                    }
                    function mergeHeaders(config) {
                        var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                        defaultHeadersIteration:for (defHeaderName in defHeaders) {
                            lowercaseDefHeaderName = lowercase(defHeaderName);
                            for (reqHeaderName in reqHeaders)
                                if (lowercase(reqHeaderName) === lowercaseDefHeaderName)
                                    continue defaultHeadersIteration;
                            reqHeaders[defHeaderName] = defHeaders[defHeaderName]
                        }
                        return executeHeaderFns(reqHeaders)
                    }
                    if (!angular.isObject(requestConfig))
                        throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                    var config = extend({method: "get", transformRequest: defaults.transformRequest, transformResponse: defaults.transformResponse}, requestConfig);
                    config.headers = mergeHeaders(requestConfig), config.method = uppercase(config.method);
                    var serverRequest = function (config) {
                        var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                        return isUndefined(reqData) && forEach(headers, function (value, header) {
                            "content-type" === lowercase(header) && delete headers[header]
                        }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), sendReq(config, reqData).then(transformResponse, transformResponse)
                    }, chain = [serverRequest, undefined], promise = $q.when(config);
                    for (forEach(reversedInterceptors, function (interceptor) {
                        (interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError), (interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError)
                    }); chain.length; ) {
                        var thenFn = chain.shift(), rejectFn = chain.shift();
                        promise = promise.then(thenFn, rejectFn)
                    }
                    return promise.success = function (fn) {
                        return promise.then(function (response) {
                            fn(response.data, response.status, response.headers, config)
                        }), promise
                    }, promise.error = function (fn) {
                        return promise.then(null, function (response) {
                            fn(response.data, response.status, response.headers, config)
                        }), promise
                    }, promise
                }
                function createShortMethods(names) {
                    forEach(arguments, function (name) {
                        $http[name] = function (url, config) {
                            return $http(extend(config || {}, {method: name, url: url}))
                        }
                    })
                }
                function createShortMethodsWithData(name) {
                    forEach(arguments, function (name) {
                        $http[name] = function (url, data, config) {
                            return $http(extend(config || {}, {method: name, url: url, data: data}))
                        }
                    })
                }
                function sendReq(config, reqData) {
                    function done(status, response, headersString, statusText) {
                        function resolveHttpPromise() {
                            resolvePromise(response, status, headersString, statusText)
                        }
                        cache && (isSuccess(status) ? cache.put(url, [status, response, parseHeaders(headersString), statusText]) : cache.remove(url)), useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), $rootScope.$$phase || $rootScope.$apply())
                    }
                    function resolvePromise(response, status, headers, statusText) {
                        status = Math.max(status, 0), (isSuccess(status) ? deferred.resolve : deferred.reject)({data: response, status: status, headers: headersGetter(headers), config: config, statusText: statusText})
                    }
                    function resolvePromiseWithResult(result) {
                        resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText)
                    }
                    function removePendingReq() {
                        var idx = $http.pendingRequests.indexOf(config);
                        -1 !== idx && $http.pendingRequests.splice(idx, 1)
                    }
                    var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, url = buildUrl(config.url, config.params);
                    if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), cache && (cachedResp = cache.get(url), isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK") : cache.put(url, promise)), isUndefined(cachedResp)) {
                        var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                        xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType)
                    }
                    return promise
                }
                function buildUrl(url, params) {
                    if (!params)
                        return url;
                    var parts = [];
                    return forEachSorted(params, function (value, key) {
                        null === value || isUndefined(value) || (isArray(value) || (value = [value]), forEach(value, function (v) {
                            isObject(v) && (v = isDate(v) ? v.toISOString() : toJson(v)), parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v))
                        }))
                    }), parts.length > 0 && (url += (-1 == url.indexOf("?") ? "?" : "&") + parts.join("&")), url
                }
                var defaultCache = $cacheFactory("$http"), reversedInterceptors = [];
                return forEach(interceptorFactories, function (interceptorFactory) {
                    reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory))
                }), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), createShortMethodsWithData("post", "put", "patch"), $http.defaults = defaults, $http
            }]
    }
    function createXhr() {
        return new window.XMLHttpRequest
    }
    function $HttpBackendProvider() {
        this.$get = ["$browser", "$window", "$document", function ($browser, $window, $document) {
                return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0])
            }]
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function (event) {
                removeEventListenerFn(script, "load", callback), removeEventListenerFn(script, "error", callback), rawDocument.body.removeChild(script), script = null;
                var status = -1, text = "unknown";
                event && ("load" !== event.type || callbacks[callbackId].called || (event = {type: "error"}), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text)
            }, addEventListenerFn(script, "load", callback), addEventListenerFn(script, "error", callback), rawDocument.body.appendChild(script), callback
        }
        return function (method, url, post, callback, headers, timeout, withCredentials, responseType) {
            function timeoutRequest() {
                jsonpDone && jsonpDone(), xhr && xhr.abort()
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                timeoutId !== undefined && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, callback(status, response, headersString, statusText), $browser.$$completeOutstandingRequest(noop)
            }
            if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" == lowercase(method)) {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function (data) {
                    callbacks[callbackId].data = data, callbacks[callbackId].called = !0
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function (status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text), callbacks[callbackId] = noop
                })
            } else {
                var xhr = createXhr();
                xhr.open(method, url, !0), forEach(headers, function (value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value)
                }), xhr.onload = function () {
                    var statusText = xhr.statusText || "", response = "response"in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                    0 === status && (status = response ? 200 : "file" == urlResolve(url).protocol ? 404 : 0), completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText)
                };
                var requestError = function () {
                    completeRequest(callback, -1, null, null, "")
                };
                if (xhr.onerror = requestError, xhr.onabort = requestError, withCredentials && (xhr.withCredentials = !0), responseType)
                    try {
                        xhr.responseType = responseType
                    } catch (e) {
                        if ("json" !== responseType)
                            throw e
                    }
                xhr.send(post || null)
            }
            if (timeout > 0)
                var timeoutId = $browserDefer(timeoutRequest, timeout);
            else
                isPromiseLike(timeout) && timeout.then(timeoutRequest)
        }
    }
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function (value) {
            return value ? (startSymbol = value, this) : startSymbol
        }, this.endSymbol = function (value) {
            return value ? (endSymbol = value, this) : endSymbol
        }, this.$get = ["$parse", "$exceptionHandler", "$sce", function ($parse, $exceptionHandler, $sce) {
                function escape(ch) {
                    return"\\\\\\" + ch
                }
                function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                    function unescapeText(text) {
                        return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol)
                    }
                    function parseStringifyInterceptor(value) {
                        try {
                            return value = getValue(value), allOrNothing && !isDefined(value) ? value : stringify(value)
                        } catch (err) {
                            var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                            $exceptionHandler(newErr)
                        }
                    }
                    allOrNothing = !!allOrNothing;
                    for (var startIndex, endIndex, exp, index = 0, expressions = [], parseFns = [], textLength = text.length, concat = [], expressionPositions = []; textLength > index; ) {
                        if (-1 == (startIndex = text.indexOf(startSymbol, index)) || -1 == (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                            index !== textLength && concat.push(unescapeText(text.substring(index)));
                            break
                        }
                        index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), parseFns.push($parse(exp, parseStringifyInterceptor)), index = endIndex + endSymbolLength, expressionPositions.push(concat.length), concat.push("")
                    }
                    if (trustedContext && concat.length > 1)
                        throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
                    if (!mustHaveExpression || expressions.length) {
                        var compute = function (values) {
                            for (var i = 0, ii = expressions.length; ii > i; i++) {
                                if (allOrNothing && isUndefined(values[i]))
                                    return;
                                concat[expressionPositions[i]] = values[i]
                            }
                            return concat.join("")
                        }, getValue = function (value) {
                            return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value)
                        }, stringify = function (value) {
                            if (null == value)
                                return"";
                            switch (typeof value) {
                                case"string":
                                    break;
                                case"number":
                                    value = "" + value;
                                    break;
                                default:
                                    value = toJson(value)
                            }
                            return value
                        };
                        return extend(function (context) {
                            var i = 0, ii = expressions.length, values = new Array(ii);
                            try {
                                for (; ii > i; i++)
                                    values[i] = parseFns[i](context);
                                return compute(values)
                            } catch (err) {
                                var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                                $exceptionHandler(newErr)
                            }
                        }, {exp: text, expressions: expressions, $$watchDelegate: function (scope, listener, objectEquality) {
                                var lastValue;
                                return scope.$watchGroup(parseFns, function (values, oldValues) {
                                    var currValue = compute(values);
                                    isFunction(listener) && listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), lastValue = currValue
                                }, objectEquality)
                            }})
                    }
                }
                var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
                return $interpolate.startSymbol = function () {
                    return startSymbol
                }, $interpolate.endSymbol = function () {
                    return endSymbol
                }, $interpolate
            }]
    }
    function $IntervalProvider() {
        this.$get = ["$rootScope", "$window", "$q", "$$q", function ($rootScope, $window, $q, $$q) {
                function interval(fn, delay, count, invokeApply) {
                    var setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                    return count = isDefined(count) ? count : 0, promise.then(null, null, fn), promise.$$intervalId = setInterval(function () {
                        deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply()
                    }, delay), intervals[promise.$$intervalId] = deferred, promise
                }
                var intervals = {};
                return interval.cancel = function (promise) {
                    return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), $window.clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], !0) : !1
                }, interval
            }]
    }
    function $LocaleProvider() {
        this.$get = function () {
            return{id: "en-us", NUMBER_FORMATS: {DECIMAL_SEP: ".", GROUP_SEP: ",", PATTERNS: [{minInt: 1, minFrac: 0, maxFrac: 3, posPre: "", posSuf: "", negPre: "-", negSuf: "", gSize: 3, lgSize: 3}, {minInt: 1, minFrac: 2, maxFrac: 2, posPre: "\xa4", posSuf: "", negPre: "(\xa4", negSuf: ")", gSize: 3, lgSize: 3}], CURRENCY_SYM: "$"}, DATETIME_FORMATS: {MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","), SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","), DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","), SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","), AMPMS: ["AM", "PM"], medium: "MMM d, y h:mm:ss a", "short": "M/d/yy h:mm a", fullDate: "EEEE, MMMM d, y", longDate: "MMMM d, y", mediumDate: "MMM d, y", shortDate: "M/d/yy", mediumTime: "h:mm:ss a", shortTime: "h:mm a"}, pluralCat: function (num) {
                    return 1 === num ? "one" : "other"
                }}
        }
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; )
            segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/")
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null
    }
    function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = "/" !== relativeUrl.charAt(0);
        prefixed && (relativeUrl = "/" + relativeUrl);
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path)
    }
    function beginsWith(begin, whole) {
        return 0 === whole.indexOf(begin) ? whole.substr(begin.length) : void 0
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return-1 == index ? url : url.substr(0, index)
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1")
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1)
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2))
    }
    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this), this.$$parse = function (url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl))
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this), this.$$path || (this.$$path = "/"), this.$$compose()
        }, this.$$compose = function () {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1)
        }, this.$$parseLinkUrl = function (url, relHref) {
            if (relHref && "#" === relHref[0])
                return this.hash(relHref.slice(1)), !0;
            var appUrl, prevAppUrl, rewrittenUrl;
            return(appUrl = beginsWith(appBase, url)) !== undefined ? (prevAppUrl = appUrl, rewrittenUrl = (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) : appBase + prevAppUrl) : (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile == url + "/" && (rewrittenUrl = appBaseNoFile), rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl
        }
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this), this.$$parse = function (url) {
            function removeWindowsDriveName(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return 0 === url.indexOf(base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), firstPathSegmentMatch ? firstPathSegmentMatch[1] : path)
            }
            var withoutHashUrl, withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            "#" === withoutBaseUrl.charAt(0) ? (withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl), isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)) : withoutHashUrl = this.$$html5 ? withoutBaseUrl : "", parseAppUrl(withoutHashUrl, this), this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), this.$$compose()
        }, this.$$compose = function () {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "")
        }, this.$$parseLinkUrl = function (url, relHref) {
            return stripHash(appBase) == stripHash(url) ? (this.$$parse(url), !0) : !1
        }
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$parseLinkUrl = function (url, relHref) {
            if (relHref && "#" === relHref[0])
                return this.hash(relHref.slice(1)), !0;
            var rewrittenUrl, appUrl;
            return appBase == stripHash(url) ? rewrittenUrl = url : (appUrl = beginsWith(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl
        }, this.$$compose = function () {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url
        }
    }
    function locationGetter(property) {
        return function () {
            return this[property]
        }
    }
    function locationGetterSetter(property, preprocess) {
        return function (value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), this.$$compose(), this)
        }
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = {enabled: !1, requireBase: !0, rewriteLinks: !0};
        this.hashPrefix = function (prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix
        }, this.html5Mode = function (mode) {
            return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), isBoolean(mode.rewriteLinks) && (html5Mode.rewriteLinks = mode.rewriteLinks), this) : html5Mode
        }, this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function ($rootScope, $browser, $sniffer, $rootElement, $window) {
                function setBrowserUrlWithFallback(url, replace, state) {
                    var oldUrl = $location.url(), oldState = $location.$$state;
                    try {
                        $browser.url(url, replace, state), $location.$$state = $browser.state()
                    } catch (e) {
                        throw $location.url(oldUrl), $location.$$state = oldState, e
                    }
                }
                function afterLocationChange(oldUrl, oldState) {
                    $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState)
                }
                var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
                if (html5Mode.enabled) {
                    if (!baseHref && html5Mode.requireBase)
                        throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                    appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url
                } else
                    appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
                $location = new LocationMode(appBase, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl), $location.$$state = $browser.state();
                var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                $rootElement.on("click", function (event) {
                    if (html5Mode.rewriteLinks && !event.ctrlKey && !event.metaKey && 2 != event.which) {
                        for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); )
                            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                                return;
                        var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                        isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), $location.absUrl() != $browser.url() && ($rootScope.$apply(), $window.angular["ff-684208-preventDefault"] = !0))
                    }
                }), $location.absUrl() != initialUrl && $browser.url($location.absUrl(), !0);
                var initializing = !0;
                return $browser.onUrlChange(function (newUrl, newState) {
                    $rootScope.$evalAsync(function () {
                        var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                        $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, afterLocationChange(oldUrl, oldState)))
                    }), $rootScope.$$phase || $rootScope.$digest()
                }), $rootScope.$watch(function () {
                    var oldUrl = trimEmptyHash($browser.url()), newUrl = trimEmptyHash($location.absUrl()), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                    (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function () {
                        var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), afterLocationChange(oldUrl, oldState)))
                    })), $location.$$replace = !1
                }), $location
            }]
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function (flag) {
            return isDefined(flag) ? (debug = flag, this) : debug
        }, this.$get = ["$window", function ($window) {
                function formatError(arg) {
                    return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), arg
                }
                function consoleLog(type) {
                    var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
                    try {
                        hasApply = !!logFn.apply
                    } catch (e) {
                    }
                    return hasApply ? function () {
                        var args = [];
                        return forEach(arguments, function (arg) {
                            args.push(formatError(arg))
                        }), logFn.apply(console, args)
                    } : function (arg1, arg2) {
                        logFn(arg1, null == arg2 ? "" : arg2)
                    }
                }
                return{log: consoleLog("log"), info: consoleLog("info"), warn: consoleLog("warn"), error: consoleLog("error"), debug: function () {
                        var fn = consoleLog("debug");
                        return function () {
                            debug && fn.apply(self, arguments)
                        }
                    }()}
            }]
    }
    function ensureSafeMemberName(name, fullExpression) {
        if ("__defineGetter__" === name || "__defineSetter__" === name || "__lookupGetter__" === name || "__lookupSetter__" === name || "__proto__" === name)
            throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! Expression: {0}", fullExpression);
        return name
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj)
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.window === obj)
                throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find))
                throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === Object)
                throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression)
        }
        return obj
    }
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj)
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === CALL || obj === APPLY || obj === BIND)
                throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression)
        }
    }
    function isConstant(exp) {
        return exp.constant
    }
    function setter(obj, locals, path, setValue, fullExp) {
        ensureSafeObject(obj, fullExp), ensureSafeObject(locals, fullExp);
        for (var key, element = path.split("."), i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = 0 === i && locals && locals[key] || obj[key];
            propertyObj || (propertyObj = {}, obj[key] = propertyObj), obj = ensureSafeObject(propertyObj, fullExp)
        }
        return key = ensureSafeMemberName(element.shift(), fullExp), ensureSafeObject(obj[key], fullExp), obj[key] = setValue, setValue
    }
    function isPossiblyDangerousMemberName(name) {
        return"constructor" == name
    }
    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, expensiveChecks) {
        ensureSafeMemberName(key0, fullExp), ensureSafeMemberName(key1, fullExp), ensureSafeMemberName(key2, fullExp), ensureSafeMemberName(key3, fullExp), ensureSafeMemberName(key4, fullExp);
        var eso = function (o) {
            return ensureSafeObject(o, fullExp)
        }, eso0 = expensiveChecks || isPossiblyDangerousMemberName(key0) ? eso : identity, eso1 = expensiveChecks || isPossiblyDangerousMemberName(key1) ? eso : identity, eso2 = expensiveChecks || isPossiblyDangerousMemberName(key2) ? eso : identity, eso3 = expensiveChecks || isPossiblyDangerousMemberName(key3) ? eso : identity, eso4 = expensiveChecks || isPossiblyDangerousMemberName(key4) ? eso : identity;
        return function (scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            return null == pathVal ? pathVal : (pathVal = eso0(pathVal[key0]), key1 ? null == pathVal ? undefined : (pathVal = eso1(pathVal[key1]), key2 ? null == pathVal ? undefined : (pathVal = eso2(pathVal[key2]), key3 ? null == pathVal ? undefined : (pathVal = eso3(pathVal[key3]), key4 ? null == pathVal ? undefined : pathVal = eso4(pathVal[key4]) : pathVal) : pathVal) : pathVal) : pathVal)
        }
    }
    function getterFnWithEnsureSafeObject(fn, fullExpression) {
        return function (s, l) {
            return fn(s, l, ensureSafeObject, fullExpression)
        }
    }
    function getterFn(path, options, fullExp) {
        var expensiveChecks = options.expensiveChecks, getterFnCache = expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault, fn = getterFnCache[path];
        if (fn)
            return fn;
        var pathKeys = path.split("."), pathKeysLength = pathKeys.length;
        if (options.csp)
            fn = 6 > pathKeysLength ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, expensiveChecks) : function (scope, locals) {
                var val, i = 0;
                do
                    val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, expensiveChecks)(scope, locals), locals = undefined, scope = val;
                while (pathKeysLength > i);
                return val
            };
        else {
            var code = "";
            expensiveChecks && (code += "s = eso(s, fe);\nl = eso(l, fe);\n");
            var needsEnsureSafeObject = expensiveChecks;
            forEach(pathKeys, function (key, index) {
                ensureSafeMemberName(key, fullExp);
                var lookupJs = (index ? "s" : '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + "." + key;
                (expensiveChecks || isPossiblyDangerousMemberName(key)) && (lookupJs = "eso(" + lookupJs + ", fe)", needsEnsureSafeObject = !0), code += "if(s == null) return undefined;\ns=" + lookupJs + ";\n"
            }), code += "return s;";
            var evaledFnGetter = new Function("s", "l", "eso", "fe", code);
            evaledFnGetter.toString = valueFn(code), needsEnsureSafeObject && (evaledFnGetter = getterFnWithEnsureSafeObject(evaledFnGetter, fullExp)), fn = evaledFnGetter
        }
        return fn.sharedGetter = !0, fn.assign = function (self, value, locals) {
            return setter(self, locals, path, value, path)
        }, getterFnCache[path] = fn, fn
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value)
    }
    function $ParseProvider() {
        var cacheDefault = createMap(), cacheExpensive = createMap();
        this.$get = ["$filter", "$sniffer", function ($filter, $sniffer) {
                function wrapSharedExpression(exp) {
                    var wrapped = exp;
                    return exp.sharedGetter && (wrapped = function (self, locals) {
                        return exp(self, locals)
                    }, wrapped.literal = exp.literal, wrapped.constant = exp.constant, wrapped.assign = exp.assign), wrapped
                }
                function collectExpressionInputs(inputs, list) {
                    for (var i = 0, ii = inputs.length; ii > i; i++) {
                        var input = inputs[i];
                        input.constant || (input.inputs ? collectExpressionInputs(input.inputs, list) : -1 === list.indexOf(input) && list.push(input))
                    }
                    return list
                }
                function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                    return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : "object" == typeof newValue && (newValue = getValueOf(newValue), "object" == typeof newValue) ? !1 : newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue
                }
                function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                    var lastResult, inputExpressions = parsedExpression.$$inputs || (parsedExpression.$$inputs = collectExpressionInputs(parsedExpression.inputs, []));
                    if (1 === inputExpressions.length) {
                        var oldInputValue = expressionInputDirtyCheck;
                        return inputExpressions = inputExpressions[0], scope.$watch(function (scope) {
                            var newInputValue = inputExpressions(scope);
                            return expressionInputDirtyCheck(newInputValue, oldInputValue) || (lastResult = parsedExpression(scope), oldInputValue = newInputValue && getValueOf(newInputValue)), lastResult
                        }, listener, objectEquality)
                    }
                    for (var oldInputValueOfValues = [], i = 0, ii = inputExpressions.length; ii > i; i++)
                        oldInputValueOfValues[i] = expressionInputDirtyCheck;
                    return scope.$watch(function (scope) {
                        for (var changed = !1, i = 0, ii = inputExpressions.length; ii > i; i++) {
                            var newInputValue = inputExpressions[i](scope);
                            (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) && (oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue))
                        }
                        return changed && (lastResult = parsedExpression(scope)), lastResult
                    }, listener, objectEquality)
                }
                function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                    var unwatch, lastValue;
                    return unwatch = scope.$watch(function (scope) {
                        return parsedExpression(scope)
                    }, function (value, old, scope) {
                        lastValue = value, isFunction(listener) && listener.apply(this, arguments), isDefined(value) && scope.$$postDigest(function () {
                            isDefined(lastValue) && unwatch()
                        })
                    }, objectEquality)
                }
                function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                    function isAllDefined(value) {
                        var allDefined = !0;
                        return forEach(value, function (val) {
                            isDefined(val) || (allDefined = !1)
                        }), allDefined
                    }
                    var unwatch, lastValue;
                    return unwatch = scope.$watch(function (scope) {
                        return parsedExpression(scope)
                    }, function (value, old, scope) {
                        lastValue = value, isFunction(listener) && listener.call(this, value, old, scope), isAllDefined(value) && scope.$$postDigest(function () {
                            isAllDefined(lastValue) && unwatch()
                        })
                    }, objectEquality)
                }
                function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                    var unwatch;
                    return unwatch = scope.$watch(function (scope) {
                        return parsedExpression(scope)
                    }, function (value, old, scope) {
                        isFunction(listener) && listener.apply(this, arguments), unwatch()
                    }, objectEquality)
                }
                function addInterceptor(parsedExpression, interceptorFn) {
                    if (!interceptorFn)
                        return parsedExpression;
                    var watchDelegate = parsedExpression.$$watchDelegate, regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate, fn = regularWatch ? function (scope, locals) {
                        var value = parsedExpression(scope, locals);
                        return interceptorFn(value, scope, locals)
                    } : function (scope, locals) {
                        var value = parsedExpression(scope, locals), result = interceptorFn(value, scope, locals);
                        return isDefined(value) ? result : value
                    };
                    return parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate ? fn.$$watchDelegate = parsedExpression.$$watchDelegate : interceptorFn.$stateful || (fn.$$watchDelegate = inputsWatchDelegate, fn.inputs = [parsedExpression]), fn
                }
                var $parseOptions = {
                    csp: $sniffer.csp, expensiveChecks: !1}, $parseOptionsExpensive = {csp: $sniffer.csp, expensiveChecks: !0};
                return function (exp, interceptorFn, expensiveChecks) {
                    var parsedExpression, oneTime, cacheKey;
                    switch (typeof exp) {
                        case"string":
                            cacheKey = exp = exp.trim();
                            var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                            if (parsedExpression = cache[cacheKey], !parsedExpression) {
                                ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, exp = exp.substring(2));
                                var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions, lexer = new Lexer(parseOptions), parser = new Parser(lexer, $filter, parseOptions);
                                parsedExpression = parser.parse(exp), parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : oneTime ? (parsedExpression = wrapSharedExpression(parsedExpression), parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate) : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), cache[cacheKey] = parsedExpression
                            }
                            return addInterceptor(parsedExpression, interceptorFn);
                        case"function":
                            return addInterceptor(exp, interceptorFn);
                        default:
                            return addInterceptor(noop, interceptorFn)
                        }
                }
            }]
    }
    function $QProvider() {
        this.$get = ["$rootScope", "$exceptionHandler", function ($rootScope, $exceptionHandler) {
                return qFactory(function (callback) {
                    $rootScope.$evalAsync(callback)
                }, $exceptionHandler)
            }]
    }
    function $$QProvider() {
        this.$get = ["$browser", "$exceptionHandler", function ($browser, $exceptionHandler) {
                return qFactory(function (callback) {
                    $browser.defer(callback)
                }, $exceptionHandler)
            }]
    }
    function qFactory(nextTick, exceptionHandler) {
        function callOnce(self, resolveFn, rejectFn) {
            function wrap(fn) {
                return function (value) {
                    called || (called = !0, fn.call(self, value))
                }
            }
            var called = !1;
            return[wrap(resolveFn), wrap(rejectFn)]
        }
        function Promise() {
            this.$$state = {status: 0}
        }
        function simpleBind(context, fn) {
            return function (value) {
                fn.call(context, value)
            }
        }
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending, state.processScheduled = !1, state.pending = undefined;
            for (var i = 0, ii = pending.length; ii > i; ++i) {
                promise = pending[i][0], fn = pending[i][state.status];
                try {
                    isFunction(fn) ? promise.resolve(fn(state.value)) : 1 === state.status ? promise.resolve(state.value) : promise.reject(state.value)
                } catch (e) {
                    promise.reject(e), exceptionHandler(e)
                }
            }
        }
        function scheduleProcessQueue(state) {
            !state.processScheduled && state.pending && (state.processScheduled = !0, nextTick(function () {
                processQueue(state)
            }))
        }
        function Deferred() {
            this.promise = new Promise, this.resolve = simpleBind(this, this.resolve), this.reject = simpleBind(this, this.reject), this.notify = simpleBind(this, this.notify)
        }
        function all(promises) {
            var deferred = new Deferred, counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function (promise, key) {
                counter++, when(promise).then(function (value) {
                    results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results))
                }, function (reason) {
                    results.hasOwnProperty(key) || deferred.reject(reason)
                })
            }), 0 === counter && deferred.resolve(results), deferred.promise
        }
        var $qMinErr = minErr("$q", TypeError), defer = function () {
            return new Deferred
        };
        Promise.prototype = {then: function (onFulfilled, onRejected, progressBack) {
                var result = new Deferred;
                return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]), this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result.promise
            }, "catch": function (callback) {
                return this.then(null, callback)
            }, "finally": function (callback, progressBack) {
                return this.then(function (value) {
                    return handleCallback(value, !0, callback)
                }, function (error) {
                    return handleCallback(error, !1, callback)
                }, progressBack)
            }}, Deferred.prototype = {resolve: function (val) {
                this.promise.$$state.status || (val === this.promise ? this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : this.$$resolve(val))
            }, $$resolve: function (val) {
                var then, fns;
                fns = callOnce(this, this.$$resolve, this.$$reject);
                try {
                    (isObject(val) || isFunction(val)) && (then = val && val.then), isFunction(then) ? (this.promise.$$state.status = -1, then.call(val, fns[0], fns[1], this.notify)) : (this.promise.$$state.value = val, this.promise.$$state.status = 1, scheduleProcessQueue(this.promise.$$state))
                } catch (e) {
                    fns[1](e), exceptionHandler(e)
                }
            }, reject: function (reason) {
                this.promise.$$state.status || this.$$reject(reason)
            }, $$reject: function (reason) {
                this.promise.$$state.value = reason, this.promise.$$state.status = 2, scheduleProcessQueue(this.promise.$$state)
            }, notify: function (progress) {
                var callbacks = this.promise.$$state.pending;
                this.promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function () {
                    for (var callback, result, i = 0, ii = callbacks.length; ii > i; i++) {
                        result = callbacks[i][0], callback = callbacks[i][3];
                        try {
                            result.notify(isFunction(callback) ? callback(progress) : progress)
                        } catch (e) {
                            exceptionHandler(e)
                        }
                    }
                })
            }};
        var reject = function (reason) {
            var result = new Deferred;
            return result.reject(reason), result.promise
        }, makePromise = function (value, resolved) {
            var result = new Deferred;
            return resolved ? result.resolve(value) : result.reject(value), result.promise
        }, handleCallback = function (value, isResolved, callback) {
            var callbackOutput = null;
            try {
                isFunction(callback) && (callbackOutput = callback())
            } catch (e) {
                return makePromise(e, !1)
            }
            return isPromiseLike(callbackOutput) ? callbackOutput.then(function () {
                return makePromise(value, isResolved)
            }, function (error) {
                return makePromise(error, !1)
            }) : makePromise(value, isResolved)
        }, when = function (value, callback, errback, progressBack) {
            var result = new Deferred;
            return result.resolve(value), result.promise.then(callback, errback, progressBack)
        }, $Q = function Q(resolver) {
            function resolveFn(value) {
                deferred.resolve(value)
            }
            function rejectFn(reason) {
                deferred.reject(reason)
            }
            if (!isFunction(resolver))
                throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            if (!(this instanceof Q))
                return new Q(resolver);
            var deferred = new Deferred;
            return resolver(resolveFn, rejectFn), deferred.promise
        };
        return $Q.defer = defer, $Q.reject = reject, $Q.when = when, $Q.all = all, $Q
    }
    function $$RAFProvider() {
        this.$get = ["$window", "$timeout", function ($window, $timeout) {
                var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function (fn) {
                    var id = requestAnimationFrame(fn);
                    return function () {
                        cancelAnimationFrame(id)
                    }
                } : function (fn) {
                    var timer = $timeout(fn, 16.66, !1);
                    return function () {
                        $timeout.cancel(timer)
                    }
                };
                return raf.supported = rafSupported, raf
            }]
    }
    function $RootScopeProvider() {
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
        this.digestTtl = function (value) {
            return arguments.length && (TTL = value), TTL
        }, this.$get = ["$injector", "$exceptionHandler", "$parse", "$browser", function ($injector, $exceptionHandler, $parse, $browser) {
                function Scope() {
                    this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, this.$root = this, this.$$destroyed = !1, this.$$listeners = {}, this.$$listenerCount = {}, this.$$isolateBindings = null
                }
                function beginPhase(phase) {
                    if ($rootScope.$$phase)
                        throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                    $rootScope.$$phase = phase
                }
                function clearPhase() {
                    $rootScope.$$phase = null
                }
                function decrementListenerCount(current, count, name) {
                    do
                        current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name];
                    while (current = current.$parent)
                }
                function initWatchVal() {
                }
                function flushApplyAsync() {
                    for (; applyAsyncQueue.length; )
                        try {
                            applyAsyncQueue.shift()()
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                    applyAsyncId = null
                }
                function scheduleApplyAsync() {
                    null === applyAsyncId && (applyAsyncId = $browser.defer(function () {
                        $rootScope.$apply(flushApplyAsync)
                    }))
                }
                Scope.prototype = {constructor: Scope, $new: function (isolate, parent) {
                        function destroyChild() {
                            child.$$destroyed = !0
                        }
                        var child;
                        return parent = parent || this, isolate ? (child = new Scope, child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = function () {
                            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, this.$$listeners = {}, this.$$listenerCount = {}, this.$id = nextUid(), this.$$ChildScope = null
                        }, this.$$ChildScope.prototype = this), child = new this.$$ChildScope), child.$parent = parent, child.$$prevSibling = parent.$$childTail, parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, (isolate || parent != this) && child.$on("$destroy", destroyChild), child
                    }, $watch: function (watchExp, listener, objectEquality) {
                        var get = $parse(watchExp);
                        if (get.$$watchDelegate)
                            return get.$$watchDelegate(this, listener, objectEquality, get);
                        var scope = this, array = scope.$$watchers, watcher = {fn: listener, last: initWatchVal, get: get, exp: watchExp, eq: !!objectEquality};
                        return lastDirtyWatch = null, isFunction(listener) || (watcher.fn = noop), array || (array = scope.$$watchers = []), array.unshift(watcher), function () {
                            arrayRemove(array, watcher), lastDirtyWatch = null
                        }
                    }, $watchGroup: function (watchExpressions, listener) {
                        function watchGroupAction() {
                            changeReactionScheduled = !1, firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self)
                        }
                        var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                        if (!watchExpressions.length) {
                            var shouldCall = !0;
                            return self.$evalAsync(function () {
                                shouldCall && listener(newValues, newValues, self)
                            }), function () {
                                shouldCall = !1
                            }
                        }
                        return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function (value, oldValue, scope) {
                            newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope)
                        }) : (forEach(watchExpressions, function (expr, i) {
                            var unwatchFn = self.$watch(expr, function (value, oldValue) {
                                newValues[i] = value, oldValues[i] = oldValue, changeReactionScheduled || (changeReactionScheduled = !0, self.$evalAsync(watchGroupAction))
                            });
                            deregisterFns.push(unwatchFn)
                        }), function () {
                            for (; deregisterFns.length; )
                                deregisterFns.shift()()
                        })
                    }, $watchCollection: function (obj, listener) {
                        function $watchCollectionInterceptor(_value) {
                            newValue = _value;
                            var newLength, key, bothNaN, newItem, oldItem;
                            if (!isUndefined(newValue)) {
                                if (isObject(newValue))
                                    if (isArrayLike(newValue)) {
                                        oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, oldValue.length = oldLength = newLength);
                                        for (var i = 0; newLength > i; i++)
                                            oldItem = oldValue[i], newItem = newValue[i], bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, oldValue[i] = newItem)
                                    } else {
                                        oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), newLength = 0;
                                        for (key in newValue)
                                            newValue.hasOwnProperty(key) && (newLength++, newItem = newValue[key], oldItem = oldValue[key], key in oldValue ? (bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, oldValue[key] = newItem)) : (oldLength++, oldValue[key] = newItem, changeDetected++));
                                        if (oldLength > newLength) {
                                            changeDetected++;
                                            for (key in oldValue)
                                                newValue.hasOwnProperty(key) || (oldLength--, delete oldValue[key])
                                        }
                                    }
                                else
                                    oldValue !== newValue && (oldValue = newValue, changeDetected++);
                                return changeDetected
                            }
                        }
                        function $watchCollectionAction() {
                            if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), trackVeryOldValue)
                                if (isObject(newValue))
                                    if (isArrayLike(newValue)) {
                                        veryOldValue = new Array(newValue.length);
                                        for (var i = 0; i < newValue.length; i++)
                                            veryOldValue[i] = newValue[i]
                                    } else {
                                        veryOldValue = {};
                                        for (var key in newValue)
                                            hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key])
                                    }
                                else
                                    veryOldValue = newValue
                        }
                        $watchCollectionInterceptor.$stateful = !0;
                        var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                        return this.$watch(changeDetector, $watchCollectionAction)
                    }, $digest: function () {
                        var watch, value, last, watchers, length, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = this, watchLog = [];
                        beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), flushApplyAsync()), lastDirtyWatch = null;
                        do {
                            for (dirty = !1, current = target; asyncQueue.length; ) {
                                try {
                                    asyncTask = asyncQueue.shift(), asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals)
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                                lastDirtyWatch = null
                            }
                            traverseScopesLoop:do {
                                if (watchers = current.$$watchers)
                                    for (length = watchers.length; length--; )
                                        try {
                                            if (watch = watchers[length])
                                                if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                                    if (watch === lastDirtyWatch) {
                                                        dirty = !1;
                                                        break traverseScopesLoop
                                                    }
                                                } else
                                                    dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, watch.fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp, newVal: value, oldVal: last}))
                                        } catch (e) {
                                            $exceptionHandler(e)
                                        }
                                if (!(next = current.$$childHead || current !== target && current.$$nextSibling))
                                    for (; current !== target && !(next = current.$$nextSibling); )
                                        current = current.$parent
                            } while (current = next);
                            if ((dirty || asyncQueue.length) && !ttl--)
                                throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog)
                        } while (dirty || asyncQueue.length);
                        for (clearPhase(); postDigestQueue.length; )
                            try {
                                postDigestQueue.shift()()
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                    }, $destroy: function () {
                        if (!this.$$destroyed) {
                            var parent = this.$parent;
                            if (this.$broadcast("$destroy"), this.$$destroyed = !0, this !== $rootScope) {
                                for (var eventName in this.$$listenerCount)
                                    decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                                parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, this.$on = this.$watch = this.$watchGroup = function () {
                                    return noop
                                }, this.$$listeners = {}, this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null
                            }
                        }
                    }, $eval: function (expr, locals) {
                        return $parse(expr)(this, locals)
                    }, $evalAsync: function (expr, locals) {
                        $rootScope.$$phase || asyncQueue.length || $browser.defer(function () {
                            asyncQueue.length && $rootScope.$digest()
                        }), asyncQueue.push({scope: this, expression: expr, locals: locals})
                    }, $$postDigest: function (fn) {
                        postDigestQueue.push(fn)
                    }, $apply: function (expr) {
                        try {
                            return beginPhase("$apply"), this.$eval(expr)
                        } catch (e) {
                            $exceptionHandler(e)
                        } finally {
                            clearPhase();
                            try {
                                $rootScope.$digest()
                            } catch (e) {
                                throw $exceptionHandler(e), e
                            }
                        }
                    }, $applyAsync: function (expr) {
                        function $applyAsyncExpression() {
                            scope.$eval(expr)
                        }
                        var scope = this;
                        expr && applyAsyncQueue.push($applyAsyncExpression), scheduleApplyAsync()
                    }, $on: function (name, listener) {
                        var namedListeners = this.$$listeners[name];
                        namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                        var current = this;
                        do
                            current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++;
                        while (current = current.$parent);
                        var self = this;
                        return function () {
                            var indexOfListener = namedListeners.indexOf(listener);
                            -1 !== indexOfListener && (namedListeners[indexOfListener] = null, decrementListenerCount(self, 1, name))
                        }
                    }, $emit: function (name, args) {
                        var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {name: name, targetScope: scope, stopPropagation: function () {
                                stopPropagation = !0
                            }, preventDefault: function () {
                                event.defaultPrevented = !0
                            }, defaultPrevented: !1}, listenerArgs = concat([event], arguments, 1);
                        do {
                            for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, i = 0, length = namedListeners.length; length > i; i++)
                                if (namedListeners[i])
                                    try {
                                        namedListeners[i].apply(null, listenerArgs)
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                else
                                    namedListeners.splice(i, 1), i--, length--;
                            if (stopPropagation)
                                return event.currentScope = null, event;
                            scope = scope.$parent
                        } while (scope);
                        return event.currentScope = null, event
                    }, $broadcast: function (name, args) {
                        var target = this, current = target, next = target, event = {name: name, targetScope: target, preventDefault: function () {
                                event.defaultPrevented = !0
                            }, defaultPrevented: !1};
                        if (!target.$$listenerCount[name])
                            return event;
                        for (var listeners, i, length, listenerArgs = concat([event], arguments, 1); current = next; ) {
                            for (event.currentScope = current, listeners = current.$$listeners[name] || [], i = 0, length = listeners.length; length > i; i++)
                                if (listeners[i])
                                    try {
                                        listeners[i].apply(null, listenerArgs)
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                else
                                    listeners.splice(i, 1), i--, length--;
                            if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling))
                                for (; current !== target && !(next = current.$$nextSibling); )
                                    current = current.$parent
                        }
                        return event.currentScope = null, event
                    }};
                var $rootScope = new Scope, asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
                return $rootScope
            }]
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function (regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist
        }, this.imgSrcSanitizationWhitelist = function (regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist
        }, this.$get = function () {
            return function (uri, isImage) {
                var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                return normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal
            }
        }
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher)
            return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1)
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"), new RegExp("^" + matcher + "$")
        }
        if (isRegExp(matcher))
            return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects')
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function (matcher) {
            adjustedMatchers.push(adjustMatcher(matcher))
        }), adjustedMatchers
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ["self"], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function (value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist
        }, this.resourceUrlBlacklist = function (value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist
        }, this.$get = ["$injector", function ($injector) {
                function matchUrl(matcher, parsedUrl) {
                    return"self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href)
                }
                function isResourceUrlAllowedByPolicy(url) {
                    var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                    for (i = 0, n = resourceUrlWhitelist.length; n > i; i++)
                        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                            allowed = !0;
                            break
                        }
                    if (allowed)
                        for (i = 0, n = resourceUrlBlacklist.length; n > i; i++)
                            if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                                allowed = !1;
                                break
                            }
                    return allowed
                }
                function generateHolderType(Base) {
                    var holderType = function (trustedValue) {
                        this.$$unwrapTrustedValue = function () {
                            return trustedValue
                        }
                    };
                    return Base && (holderType.prototype = new Base), holderType.prototype.valueOf = function () {
                        return this.$$unwrapTrustedValue()
                    }, holderType.prototype.toString = function () {
                        return this.$$unwrapTrustedValue().toString()
                    }, holderType
                }
                function trustAs(type, trustedValue) {
                    var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                    if (!Constructor)
                        throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                    if (null === trustedValue || trustedValue === undefined || "" === trustedValue)
                        return trustedValue;
                    if ("string" != typeof trustedValue)
                        throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                    return new Constructor(trustedValue)
                }
                function valueOf(maybeTrusted) {
                    return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted
                }
                function getTrusted(type, maybeTrusted) {
                    if (null === maybeTrusted || maybeTrusted === undefined || "" === maybeTrusted)
                        return maybeTrusted;
                    var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                    if (constructor && maybeTrusted instanceof constructor)
                        return maybeTrusted.$$unwrapTrustedValue();
                    if (type === SCE_CONTEXTS.RESOURCE_URL) {
                        if (isResourceUrlAllowedByPolicy(maybeTrusted))
                            return maybeTrusted;
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString())
                    }
                    if (type === SCE_CONTEXTS.HTML)
                        return htmlSanitizer(maybeTrusted);
                    throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                }
                var htmlSanitizer = function (html) {
                    throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                };
                $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
                var trustedValueHolderBase = generateHolderType(), byType = {};
                return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), {trustAs: trustAs, getTrusted: getTrusted, valueOf: valueOf}
            }]
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function (value) {
            return arguments.length && (enabled = !!value), enabled
        }, this.$get = ["$parse", "$sceDelegate", function ($parse, $sceDelegate) {
                if (enabled && 8 > msie)
                    throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
                var sce = shallowCopy(SCE_CONTEXTS);
                sce.isEnabled = function () {
                    return enabled
                }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function (type, value) {
                    return value
                }, sce.valueOf = identity), sce.parseAs = function (type, expr) {
                    var parsed = $parse(expr);
                    return parsed.literal && parsed.constant ? parsed : $parse(expr, function (value) {
                        return sce.getTrusted(type, value)
                    })
                };
                var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
                return forEach(SCE_CONTEXTS, function (enumValue, name) {
                    var lName = lowercase(name);
                    sce[camelCase("parse_as_" + lName)] = function (expr) {
                        return parse(enumValue, expr)
                    }, sce[camelCase("get_trusted_" + lName)] = function (value) {
                        return getTrusted(enumValue, value)
                    }, sce[camelCase("trust_as_" + lName)] = function (value) {
                        return trustAs(enumValue, value)
                    }
                }), sce
            }]
    }
    function $SnifferProvider() {
        this.$get = ["$window", "$document", function ($window, $document) {
                var vendorPrefix, match, eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
                if (bodyStyle) {
                    for (var prop in bodyStyle)
                        if (match = vendorRegex.exec(prop)) {
                            vendorPrefix = match[0], vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                            break
                        }
                    vendorPrefix || (vendorPrefix = "WebkitOpacity"in bodyStyle && "webkit"), transitions = !!("transition"in bodyStyle || vendorPrefix + "Transition"in bodyStyle), animations = !!("animation"in bodyStyle || vendorPrefix + "Animation"in bodyStyle), !android || transitions && animations || (transitions = isString(document.body.style.webkitTransition), animations = isString(document.body.style.webkitAnimation))
                }
                return{history: !(!$window.history || !$window.history.pushState || 4 > android || boxee), hasEvent: function (event) {
                        if ("input" === event && 11 >= msie)
                            return!1;
                        if (isUndefined(eventSupport[event])) {
                            var divElm = document.createElement("div");
                            eventSupport[event] = "on" + event in divElm
                        }
                        return eventSupport[event]
                    }, csp: csp(), vendorPrefix: vendorPrefix, transitions: transitions, animations: animations, android: android}
            }]
    }
    function $TemplateRequestProvider() {
        this.$get = ["$templateCache", "$http", "$q", function ($templateCache, $http, $q) {
                function handleRequestFn(tpl, ignoreRequestError) {
                    function handleError(resp) {
                        if (!ignoreRequestError)
                            throw $compileMinErr("tpload", "Failed to load template: {0}", tpl);
                        return $q.reject(resp)
                    }
                    handleRequestFn.totalPendingRequests++;
                    var transformResponse = $http.defaults && $http.defaults.transformResponse;
                    isArray(transformResponse) ? transformResponse = transformResponse.filter(function (transformer) {
                        return transformer !== defaultHttpResponseTransform
                    }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null);
                    var httpOptions = {cache: $templateCache, transformResponse: transformResponse};
                    return $http.get(tpl, httpOptions)["finally"](function () {
                        handleRequestFn.totalPendingRequests--
                    }).then(function (response) {
                        return response.data
                    }, handleError)
                }
                return handleRequestFn.totalPendingRequests = 0, handleRequestFn
            }]
    }
    function $$TestabilityProvider() {
        this.$get = ["$rootScope", "$browser", "$location", function ($rootScope, $browser, $location) {
                var testability = {};
                return testability.findBindings = function (element, expression, opt_exactMatch) {
                    var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                    return forEach(bindings, function (binding) {
                        var dataBinding = angular.element(binding).data("$binding");
                        dataBinding && forEach(dataBinding, function (bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                matcher.test(bindingName) && matches.push(binding)
                            } else
                                -1 != bindingName.indexOf(expression) && matches.push(binding)
                        })
                    }), matches
                }, testability.findModels = function (element, expression, opt_exactMatch) {
                    for (var prefixes = ["ng-", "data-ng-", "ng\\:"], p = 0; p < prefixes.length; ++p) {
                        var attributeEquals = opt_exactMatch ? "=" : "*=", selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                        if (elements.length)
                            return elements
                    }
                }, testability.getLocation = function () {
                    return $location.url()
                }, testability.setLocation = function (url) {
                    url !== $location.url() && ($location.url(url), $rootScope.$digest())
                }, testability.whenStable = function (callback) {
                    $browser.notifyWhenNoOutstandingRequests(callback)
                }, testability
            }]
    }
    function $TimeoutProvider() {
        this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
                function timeout(fn, delay, invokeApply) {
                    var timeoutId, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                    return timeoutId = $browser.defer(function () {
                        try {
                            deferred.resolve(fn())
                        } catch (e) {
                            deferred.reject(e), $exceptionHandler(e)
                        } finally {
                            delete deferreds[promise.$$timeoutId]
                        }
                        skipApply || $rootScope.$apply()
                    }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise
                }
                var deferreds = {};
                return timeout.cancel = function (promise) {
                    return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) : !1
                }, timeout
            }]
    }
    function urlResolve(url) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), urlParsingNode.setAttribute("href", href), {href: urlParsingNode.href, protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "", host: urlParsingNode.host, search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "", hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "", hostname: urlParsingNode.hostname, port: urlParsingNode.port, pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname}
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host
    }
    function $WindowProvider() {
        this.$get = valueFn(window)
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function (filter, key) {
                    filters[key] = register(key, filter)
                }), filters
            }
            return $provide.factory(name + suffix, factory)
        }
        var suffix = "Filter";
        this.register = register, this.$get = ["$injector", function ($injector) {
                return function (name) {
                    return $injector.get(name + suffix)
                }
            }], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter)
    }
    function filterFilter() {
        return function (array, expression, comparator) {
            if (!isArray(array))
                return array;
            var predicateFn, matchAgainstAnyProp;
            switch (typeof expression) {
                case"function":
                    predicateFn = expression;
                    break;
                case"boolean":
                case"number":
                case"string":
                    matchAgainstAnyProp = !0;
                case"object":
                    predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                    break;
                default:
                    return array
            }
            return array.filter(predicateFn)
        }
    }
    function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var predicateFn, shouldMatchPrimitives = isObject(expression) && "$"in expression;
        return comparator === !0 ? comparator = equals : isFunction(comparator) || (comparator = function (actual, expected) {
            return isObject(actual) || isObject(expected) ? !1 : (actual = lowercase("" + actual), expected = lowercase("" + expected), -1 !== actual.indexOf(expected))
        }), predicateFn = function (item) {
            return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression.$, comparator, !1) : deepCompare(item, expression, comparator, matchAgainstAnyProp)
        }
    }
    function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = typeof actual, expectedType = typeof expected;
        if ("string" === expectedType && "!" === expected.charAt(0))
            return!deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        if (isArray(actual))
            return actual.some(function (item) {
                return deepCompare(item, expected, comparator, matchAgainstAnyProp)
            });
        switch (actualType) {
            case"object":
                var key;
                if (matchAgainstAnyProp) {
                    for (key in actual)
                        if ("$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, !0))
                            return!0;
                    return dontMatchWholeObject ? !1 : deepCompare(actual, expected, comparator, !1)
                }
                if ("object" === expectedType) {
                    for (key in expected) {
                        var expectedVal = expected[key];
                        if (!isFunction(expectedVal)) {
                            var matchAnyProperty = "$" === key, actualVal = matchAnyProperty ? actual : actual[key];
                            if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty))
                                return!1
                        }
                    }
                    return!0
                }
                return comparator(actual, expected);
            case"function":
                return!1;
            default:
                return comparator(actual, expected)
            }
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function (amount, currencySymbol, fractionSize) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac), null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol)
        }
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function (number, fractionSize) {
            return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize)
        }
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!isFinite(number) || isObject(number))
            return"";
        var isNegative = 0 > number;
        number = Math.abs(number);
        var numStr = number + "", formatedText = "", parts = [], hasExponent = !1;
        if (-1 !== numStr.indexOf("e")) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            match && "-" == match[2] && match[3] > fractionSize + 1 ? number = 0 : (formatedText = numStr,
                    hasExponent = !0)
        }
        if (hasExponent)
            fractionSize > 0 && 1 > number && (formatedText = number.toFixed(fractionSize), number = parseFloat(formatedText));
        else {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac)), number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP), whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group)
                for (pos = whole.length - lgroup, i = 0; pos > i; i++)
                    (pos - i) % group === 0 && 0 !== i && (formatedText += groupSep), formatedText += whole.charAt(i);
            for (i = pos; i < whole.length; i++)
                (whole.length - i) % lgroup === 0 && 0 !== i && (formatedText += groupSep), formatedText += whole.charAt(i);
            for (; fraction.length < fractionSize; )
                fraction += "0";
            fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize))
        }
        return 0 === number && (isNegative = !1), parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf), parts.join("")
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        for (0 > num && (neg = "-", num = - num), num = "" + num; num.length < digits; )
            num = "0" + num;
        return trim && (num = num.substr(num.length - digits)), neg + num
    }
    function dateGetter(name, size, offset, trim) {
        return offset = offset || 0, function (date) {
            var value = date["get" + name]();
            return(offset > 0 || value > -offset) && (value += offset), 0 === value && -12 == offset && (value = 12), padNumber(value, size, trim)
        }
    }
    function dateStrGetter(name, shortForm) {
        return function (date, formats) {
            var value = date["get" + name](), get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value]
        }
    }
    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset(), paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (4 >= dayOfWeekOnFirst ? 5 : 12) - dayOfWeekOnFirst)
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()))
    }
    function weekGetter(size) {
        return function (date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date), diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size)
        }
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = int(match[9] + match[10]), tzMin = int(match[9] + match[11])), dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour, m = int(match[5] || 0) - tzMin, s = int(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date
            }
            return string
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function (date, format, timezone) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, isString(date) && (date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date)), isNumber(date) && (date = new Date(date)), !isDate(date))
                return date;
            for (; format; )
                match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), format = parts.pop()) : (parts.push(format), format = null);
            return timezone && "UTC" === timezone && (date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + date.getTimezoneOffset())), forEach(parts, function (value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
            }), text
        }
    }
    function jsonFilter() {
        return function (object, spacing) {
            return isUndefined(spacing) && (spacing = 2), toJson(object, spacing)
        }
    }
    function limitToFilter() {
        return function (input, limit) {
            return isNumber(input) && (input = input.toString()), isArray(input) || isString(input) ? (limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : int(limit), limit ? limit > 0 ? input.slice(0, limit) : input.slice(limit) : isString(input) ? "" : []) : input
        }
    }
    function orderByFilter($parse) {
        return function (array, sortPredicate, reverseOrder) {
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (0 !== comp)
                        return comp
                }
                return 0
            }
            function reverseComparator(comp, descending) {
                return descending ? function (a, b) {
                    return comp(b, a)
                } : comp
            }
            function isPrimitive(value) {
                switch (typeof value) {
                    case"number":
                    case"boolean":
                    case"string":
                        return!0;
                    default:
                        return!1
                    }
            }
            function objectToString(value) {
                return null === value ? "null" : "function" == typeof value.valueOf && (value = value.valueOf(), isPrimitive(value)) ? value : "function" == typeof value.toString && (value = value.toString(), isPrimitive(value)) ? value : ""
            }
            function compare(v1, v2) {
                var t1 = typeof v1, t2 = typeof v2;
                return t1 === t2 && "object" === t1 && (v1 = objectToString(v1), v2 = objectToString(v2)), t1 === t2 ? ("string" === t1 && (v1 = v1.toLowerCase(), v2 = v2.toLowerCase()), v1 === v2 ? 0 : v2 > v1 ? -1 : 1) : t2 > t1 ? -1 : 1
            }
            return isArrayLike(array) ? (sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate], 0 === sortPredicate.length && (sortPredicate = ["+"]), sortPredicate = sortPredicate.map(function (predicate) {
                var descending = !1, get = predicate || identity;
                if (isString(predicate)) {
                    if (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0), predicate = predicate.substring(1)), "" === predicate)
                        return reverseComparator(compare, descending);
                    if (get = $parse(predicate), get.constant) {
                        var key = get();
                        return reverseComparator(function (a, b) {
                            return compare(a[key], b[key])
                        }, descending)
                    }
                }
                return reverseComparator(function (a, b) {
                    return compare(get(a), get(b))
                }, descending)
            }), slice.call(array).sort(reverseComparator(comparator, reverseOrder))) : array
        }
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {link: directive}), directive.restrict = directive.restrict || "AC", valueFn(directive)
    }
    function nullFormRenameControl(control, name) {
        control.$name = name
    }
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this, controls = [], parentForm = form.$$parentForm = element.parent().controller("form") || nullFormCtrl;
        form.$error = {}, form.$$success = {}, form.$pending = undefined, form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope), form.$dirty = !1, form.$pristine = !0, form.$valid = !0, form.$invalid = !1, form.$submitted = !1, parentForm.$addControl(form), form.$rollbackViewValue = function () {
            forEach(controls, function (control) {
                control.$rollbackViewValue()
            })
        }, form.$commitViewValue = function () {
            forEach(controls, function (control) {
                control.$commitViewValue()
            })
        }, form.$addControl = function (control) {
            assertNotHasOwnProperty(control.$name, "input"), controls.push(control), control.$name && (form[control.$name] = control)
        }, form.$$renameControl = function (control, newName) {
            var oldName = control.$name;
            form[oldName] === control && delete form[oldName], form[newName] = control, control.$name = newName
        }, form.$removeControl = function (control) {
            control.$name && form[control.$name] === control && delete form[control.$name], forEach(form.$pending, function (value, name) {
                form.$setValidity(name, null, control)
            }), forEach(form.$error, function (value, name) {
                form.$setValidity(name, null, control)
            }), forEach(form.$$success, function (value, name) {
                form.$setValidity(name, null, control)
            }), arrayRemove(controls, control)
        }, addSetValidityMethod({ctrl: this, $element: element, set: function (object, property, controller) {
                var list = object[property];
                if (list) {
                    var index = list.indexOf(controller);
                    -1 === index && list.push(controller)
                } else
                    object[property] = [controller]
            }, unset: function (object, property, controller) {
                var list = object[property];
                list && (arrayRemove(list, controller), 0 === list.length && delete object[property])
            }, parentForm: parentForm, $animate: $animate}), form.$setDirty = function () {
            $animate.removeClass(element, PRISTINE_CLASS), $animate.addClass(element, DIRTY_CLASS), form.$dirty = !0, form.$pristine = !1, parentForm.$setDirty()
        }, form.$setPristine = function () {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS), form.$dirty = !1, form.$pristine = !0, form.$submitted = !1, forEach(controls, function (control) {
                control.$setPristine()
            })
        }, form.$setUntouched = function () {
            forEach(controls, function (control) {
                control.$setUntouched()
            })
        }, form.$setSubmitted = function () {
            $animate.addClass(element, SUBMITTED_CLASS), form.$submitted = !0, parentForm.$setSubmitted()
        }
    }
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function (value) {
            return ctrl.$isEmpty(value) ? value : value.toString()
        })
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl)
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function (data) {
                composing = !0
            }), element.on("compositionend", function () {
                composing = !1, listener()
            })
        }
        var listener = function (ev) {
            if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                var value = element.val(), event = ev && ev.type;
                "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event)
            }
        };
        if ($sniffer.hasEvent("input"))
            element.on("input", listener);
        else {
            var timeout, deferListener = function (ev, input, origValue) {
                timeout || (timeout = $browser.defer(function () {
                    timeout = null, input && input.value === origValue || listener(ev)
                }))
            };
            element.on("keydown", function (event) {
                var key = event.keyCode;
                91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener(event, this, this.value)
            }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener)
        }
        element.on("change", listener), ctrl.$render = function () {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue)
        }
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek))
            return isoWeek;
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds)
            }
        }
        return NaN
    }
    function createDateParser(regexp, mapping) {
        return function (iso, date) {
            var parts, map;
            if (isDate(iso))
                return iso;
            if (isString(iso)) {
                if ('"' == iso.charAt(0) && '"' == iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), ISO_DATE_REGEXP.test(iso))
                    return new Date(iso);
                if (regexp.lastIndex = 0, parts = regexp.exec(iso))
                    return parts.shift(), map = date ? {yyyy: date.getFullYear(), MM: date.getMonth() + 1, dd: date.getDate(), HH: date.getHours(), mm: date.getMinutes(), ss: date.getSeconds(), sss: date.getMilliseconds() / 1e3} : {yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0}, forEach(parts, function (part, index) {
                        index < mapping.length && (map[mapping[index]] = +part)
                    }), new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0)
            }
            return NaN
        }
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function (scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime())
            }
            function parseObservedDateValue(val) {
                return isDefined(val) ? isDate(val) ? val : parseDate(val) : undefined
            }
            badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var previousDate, timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            if (ctrl.$$parserName = type, ctrl.$parsers.push(function (value) {
                if (ctrl.$isEmpty(value))
                    return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    return"UTC" === timezone && parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset()), parsedDate
                }
                return undefined
            }), ctrl.$formatters.push(function (value) {
                if (value && !isDate(value))
                    throw $ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                if (isValidDate(value)) {
                    if (previousDate = value, previousDate && "UTC" === timezone) {
                        var timezoneOffset = 6e4 * previousDate.getTimezoneOffset();
                        previousDate = new Date(previousDate.getTime() + timezoneOffset)
                    }
                    return $filter("date")(value, format, timezone)
                }
                return previousDate = null, ""
            }), isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function (value) {
                    return!isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal
                }, attr.$observe("min", function (val) {
                    minVal = parseObservedDateValue(val), ctrl.$validate()
                })
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function (value) {
                    return!isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal
                }, attr.$observe("max", function (val) {
                    maxVal = parseObservedDateValue(val), ctrl.$validate()
                })
            }
        }
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0], nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        nativeValidation && ctrl.$parsers.push(function (value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value
        })
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        if (badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser), ctrl.$$parserName = "number", ctrl.$parsers.push(function (value) {
            return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : undefined
        }), ctrl.$formatters.push(function (value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value))
                    throw $ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                value = value.toString()
            }
            return value
        }), attr.min || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function (value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal
            }, attr.$observe("min", function (val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)), minVal = isNumber(val) && !isNaN(val) ? val : undefined, ctrl.$validate()
            })
        }
        if (attr.max || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function (value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || maxVal >= value
            }, attr.$observe("max", function (val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)), maxVal = isNumber(val) && !isNaN(val) ? val : undefined, ctrl.$validate()
            })
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), ctrl.$$parserName = "url", ctrl.$validators.url = function (modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value)
        }
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), ctrl.$$parserName = "email", ctrl.$validators.email = function (modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value)
        }
    }
    function radioInputType(scope, element, attr, ctrl) {
        isUndefined(attr.name) && element.attr("name", nextUid());
        var listener = function (ev) {
            element[0].checked && ctrl.$setViewValue(attr.value, ev && ev.type)
        };
        element.on("click", listener), ctrl.$render = function () {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue
        }, attr.$observe("value", ctrl.$render)
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            if (parseFn = $parse(expression), !parseFn.constant)
                throw minErr("ngModel")("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
            return parseFn(context)
        }
        return fallback
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1), listener = function (ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type)
        };
        element.on("click", listener), ctrl.$render = function () {
            element[0].checked = ctrl.$viewValue
        }, ctrl.$isEmpty = function (value) {
            return value === !1
        }, ctrl.$formatters.push(function (value) {
            return equals(value, trueValue)
        }), ctrl.$parsers.push(function (value) {
            return value ? trueValue : falseValue
        })
    }
    function classDirective(name, selector) {
        return name = "ngClass" + name, ["$animate", function ($animate) {
                function arrayDifference(tokens1, tokens2) {
                    var values = [];
                    outer:for (var i = 0; i < tokens1.length; i++) {
                        for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                            if (token == tokens2[j])
                                continue outer;
                        values.push(token)
                    }
                    return values
                }
                function arrayClasses(classVal) {
                    if (isArray(classVal))
                        return classVal;
                    if (isString(classVal))
                        return classVal.split(" ");
                    if (isObject(classVal)) {
                        var classes = [];
                        return forEach(classVal, function (v, k) {
                            v && (classes = classes.concat(k.split(" ")))
                        }), classes
                    }
                    return classVal
                }
                return{restrict: "AC", link: function (scope, element, attr) {
                        function addClasses(classes) {
                            var newClasses = digestClassCounts(classes, 1);
                            attr.$addClass(newClasses)
                        }
                        function removeClasses(classes) {
                            var newClasses = digestClassCounts(classes, -1);
                            attr.$removeClass(newClasses)
                        }
                        function digestClassCounts(classes, count) {
                            var classCounts = element.data("$classCounts") || {}, classesToUpdate = [];
                            return forEach(classes, function (className) {
                                (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, classCounts[className] === +(count > 0) && classesToUpdate.push(className))
                            }), element.data("$classCounts", classCounts), classesToUpdate.join(" ")
                        }
                        function updateClasses(oldClasses, newClasses) {
                            var toAdd = arrayDifference(newClasses, oldClasses), toRemove = arrayDifference(oldClasses, newClasses);
                            toAdd = digestClassCounts(toAdd, 1), toRemove = digestClassCounts(toRemove, -1), toAdd && toAdd.length && $animate.addClass(element, toAdd), toRemove && toRemove.length && $animate.removeClass(element, toRemove)
                        }
                        function ngClassWatchAction(newVal) {
                            if (selector === !0 || scope.$index % 2 === selector) {
                                var newClasses = arrayClasses(newVal || []);
                                if (oldVal) {
                                    if (!equals(newVal, oldVal)) {
                                        var oldClasses = arrayClasses(oldVal);
                                        updateClasses(oldClasses, newClasses)
                                    }
                                } else
                                    addClasses(newClasses)
                            }
                            oldVal = shallowCopy(newVal)
                        }
                        var oldVal;
                        scope.$watch(attr[name], ngClassWatchAction, !0), attr.$observe("class", function (value) {
                            ngClassWatchAction(scope.$eval(attr[name]))
                        }), "ngClass" !== name && scope.$watch("$index", function ($index, old$index) {
                            var mod = 1 & $index;
                            if (mod !== (1 & old$index)) {
                                var classes = arrayClasses(scope.$eval(attr[name]));
                                mod === selector ? addClasses(classes) : removeClasses(classes)
                            }
                        })
                    }}
            }]
    }
    function addSetValidityMethod(context) {
        function setValidity(validationErrorKey, state, controller) {
            state === undefined ? createAndSet("$pending", validationErrorKey, controller) : unsetAndCleanup("$pending", validationErrorKey, controller), isBoolean(state) ? state ? (unset(ctrl.$error, validationErrorKey, controller), set(ctrl.$$success, validationErrorKey, controller)) : (set(ctrl.$error, validationErrorKey, controller), unset(ctrl.$$success, validationErrorKey, controller)) : (unset(ctrl.$error, validationErrorKey, controller), unset(ctrl.$$success, validationErrorKey, controller)), ctrl.$pending ? (cachedToggleClass(PENDING_CLASS, !0), ctrl.$valid = ctrl.$invalid = undefined, toggleValidationCss("", null)) : (cachedToggleClass(PENDING_CLASS, !1), ctrl.$valid = isObjectEmpty(ctrl.$error), ctrl.$invalid = !ctrl.$valid, toggleValidationCss("", ctrl.$valid));
            var combinedState;
            combinedState = ctrl.$pending && ctrl.$pending[validationErrorKey] ? undefined : ctrl.$error[validationErrorKey] ? !1 : ctrl.$$success[validationErrorKey] ? !0 : null, toggleValidationCss(validationErrorKey, combinedState), parentForm.$setValidity(validationErrorKey, combinedState, ctrl)
        }
        function createAndSet(name, value, controller) {
            ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller)
        }
        function unsetAndCleanup(name, value, controller) {
            ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = undefined)
        }
        function cachedToggleClass(className, switchValue) {
            switchValue && !classCache[className] ? ($animate.addClass($element, className), classCache[className] = !0) : !switchValue && classCache[className] && ($animate.removeClass($element, className), classCache[className] = !1)
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === !0), cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === !1)
        }
        var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, parentForm = context.parentForm, $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS)), ctrl.$setValidity = setValidity
    }
    function isObjectEmpty(obj) {
        if (obj)
            for (var prop in obj)
                return!1;
        return!0
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", lowercase = function (string) {
        return isString(string) ? string.toLowerCase() : string
    }, hasOwnProperty = Object.prototype.hasOwnProperty, uppercase = function (string) {
        return isString(string) ? string.toUpperCase() : string
    }, manualLowercase = function (s) {
        return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
            return String.fromCharCode(32 | ch.charCodeAt(0))
        }) : s
    }, manualUppercase = function (s) {
        return isString(s) ? s.replace(/[a-z]/g, function (ch) {
            return String.fromCharCode(-33 & ch.charCodeAt(0))
        }) : s
    };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
    msie = document.documentMode, noop.$inject = [], identity.$inject = [];
    var skipDestroyOnNextJQueryCleanData, isArray = Array.isArray, trim = function (value) {
        return isString(value) ? value.trim() : value
    }, escapeForRegexp = function (s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
    }, csp = function () {
        if (isDefined(csp.isActive_))
            return csp.isActive_;
        var active = !(!document.querySelector("[ng-csp]") && !document.querySelector("[data-ng-csp]"));
        if (!active)
            try {
                new Function("")
            } catch (e) {
                active = !0
            }
        return csp.isActive_ = active
    }, ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"], SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {full: "1.3.10", major: 1, minor: 3, dot: 10, codeName: "heliotropic-sundial"};
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function (element, type, fn) {
        element.addEventListener(type, fn, !1)
    }, removeEventListenerFn = function (element, type, fn) {
        element.removeEventListener(type, fn, !1)
    };
    JQLite._data = function (node) {
        return this.cache[node[this.expando]] || {}
    };
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g, MOZ_HACK_REGEXP = /^moz([A-Z])/, MOUSE_EVENT_MAP = {mouseleave: "mouseout", mouseenter: "mouseover"}, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, wrapMap = {option: [1, '<select multiple="multiple">', "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""]};
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td;
    var JQLitePrototype = JQLite.prototype = {ready: function (fn) {
            function trigger() {
                fired || (fired = !0, fn())
            }
            var fired = !1;
            "complete" === document.readyState ? setTimeout(trigger) : (this.on("DOMContentLoaded", trigger), JQLite(window).on("load", trigger))
        }, toString: function () {
            var value = [];
            return forEach(this, function (e) {
                value.push("" + e)
            }), "[" + value.join(", ") + "]"
        }, eq: function (index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index])
        }, length: 0, push: push, sort: [].sort, splice: [].splice}, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function (value) {
        BOOLEAN_ATTR[lowercase(value)] = value
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function (value) {
        BOOLEAN_ELEMENTS[value] = !0
    });
    var ALIASED_ATTR = {ngMinlength: "minlength", ngMaxlength: "maxlength", ngMin: "min", ngMax: "max", ngPattern: "pattern"};
    forEach({data: jqLiteData, removeData: jqLiteRemoveData}, function (fn, name) {
        JQLite[name] = fn
    }), forEach({data: jqLiteData, inheritedData: jqLiteInheritedData, scope: function (element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, ["$isolateScope", "$scope"])
        }, isolateScope: function (element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate")
        }, controller: jqLiteController, injector: function (element) {
            return jqLiteInheritedData(element, "$injector")
        }, removeAttr: function (element, name) {
            element.removeAttribute(name)
        }, hasClass: jqLiteHasClass, css: function (element, name, value) {
            return name = camelCase(name), isDefined(value) ? void(element.style[name] = value) : element.style[name]
        }, attr: function (element, name, value) {
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (!isDefined(value))
                    return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) : (element[name] = !1, element.removeAttribute(lowercasedName))
            } else if (isDefined(value))
                element.setAttribute(name, value);
            else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return null === ret ? undefined : ret
            }
        }, prop: function (element, name, value) {
            return isDefined(value) ? void(element[name] = value) : element[name]
        }, text: function () {
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : ""
                }
                element.textContent = value
            }
            return getText.$dv = "", getText
        }(), val: function (element, value) {
            if (isUndefined(value)) {
                if (element.multiple && "select" === nodeName_(element)) {
                    var result = [];
                    return forEach(element.options, function (option) {
                        option.selected && result.push(option.value || option.text)
                    }), 0 === result.length ? null : result
                }
                return element.value
            }
            element.value = value
        }, html: function (element, value) {
            return isUndefined(value) ? element.innerHTML : (jqLiteDealoc(element, !0), void(element.innerHTML = value))
        }, empty: jqLiteEmpty}, function (fn, name) {
        JQLite.prototype[name] = function (arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && (2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; nodeCount > i; i++)
                        if (fn === jqLiteData)
                            fn(this[i], arg1);
                        else
                            for (key in arg1)
                                fn(this[i], key, arg1[key]);
                    return this
                }
                for (var value = fn.$dv, jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount, j = 0; jj > j; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue
                }
                return value
            }
            for (i = 0; nodeCount > i; i++)
                fn(this[i], arg1, arg2);
            return this
        }
    }), forEach({removeData: jqLiteRemoveData, on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported))
                throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (jqLiteAcceptsData(element)) {
                var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                handle || (handle = expandoStore.handle = createEventHandler(element, events));
                for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [type], i = types.length; i--; ) {
                    type = types[i];
                    var eventFns = events[type];
                    eventFns || (events[type] = [], "mouseenter" === type || "mouseleave" === type ? jqLiteOn(element, MOUSE_EVENT_MAP[type], function (event) {
                        var target = this, related = event.relatedTarget;
                        (!related || related !== target && !target.contains(related)) && handle(event, type)
                    }) : "$destroy" !== type && addEventListenerFn(element, type, handle), eventFns = events[type]), eventFns.push(fn)
                }
            }
        }, off: jqLiteOff, one: function (element, type, fn) {
            element = jqLite(element), element.on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn)
            }), element.on(type, fn)
        }, replaceWith: function (element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function (node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), index = node
            })
        }, children: function (element) {
            var children = [];
            return forEach(element.childNodes, function (element) {
                element.nodeType === NODE_TYPE_ELEMENT && children.push(element)
            }), children
        }, contents: function (element) {
            return element.contentDocument || element.childNodes || []
        }, append: function (element, node) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                node = new JQLite(node);
                for (var i = 0, ii = node.length; ii > i; i++) {
                    var child = node[i];
                    element.appendChild(child)
                }
            }
        }, prepend: function (element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function (child) {
                    element.insertBefore(child, index)
                })
            }
        }, wrap: function (element, wrapNode) {
            wrapNode = jqLite(wrapNode).eq(0).clone()[0];
            var parent = element.parentNode;
            parent && parent.replaceChild(wrapNode, element), wrapNode.appendChild(element)
        }, remove: jqLiteRemove, detach: function (element) {
            jqLiteRemove(element, !0)
        }, after: function (element, newElement) {
            var index = element, parent = element.parentNode;
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; ii > i; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling), index = node
            }
        }, addClass: jqLiteAddClass, removeClass: jqLiteRemoveClass, toggleClass: function (element, selector, condition) {
            selector && forEach(selector.split(" "), function (className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className)
            })
        }, parent: function (element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null
        }, next: function (element) {
            return element.nextElementSibling
        }, find: function (element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : []
        }, clone: jqLiteClone, triggerHandler: function (element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
            eventFns && (dummyEvent = {preventDefault: function () {
                    this.defaultPrevented = !0
                }, isDefaultPrevented: function () {
                    return this.defaultPrevented === !0
                }, stopImmediatePropagation: function () {
                    this.immediatePropagationStopped = !0
                }, isImmediatePropagationStopped: function () {
                    return this.immediatePropagationStopped === !0
                }, stopPropagation: noop, type: eventName, target: element}, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent], forEach(eventFnsCopy, function (fn) {
                dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs)
            }))
        }}, function (fn, name) {
        JQLite.prototype[name] = function (arg1, arg2, arg3) {
            for (var value, i = 0, ii = this.length; ii > i; i++)
                isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this
        }, JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off
    }), HashMap.prototype = {put: function (key, value) {
            this[hashKey(key, this.nextUid)] = value
        }, get: function (key) {
            return this[hashKey(key, this.nextUid)]
        }, remove: function (key) {
            var value = this[key = hashKey(key, this.nextUid)];
            return delete this[key], value
        }};
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
    createInjector.$$annotate = annotate;
    var $animateMinErr = minErr("$animate"), $AnimateProvider = ["$provide", function ($provide) {
            this.$$selectors = {}, this.register = function (name, factory) {
                var key = name + "-animation";
                if (name && "." != name.charAt(0))
                    throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                this.$$selectors[name.substr(1)] = key, $provide.factory(key, factory)
            }, this.classNameFilter = function (expression) {
                return 1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null),
                        this.$$classNameFilter
            }, this.$get = ["$$q", "$$asyncCallback", "$rootScope", function ($$q, $$asyncCallback, $rootScope) {
                    function runAnimationPostDigest(fn) {
                        var cancelFn, defer = $$q.defer();
                        return defer.promise.$$cancelFn = function () {
                            cancelFn && cancelFn()
                        }, $rootScope.$$postDigest(function () {
                            cancelFn = fn(function () {
                                defer.resolve()
                            })
                        }), defer.promise
                    }
                    function resolveElementClasses(element, classes) {
                        var toAdd = [], toRemove = [], hasClasses = createMap();
                        return forEach((element.attr("class") || "").split(/\s+/), function (className) {
                            hasClasses[className] = !0
                        }), forEach(classes, function (status, className) {
                            var hasClass = hasClasses[className];
                            status === !1 && hasClass ? toRemove.push(className) : status !== !0 || hasClass || toAdd.push(className)
                        }), toAdd.length + toRemove.length > 0 && [toAdd.length ? toAdd : null, toRemove.length ? toRemove : null]
                    }
                    function cachedClassManipulation(cache, classes, op) {
                        for (var i = 0, ii = classes.length; ii > i; ++i) {
                            var className = classes[i];
                            cache[className] = op
                        }
                    }
                    function asyncPromise() {
                        return currentDefer || (currentDefer = $$q.defer(), $$asyncCallback(function () {
                            currentDefer.resolve(), currentDefer = null
                        })), currentDefer.promise
                    }
                    function applyStyles(element, options) {
                        if (angular.isObject(options)) {
                            var styles = extend(options.from || {}, options.to || {});
                            element.css(styles)
                        }
                    }
                    var currentDefer;
                    return{animate: function (element, from, to) {
                            return applyStyles(element, {from: from, to: to}), asyncPromise()
                        }, enter: function (element, parent, after, options) {
                            return applyStyles(element, options), after ? after.after(element) : parent.prepend(element), asyncPromise()
                        }, leave: function (element, options) {
                            return element.remove(), asyncPromise()
                        }, move: function (element, parent, after, options) {
                            return this.enter(element, parent, after, options)
                        }, addClass: function (element, className, options) {
                            return this.setClass(element, className, [], options)
                        }, $$addClassImmediately: function (element, className, options) {
                            return element = jqLite(element), className = isString(className) ? className : isArray(className) ? className.join(" ") : "", forEach(element, function (element) {
                                jqLiteAddClass(element, className)
                            }), applyStyles(element, options), asyncPromise()
                        }, removeClass: function (element, className, options) {
                            return this.setClass(element, [], className, options)
                        }, $$removeClassImmediately: function (element, className, options) {
                            return element = jqLite(element), className = isString(className) ? className : isArray(className) ? className.join(" ") : "", forEach(element, function (element) {
                                jqLiteRemoveClass(element, className)
                            }), applyStyles(element, options), asyncPromise()
                        }, setClass: function (element, add, remove, options) {
                            var self = this, STORAGE_KEY = "$$animateClasses", createdCache = !1;
                            element = jqLite(element);
                            var cache = element.data(STORAGE_KEY);
                            cache ? options && cache.options && (cache.options = angular.extend(cache.options || {}, options)) : (cache = {classes: {}, options: options}, createdCache = !0);
                            var classes = cache.classes;
                            return add = isArray(add) ? add : add.split(" "), remove = isArray(remove) ? remove : remove.split(" "), cachedClassManipulation(classes, add, !0), cachedClassManipulation(classes, remove, !1), createdCache && (cache.promise = runAnimationPostDigest(function (done) {
                                var cache = element.data(STORAGE_KEY);
                                if (element.removeData(STORAGE_KEY), cache) {
                                    var classes = resolveElementClasses(element, cache.classes);
                                    classes && self.$$setClassImmediately(element, classes[0], classes[1], cache.options)
                                }
                                done()
                            }), element.data(STORAGE_KEY, cache)), cache.promise
                        }, $$setClassImmediately: function (element, add, remove, options) {
                            return add && this.$$addClassImmediately(element, add), remove && this.$$removeClassImmediately(element, remove), applyStyles(element, options), asyncPromise()
                        }, enabled: noop, cancel: noop}
                }]
        }], $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"];
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {"Content-Type": APPLICATION_JSON + ";charset=utf-8"}, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {"[": /]$/, "{": /}$/}, JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/, $interpolateMinErr = minErr("$interpolate"), PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {http: 80, https: 443, ftp: 21}, $locationMinErr = minErr("$location"), locationPrototype = {$$html5: !1, $$replace: !1, absUrl: locationGetter("$$absUrl"), url: function (url) {
            if (isUndefined(url))
                return this.$$url;
            var match = PATH_MATCH.exec(url);
            return(match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), this.hash(match[5] || ""), this
        }, protocol: locationGetter("$$protocol"), host: locationGetter("$$host"), port: locationGetter("$$port"), path: locationGetterSetter("$$path", function (path) {
            return path = null !== path ? path.toString() : "", "/" == path.charAt(0) ? path : "/" + path
        }), search: function (search, paramValue) {
            switch (arguments.length) {
                case 0:
                    return this.$$search;
                case 1:
                    if (isString(search) || isNumber(search))
                        search = search.toString(), this.$$search = parseKeyValue(search);
                    else {
                        if (!isObject(search))
                            throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                        search = copy(search, {}), forEach(search, function (value, key) {
                            null == value && delete search[key]
                        }), this.$$search = search
                    }
                    break;
                default:
                    isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue
            }
            return this.$$compose(), this
        }, hash: locationGetterSetter("$$hash", function (hash) {
            return null !== hash ? hash.toString() : ""
        }), replace: function () {
            return this.$$replace = !0, this
        }};
    forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function (Location) {
        Location.prototype = Object.create(locationPrototype), Location.prototype.state = function (state) {
            if (!arguments.length)
                return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5)
                throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            return this.$$state = isUndefined(state) ? null : state, this
        }
    });
    var $parseMinErr = minErr("$parse"), CALL = Function.prototype.call, APPLY = Function.prototype.apply, BIND = Function.prototype.bind, CONSTANTS = createMap();
    forEach({"null": function () {
            return null
        }, "true": function () {
            return!0
        }, "false": function () {
            return!1
        }, undefined: function () {
        }}, function (constantGetter, name) {
        constantGetter.constant = constantGetter.literal = constantGetter.sharedGetter = !0, CONSTANTS[name] = constantGetter
    }), CONSTANTS["this"] = function (self) {
        return self
    }, CONSTANTS["this"].sharedGetter = !0;
    var OPERATORS = extend(createMap(), {"+": function (self, locals, a, b) {
            return a = a(self, locals), b = b(self, locals), isDefined(a) ? isDefined(b) ? a + b : a : isDefined(b) ? b : undefined
        }, "-": function (self, locals, a, b) {
            return a = a(self, locals), b = b(self, locals), (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0)
        }, "*": function (self, locals, a, b) {
            return a(self, locals) * b(self, locals)
        }, "/": function (self, locals, a, b) {
            return a(self, locals) / b(self, locals)
        }, "%": function (self, locals, a, b) {
            return a(self, locals) % b(self, locals)
        }, "===": function (self, locals, a, b) {
            return a(self, locals) === b(self, locals)
        }, "!==": function (self, locals, a, b) {
            return a(self, locals) !== b(self, locals)
        }, "==": function (self, locals, a, b) {
            return a(self, locals) == b(self, locals)
        }, "!=": function (self, locals, a, b) {
            return a(self, locals) != b(self, locals)
        }, "<": function (self, locals, a, b) {
            return a(self, locals) < b(self, locals)
        }, ">": function (self, locals, a, b) {
            return a(self, locals) > b(self, locals)
        }, "<=": function (self, locals, a, b) {
            return a(self, locals) <= b(self, locals)
        }, ">=": function (self, locals, a, b) {
            return a(self, locals) >= b(self, locals)
        }, "&&": function (self, locals, a, b) {
            return a(self, locals) && b(self, locals)
        }, "||": function (self, locals, a, b) {
            return a(self, locals) || b(self, locals)
        }, "!": function (self, locals, a) {
            return!a(self, locals)
        }, "=": !0, "|": !0}), ESCAPE = {n: "\n", f: "\f", r: "\r", t: "	", v: "", "'": "'", '"': '"'}, Lexer = function (options) {
        this.options = options
    };
    Lexer.prototype = {constructor: Lexer, lex: function (text) {
            for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if ('"' === ch || "'" === ch)
                    this.readString(ch);
                else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek()))
                    this.readNumber();
                else if (this.isIdent(ch))
                    this.readIdent();
                else if (this.is(ch, "(){}[].,;:?"))
                    this.tokens.push({index: this.index, text: ch}), this.index++;
                else if (this.isWhitespace(ch))
                    this.index++;
                else {
                    var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({index: this.index, text: token, operator: !0}), this.index += token.length
                    } else
                        this.throwError("Unexpected next character ", this.index, this.index + 1)
                }
            }
            return this.tokens
        }, is: function (ch, chars) {
            return-1 !== chars.indexOf(ch)
        }, peek: function (i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1
        }, isNumber: function (ch) {
            return ch >= "0" && "9" >= ch && "string" == typeof ch
        }, isWhitespace: function (ch) {
            return" " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || "\xa0" === ch
        }, isIdent: function (ch) {
            return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch
        }, isExpOperator: function (ch) {
            return"-" === ch || "+" === ch || this.isNumber(ch)
        }, throwError: function (error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text)
        }, readNumber: function () {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." == ch || this.isNumber(ch))
                    number += ch;
                else {
                    var peekCh = this.peek();
                    if ("e" == ch && this.isExpOperator(peekCh))
                        number += ch;
                    else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1))
                        number += ch;
                    else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1))
                            break;
                        this.throwError("Invalid exponent")
                    }
                }
                this.index++
            }
            this.tokens.push({index: start, text: number, constant: !0, value: Number(number)})
        }, readIdent: function () {
            for (var start = this.index; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (!this.isIdent(ch) && !this.isNumber(ch))
                    break;
                this.index++
            }
            this.tokens.push({index: start, text: this.text.slice(start, this.index), identifier: !0})
        }, readString: function (quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), this.index += 4, string += String.fromCharCode(parseInt(hex, 16))
                    } else {
                        var rep = ESCAPE[ch];
                        string += rep || ch
                    }
                    escape = !1
                } else if ("\\" === ch)
                    escape = !0;
                else {
                    if (ch === quote)
                        return this.index++, void this.tokens.push({index: start, text: rawString, constant: !0, value: string});
                    string += ch
                }
                this.index++
            }
            this.throwError("Unterminated quote", start)
        }};
    var Parser = function (lexer, $filter, options) {
        this.lexer = lexer, this.$filter = $filter, this.options = options
    };
    Parser.ZERO = extend(function () {
        return 0
    }, {sharedGetter: !0, constant: !0}), Parser.prototype = {constructor: Parser, parse: function (text) {
            this.text = text, this.tokens = this.lexer.lex(text);
            var value = this.statements();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), value.literal = !!value.literal, value.constant = !!value.constant, value
        }, primary: function () {
            var primary;
            this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.peek().identifier && this.peek().text in CONSTANTS ? primary = CONSTANTS[this.consume().text] : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var next, context; next = this.expect("(", "[", "."); )
                "(" === next.text ? (primary = this.functionCall(primary, context), context = null) : "[" === next.text ? (context = primary, primary = this.objectIndex(primary)) : "." === next.text ? (context = primary, primary = this.fieldAccess(primary)) : this.throwError("IMPOSSIBLE");
            return primary
        }, throwError: function (msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index))
        }, peekToken: function () {
            if (0 === this.tokens.length)
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0]
        }, peek: function (e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4)
        }, peekAhead: function (i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4)
                    return token
            }
            return!1
        }, expect: function (e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return token ? (this.tokens.shift(), token) : !1
        }, consume: function (e1) {
            if (0 === this.tokens.length)
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            var token = this.expect(e1);
            return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), token
        }, unaryFn: function (op, right) {
            var fn = OPERATORS[op];
            return extend(function (self, locals) {
                return fn(self, locals, right)
            }, {constant: right.constant, inputs: [right]})
        }, binaryFn: function (left, op, right, isBranching) {
            var fn = OPERATORS[op];
            return extend(function (self, locals) {
                return fn(self, locals, left, right)
            }, {constant: left.constant && right.constant, inputs: !isBranching && [left, right]})
        }, identifier: function () {
            for (var id = this.consume().text; this.peek(".") && this.peekAhead(1).identifier && !this.peekAhead(2, "("); )
                id += this.consume().text + this.consume().text;
            return getterFn(id, this.options, this.text)
        }, constant: function () {
            var value = this.consume().value;
            return extend(function () {
                return value
            }, {constant: !0, literal: !0})
        }, statements: function () {
            for (var statements = []; ; )
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && statements.push(this.filterChain()), !this.expect(";"))
                    return 1 === statements.length ? statements[0] : function (self, locals) {
                        for (var value, i = 0, ii = statements.length; ii > i; i++)
                            value = statements[i](self, locals);
                        return value
                    }
        }, filterChain: function () {
            for (var token, left = this.expression(); token = this.expect("|"); )
                left = this.filter(left);
            return left
        }, filter: function (inputFn) {
            var argsFn, args, fn = this.$filter(this.consume().text);
            if (this.peek(":"))
                for (argsFn = [], args = []; this.expect(":"); )
                    argsFn.push(this.expression());
            var inputs = [inputFn].concat(argsFn || []);
            return extend(function (self, locals) {
                var input = inputFn(self, locals);
                if (args) {
                    args[0] = input;
                    for (var i = argsFn.length; i--; )
                        args[i + 1] = argsFn[i](self, locals);
                    return fn.apply(undefined, args)
                }
                return fn(input)
            }, {constant: !fn.$stateful && inputs.every(isConstant), inputs: !fn.$stateful && inputs})
        }, expression: function () {
            return this.assignment()
        }, assignment: function () {
            var right, token, left = this.ternary();
            return(token = this.expect("=")) ? (left.assign || this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token), right = this.ternary(), extend(function (scope, locals) {
                return left.assign(scope, right(scope, locals), locals)
            }, {inputs: [left, right]})) : left
        }, ternary: function () {
            var middle, token, left = this.logicalOR();
            if ((token = this.expect("?")) && (middle = this.assignment(), this.consume(":"))) {
                var right = this.assignment();
                return extend(function (self, locals) {
                    return left(self, locals) ? middle(self, locals) : right(self, locals)
                }, {constant: left.constant && middle.constant && right.constant})
            }
            return left
        }, logicalOR: function () {
            for (var token, left = this.logicalAND(); token = this.expect("||"); )
                left = this.binaryFn(left, token.text, this.logicalAND(), !0);
            return left
        }, logicalAND: function () {
            for (var token, left = this.equality(); token = this.expect("&&"); )
                left = this.binaryFn(left, token.text, this.equality(), !0);
            return left
        }, equality: function () {
            for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); )
                left = this.binaryFn(left, token.text, this.relational());
            return left
        }, relational: function () {
            for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); )
                left = this.binaryFn(left, token.text, this.additive());
            return left
        }, additive: function () {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); )
                left = this.binaryFn(left, token.text, this.multiplicative());
            return left
        }, multiplicative: function () {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); )
                left = this.binaryFn(left, token.text, this.unary());
            return left
        }, unary: function () {
            var token;
            return this.expect("+") ? this.primary() : (token = this.expect("-")) ? this.binaryFn(Parser.ZERO, token.text, this.unary()) : (token = this.expect("!")) ? this.unaryFn(token.text, this.unary()) : this.primary()
        }, fieldAccess: function (object) {
            var getter = this.identifier();
            return extend(function (scope, locals, self) {
                var o = self || object(scope, locals);
                return null == o ? undefined : getter(o)
            }, {assign: function (scope, value, locals) {
                    var o = object(scope, locals);
                    return o || object.assign(scope, o = {}, locals), getter.assign(o, value)
                }})
        }, objectIndex: function (obj) {
            var expression = this.text, indexFn = this.expression();
            return this.consume("]"), extend(function (self, locals) {
                var v, o = obj(self, locals), i = indexFn(self, locals);
                return ensureSafeMemberName(i, expression), o ? v = ensureSafeObject(o[i], expression) : undefined
            }, {assign: function (self, value, locals) {
                    var key = ensureSafeMemberName(indexFn(self, locals), expression), o = ensureSafeObject(obj(self, locals), expression);
                    return o || obj.assign(self, o = {}, locals), o[key] = value
                }})
        }, functionCall: function (fnGetter, contextGetter) {
            var argsFn = [];
            if (")" !== this.peekToken().text)
                do
                    argsFn.push(this.expression());
                while (this.expect(","));
            this.consume(")");
            var expressionText = this.text, args = argsFn.length ? [] : null;
            return function (scope, locals) {
                var context = contextGetter ? contextGetter(scope, locals) : isDefined(contextGetter) ? undefined : scope, fn = fnGetter(scope, locals, context) || noop;
                if (args)
                    for (var i = argsFn.length; i--; )
                        args[i] = ensureSafeObject(argsFn[i](scope, locals), expressionText);
                ensureSafeObject(context, expressionText), ensureSafeFunction(fn, expressionText);
                var v = fn.apply ? fn.apply(context, args) : fn(args[0], args[1], args[2], args[3], args[4]);
                return ensureSafeObject(v, expressionText)
            }
        }, arrayDeclaration: function () {
            var elementFns = [];
            if ("]" !== this.peekToken().text)
                do {
                    if (this.peek("]"))
                        break;
                    elementFns.push(this.expression())
                } while (this.expect(","));
            return this.consume("]"), extend(function (self, locals) {
                for (var array = [], i = 0, ii = elementFns.length; ii > i; i++)
                    array.push(elementFns[i](self, locals));
                return array
            }, {literal: !0, constant: elementFns.every(isConstant), inputs: elementFns})
        }, object: function () {
            var keys = [], valueFns = [];
            if ("}" !== this.peekToken().text)
                do {
                    if (this.peek("}"))
                        break;
                    var token = this.consume();
                    token.constant ? keys.push(token.value) : token.identifier ? keys.push(token.text) : this.throwError("invalid key", token), this.consume(":"), valueFns.push(this.expression())
                } while (this.expect(","));
            return this.consume("}"), extend(function (self, locals) {
                for (var object = {}, i = 0, ii = valueFns.length; ii > i; i++)
                    object[keys[i]] = valueFns[i](self, locals);
                return object
            }, {literal: !0, constant: valueFns.every(isConstant), inputs: valueFns})
        }};
    var getterFnCacheDefault = createMap(), getterFnCacheExpensive = createMap(), objectValueOf = Object.prototype.valueOf, $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {HTML: "html", CSS: "css", URL: "url", RESOURCE_URL: "resourceUrl", JS: "js"}, $compileMinErr = minErr("$compile"), urlParsingNode = document.createElement("a"), originUrl = urlResolve(window.location.href);
    $FilterProvider.$inject = ["$provide"], currencyFilter.$inject = ["$locale"], numberFilter.$inject = ["$locale"];
    var DECIMAL_SEP = ".", DATE_FORMATS = {yyyy: dateGetter("FullYear", 4), yy: dateGetter("FullYear", 2, 0, !0), y: dateGetter("FullYear", 1), MMMM: dateStrGetter("Month"), MMM: dateStrGetter("Month", !0), MM: dateGetter("Month", 2, 1), M: dateGetter("Month", 1, 1), dd: dateGetter("Date", 2), d: dateGetter("Date", 1), HH: dateGetter("Hours", 2), H: dateGetter("Hours", 1), hh: dateGetter("Hours", 2, -12), h: dateGetter("Hours", 1, -12), mm: dateGetter("Minutes", 2), m: dateGetter("Minutes", 1), ss: dateGetter("Seconds", 2), s: dateGetter("Seconds", 1), sss: dateGetter("Milliseconds", 3), EEEE: dateStrGetter("Day"), EEE: dateStrGetter("Day", !0), a: ampmGetter, Z: timeZoneGetter, ww: weekGetter(2), w: weekGetter(1)}, DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEw']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = ["$locale"];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = ["$parse"];
    var htmlAnchorDirective = valueFn({restrict: "E", compile: function (element, attr) {
            return attr.href || attr.xlinkHref || attr.name ? void 0 : function (scope, element) {
                var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                element.on("click", function (event) {
                    element.attr(href) || event.preventDefault()
                })
            }
        }}), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function (propName, attrName) {
        if ("multiple" != propName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = function () {
                return{restrict: "A", priority: 100, link: function (scope, element, attr) {
                        scope.$watch(attr[normalized], function (value) {
                            attr.$set(attrName, !!value)
                        })
                    }}
            }
        }
    }), forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function () {
            return{priority: 100, link: function (scope, element, attr) {
                    if ("ngPattern" === ngAttr && "/" == attr.ngPattern.charAt(0)) {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match)
                            return void attr.$set("ngPattern", new RegExp(match[1], match[2]))
                    }
                    scope.$watch(attr[ngAttr], function (value) {
                        attr.$set(ngAttr, value)
                    })
                }}
        }
    }), forEach(["src", "srcset", "href"], function (attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function () {
            return{priority: 99, link: function (scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function (value) {
                        return value ? (attr.$set(name, value), void(msie && propName && element.prop(propName, attr[name]))) : void("href" === attrName && attr.$set(name, null))
                    })
                }}
        }
    });
    var nullFormCtrl = {$addControl: noop, $$renameControl: nullFormRenameControl, $removeControl: noop, $setValidity: noop, $setDirty: noop, $setPristine: noop, $setSubmitted: noop}, SUBMITTED_CLASS = "ng-submitted";
    FormController.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"];
    var formDirectiveFactory = function (isNgForm) {
        return["$timeout", function ($timeout) {
                var formDirective = {name: "form", restrict: isNgForm ? "EAC" : "E", controller: FormController, compile: function (formElement) {
                        return formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS), {pre: function (scope, formElement, attr, controller) {
                                if (!("action"in attr)) {
                                    var handleFormSubmission = function (event) {
                                        scope.$apply(function () {
                                            controller.$commitViewValue(), controller.$setSubmitted()
                                        }), event.preventDefault()
                                    };
                                    addEventListenerFn(formElement[0], "submit", handleFormSubmission), formElement.on("$destroy", function () {
                                        $timeout(function () {
                                            removeEventListenerFn(formElement[0], "submit", handleFormSubmission)
                                        }, 0, !1)
                                    })
                                }
                                var parentFormCtrl = controller.$$parentForm, alias = controller.$name;
                                alias && (setter(scope, null, alias, controller, alias), attr.$observe(attr.name ? "name" : "ngForm", function (newValue) {
                                    alias !== newValue && (setter(scope, null, alias, undefined, alias), alias = newValue, setter(scope, null, alias, controller, alias), parentFormCtrl.$$renameControl(controller, alias))
                                })), formElement.on("$destroy", function () {
                                    parentFormCtrl.$removeControl(controller), alias && setter(scope, null, alias, undefined, alias), extend(controller, nullFormCtrl)
                                })
                            }}
                    }};
                return formDirective
            }]
    }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/, URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/, EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/, DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, inputType = {text: textInputType, date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"), "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ["yyyy", "MM", "dd", "HH", "mm", "ss", "sss"]), "yyyy-MM-ddTHH:mm:ss.sss"), time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"), week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"), month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, ["yyyy", "MM"]), "yyyy-MM"), number: numberInputType, url: urlInputType, email: emailInputType, radio: radioInputType, checkbox: checkboxInputType, hidden: noop, button: noop, submit: noop, reset: noop, file: noop}, inputDirective = ["$browser", "$sniffer", "$filter", "$parse", function ($browser, $sniffer, $filter, $parse) {
            return{restrict: "E", require: ["?ngModel"], link: {pre: function (scope, element, attr, ctrls) {
                        ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse)
                    }}}
        }], CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function () {
        return{restrict: "A", priority: 100, compile: function (tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function (scope, elm, attr) {
                    attr.$set("value", scope.$eval(attr.ngValue))
                } : function (scope, elm, attr) {
                    scope.$watch(attr.ngValue, function (value) {
                        attr.$set("value", value)
                    })
                }
            }}
    }, ngBindDirective = ["$compile", function ($compile) {
            return{restrict: "AC", compile: function (templateElement) {
                    return $compile.$$addBindingClass(templateElement), function (scope, element, attr) {
                        $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function (value) {
                            element.textContent = value === undefined ? "" : value
                        })
                    }
                }}
        }], ngBindTemplateDirective = ["$interpolate", "$compile", function ($interpolate, $compile) {
            return{compile: function (templateElement) {
                    return $compile.$$addBindingClass(templateElement), function (scope, element, attr) {
                        var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                        $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], attr.$observe("ngBindTemplate", function (value) {
                            element.textContent = value === undefined ? "" : value
                        })
                    }
                }}
        }], ngBindHtmlDirective = ["$sce", "$parse", "$compile", function ($sce, $parse, $compile) {
            return{restrict: "A", compile: function (tElement, tAttrs) {
                    var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function (value) {
                        return(value || "").toString()
                    });
                    return $compile.$$addBindingClass(tElement), function (scope, element, attr) {
                        $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function () {
                            element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || "")
                        })
                    }
                }}
        }], ngChangeDirective = valueFn({restrict: "A", require: "ngModel", link: function (scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function () {
                scope.$eval(attr.ngChange)
            })
        }}), ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({compile: function (element, attr) {
            attr.$set("ngCloak", undefined), element.removeClass("ng-cloak")
        }}), ngControllerDirective = [function () {
            return{restrict: "A", scope: !0, controller: "@", priority: 500}
        }], ngEventDirectives = {}, forceAsyncEvents = {blur: !0, focus: !0};
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function (eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = ["$parse", "$rootScope", function ($parse, $rootScope) {
                return{restrict: "A", compile: function ($element, attr) {
                        var fn = $parse(attr[directiveName], null, !0);
                        return function (scope, element) {
                            element.on(eventName, function (event) {
                                var callback = function () {
                                    fn(scope, {$event: event})
                                };
                                forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) : scope.$apply(callback)
                            })
                        }
                    }}
            }]
    });
    var ngIfDirective = ["$animate", function ($animate) {
            return{multiElement: !0, transclude: "element", priority: 600, terminal: !0, restrict: "A", $$tlb: !0, link: function ($scope, $element, $attr, ctrl, $transclude) {
                    var block, childScope, previousElements;
                    $scope.$watch($attr.ngIf, function (value) {
                        value ? childScope || $transclude(function (clone, newScope) {
                            childScope = newScope, clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "), block = {clone: clone}, $animate.enter(clone, $element.parent(), $element)
                        }) : (previousElements && (previousElements.remove(), previousElements = null), childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), $animate.leave(previousElements).then(function () {
                            previousElements = null
                        }), block = null))
                    })
                }}
        }], ngIncludeDirective = ["$templateRequest", "$anchorScroll", "$animate", "$sce", function ($templateRequest, $anchorScroll, $animate, $sce) {
            return{restrict: "ECA", priority: 400, terminal: !0, transclude: "element", controller: angular.noop, compile: function (element, attr) {
                    var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                    return function (scope, $element, $attr, ctrl, $transclude) {
                        var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function () {
                            previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), currentScope = null), currentElement && ($animate.leave(currentElement).then(function () {
                                previousElement = null
                            }), previousElement = currentElement, currentElement = null)
                        };
                        scope.$watch($sce.parseAsResourceUrl(srcExp), function (src) {
                            var afterAnimation = function () {
                                !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll()
                            }, thisChangeId = ++changeCounter;
                            src ? ($templateRequest(src, !0).then(function (response) {
                                if (thisChangeId === changeCounter) {
                                    var newScope = scope.$new();
                                    ctrl.template = response;
                                    var clone = $transclude(newScope, function (clone) {
                                        cleanupLastIncludeContent(), $animate.enter(clone, null, $element).then(afterAnimation)
                                    });
                                    currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src), scope.$eval(onloadExp)
                                }
                            }, function () {
                                thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src))
                            }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), ctrl.template = null)
                        })
                    }
                }}
        }], ngIncludeFillContentDirective = ["$compile", function ($compile) {
            return{restrict: "ECA", priority: -400, require: "ngInclude", link: function (scope, $element, $attr, ctrl) {
                    return/SVG/.test($element[0].toString()) ? ($element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function (clone) {
                        $element.append(clone)
                    }, {futureParentElement: $element})) : ($element.html(ctrl.template), void $compile($element.contents())(scope))
                }}
        }], ngInitDirective = ngDirective({priority: 450, compile: function () {
            return{pre: function (scope, element, attrs) {
                    scope.$eval(attrs.ngInit)
                }}
        }}), ngListDirective = function () {
        return{restrict: "A", priority: 100, require: "ngModel", link: function (scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList, parse = function (viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function (value) {
                            value && list.push(trimValues ? trim(value) : value)
                        }), list
                    }
                };
                ctrl.$parsers.push(parse), ctrl.$formatters.push(function (value) {
                    return isArray(value) ? value.join(ngList) : undefined
                }), ctrl.$isEmpty = function (value) {
                    return!value || !value.length
                }
            }}
    }, VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending", $ngModelMinErr = new minErr("ngModel"), NgModelController = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function ($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
            this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = undefined, this.$validators = {}, this.$asyncValidators = {},
                    this.$parsers = [], this.$formatters = [], this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, this.$pending = undefined, this.$name = $interpolate($attr.name || "", !1)($scope);
            var parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, ctrl = this;
            this.$$setOptions = function (options) {
                if (ctrl.$options = options, options && options.getterSetter) {
                    var invokeModelGetter = $parse($attr.ngModel + "()"), invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                    ngModelGet = function ($scope) {
                        var modelValue = parsedNgModel($scope);
                        return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue
                    }, ngModelSet = function ($scope, newValue) {
                        isFunction(parsedNgModel($scope)) ? invokeModelSetter($scope, {$$$p: ctrl.$modelValue}) : parsedNgModelAssign($scope, ctrl.$modelValue)
                    }
                } else if (!parsedNgModel.assign)
                    throw $ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element))
            }, this.$render = noop, this.$isEmpty = function (value) {
                return isUndefined(value) || "" === value || null === value || value !== value
            };
            var parentForm = $element.inheritedData("$formController") || nullFormCtrl, currentValidationRunId = 0;
            addSetValidityMethod({ctrl: this, $element: $element, set: function (object, property) {
                    object[property] = !0
                }, unset: function (object, property) {
                    delete object[property]
                }, parentForm: parentForm, $animate: $animate}), this.$setPristine = function () {
                ctrl.$dirty = !1, ctrl.$pristine = !0, $animate.removeClass($element, DIRTY_CLASS), $animate.addClass($element, PRISTINE_CLASS)
            }, this.$setDirty = function () {
                ctrl.$dirty = !0, ctrl.$pristine = !1, $animate.removeClass($element, PRISTINE_CLASS), $animate.addClass($element, DIRTY_CLASS), parentForm.$setDirty()
            }, this.$setUntouched = function () {
                ctrl.$touched = !1, ctrl.$untouched = !0, $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS)
            }, this.$setTouched = function () {
                ctrl.$touched = !0, ctrl.$untouched = !1, $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS)
            }, this.$rollbackViewValue = function () {
                $timeout.cancel(pendingDebounce), ctrl.$viewValue = ctrl.$$lastCommittedViewValue, ctrl.$render()
            }, this.$validate = function () {
                if (!isNumber(ctrl.$modelValue) || !isNaN(ctrl.$modelValue)) {
                    var viewValue = ctrl.$$lastCommittedViewValue, modelValue = ctrl.$$rawModelValue, parserName = ctrl.$$parserName || "parse", parserValid = ctrl.$error[parserName] ? !1 : undefined, prevValid = ctrl.$valid, prevModelValue = ctrl.$modelValue, allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                    ctrl.$$runValidators(parserValid, modelValue, viewValue, function (allValid) {
                        allowInvalid || prevValid === allValid || (ctrl.$modelValue = allValid ? modelValue : undefined, ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope())
                    })
                }
            }, this.$$runValidators = function (parseValid, modelValue, viewValue, doneCallback) {
                function processParseErrors(parseValid) {
                    var errorKey = ctrl.$$parserName || "parse";
                    if (parseValid === undefined)
                        setValidity(errorKey, null);
                    else if (setValidity(errorKey, parseValid), !parseValid)
                        return forEach(ctrl.$validators, function (v, name) {
                            setValidity(name, null)
                        }), forEach(ctrl.$asyncValidators, function (v, name) {
                            setValidity(name, null)
                        }), !1;
                    return!0
                }
                function processSyncValidators() {
                    var syncValidatorsValid = !0;
                    return forEach(ctrl.$validators, function (validator, name) {
                        var result = validator(modelValue, viewValue);
                        syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result)
                    }), syncValidatorsValid ? !0 : (forEach(ctrl.$asyncValidators, function (v, name) {
                        setValidity(name, null)
                    }), !1)
                }
                function processAsyncValidators() {
                    var validatorPromises = [], allValid = !0;
                    forEach(ctrl.$asyncValidators, function (validator, name) {
                        var promise = validator(modelValue, viewValue);
                        if (!isPromiseLike(promise))
                            throw $ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                        setValidity(name, undefined), validatorPromises.push(promise.then(function () {
                            setValidity(name, !0)
                        }, function (error) {
                            allValid = !1, setValidity(name, !1)
                        }))
                    }), validatorPromises.length ? $q.all(validatorPromises).then(function () {
                        validationDone(allValid)
                    }, noop) : validationDone(!0)
                }
                function setValidity(name, isValid) {
                    localValidationRunId === currentValidationRunId && ctrl.$setValidity(name, isValid)
                }
                function validationDone(allValid) {
                    localValidationRunId === currentValidationRunId && doneCallback(allValid)
                }
                currentValidationRunId++;
                var localValidationRunId = currentValidationRunId;
                return processParseErrors(parseValid) && processSyncValidators() ? void processAsyncValidators() : void validationDone(!1)
            }, this.$commitViewValue = function () {
                var viewValue = ctrl.$viewValue;
                $timeout.cancel(pendingDebounce), (ctrl.$$lastCommittedViewValue !== viewValue || "" === viewValue && ctrl.$$hasNativeValidators) && (ctrl.$$lastCommittedViewValue = viewValue, ctrl.$pristine && this.$setDirty(), this.$$parseAndValidate())
            }, this.$$parseAndValidate = function () {
                function writeToModelIfNeeded() {
                    ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope()
                }
                var viewValue = ctrl.$$lastCommittedViewValue, modelValue = viewValue, parserValid = isUndefined(modelValue) ? undefined : !0;
                if (parserValid)
                    for (var i = 0; i < ctrl.$parsers.length; i++)
                        if (modelValue = ctrl.$parsers[i](modelValue), isUndefined(modelValue)) {
                            parserValid = !1;
                            break
                        }
                isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue) && (ctrl.$modelValue = ngModelGet($scope));
                var prevModelValue = ctrl.$modelValue, allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                ctrl.$$rawModelValue = modelValue, allowInvalid && (ctrl.$modelValue = modelValue, writeToModelIfNeeded()), ctrl.$$runValidators(parserValid, modelValue, ctrl.$$lastCommittedViewValue, function (allValid) {
                    allowInvalid || (ctrl.$modelValue = allValid ? modelValue : undefined, writeToModelIfNeeded())
                })
            }, this.$$writeModelToScope = function () {
                ngModelSet($scope, ctrl.$modelValue), forEach(ctrl.$viewChangeListeners, function (listener) {
                    try {
                        listener()
                    } catch (e) {
                        $exceptionHandler(e)
                    }
                })
            }, this.$setViewValue = function (value, trigger) {
                ctrl.$viewValue = value, (!ctrl.$options || ctrl.$options.updateOnDefault) && ctrl.$$debounceViewValueCommit(trigger)
            }, this.$$debounceViewValueCommit = function (trigger) {
                var debounce, debounceDelay = 0, options = ctrl.$options;
                options && isDefined(options.debounce) && (debounce = options.debounce, isNumber(debounce) ? debounceDelay = debounce : isNumber(debounce[trigger]) ? debounceDelay = debounce[trigger] : isNumber(debounce["default"]) && (debounceDelay = debounce["default"])), $timeout.cancel(pendingDebounce), debounceDelay ? pendingDebounce = $timeout(function () {
                    ctrl.$commitViewValue()
                }, debounceDelay) : $rootScope.$$phase ? ctrl.$commitViewValue() : $scope.$apply(function () {
                    ctrl.$commitViewValue()
                })
            }, $scope.$watch(function () {
                var modelValue = ngModelGet($scope);
                if (modelValue !== ctrl.$modelValue) {
                    ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                    for (var formatters = ctrl.$formatters, idx = formatters.length, viewValue = modelValue; idx--; )
                        viewValue = formatters[idx](viewValue);
                    ctrl.$viewValue !== viewValue && (ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue, ctrl.$render(), ctrl.$$runValidators(undefined, modelValue, viewValue, noop))
                }
                return modelValue
            })
        }], ngModelDirective = ["$rootScope", function ($rootScope) {
            return{restrict: "A", require: ["ngModel", "^?form", "^?ngModelOptions"], controller: NgModelController, priority: 1, compile: function (element) {
                    return element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS), {pre: function (scope, element, attr, ctrls) {
                            var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                            modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options), formCtrl.$addControl(modelCtrl), attr.$observe("name", function (newValue) {
                                modelCtrl.$name !== newValue && formCtrl.$$renameControl(modelCtrl, newValue)
                            }), scope.$on("$destroy", function () {
                                formCtrl.$removeControl(modelCtrl)
                            })
                        }, post: function (scope, element, attr, ctrls) {
                            var modelCtrl = ctrls[0];
                            modelCtrl.$options && modelCtrl.$options.updateOn && element.on(modelCtrl.$options.updateOn, function (ev) {
                                modelCtrl.$$debounceViewValueCommit(ev && ev.type)
                            }), element.on("blur", function (ev) {
                                modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(modelCtrl.$setTouched) : scope.$apply(modelCtrl.$setTouched))
                            })
                        }}
                }}
        }], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/, ngModelOptionsDirective = function () {
        return{restrict: "A", controller: ["$scope", "$attrs", function ($scope, $attrs) {
                    var that = this;
                    this.$options = $scope.$eval($attrs.ngModelOptions), this.$options.updateOn !== undefined ? (this.$options.updateOnDefault = !1, this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function () {
                        return that.$options.updateOnDefault = !0, " "
                    }))) : this.$options.updateOnDefault = !0
                }]}
    }, ngNonBindableDirective = ngDirective({terminal: !0, priority: 1e3}), ngPluralizeDirective = ["$locale", "$interpolate", function ($locale, $interpolate) {
            var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
            return{restrict: "EA", link: function (scope, element, attr) {
                    function updateElementText(newText) {
                        element.text(newText || "")
                    }
                    var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                    forEach(attr, function (expression, attributeName) {
                        var tmpMatch = IS_WHEN.exec(attributeName);
                        if (tmpMatch) {
                            var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                            whens[whenKey] = element.attr(attr.$attr[attributeName])
                        }
                    }), forEach(whens, function (expression, key) {
                        whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement))
                    }), scope.$watch(numberExp, function (newVal) {
                        var count = parseFloat(newVal), countIsNaN = isNaN(count);
                        countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), count === lastCount || countIsNaN && isNaN(lastCount) || (watchRemover(), watchRemover = scope.$watch(whensExpFns[count], updateElementText), lastCount = count)
                    })
                }}
        }], ngRepeatDirective = ["$parse", "$animate", function ($parse, $animate) {
            var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat"), updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), scope.$odd = !(scope.$even = 0 === (1 & index))
            }, getBlockStart = function (block) {
                return block.clone[0]
            }, getBlockEnd = function (block) {
                return block.clone[block.clone.length - 1]
            };
            return{restrict: "A", multiElement: !0, transclude: "element", priority: 1e3, terminal: !0, $$tlb: !0, compile: function ($element, $attr) {
                    var expression = $attr.ngRepeat, ngRepeatEndComment = document.createComment(" end ngRepeat: " + expression + " "), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                    if (!match)
                        throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                    var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                    if (match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/), !match)
                        throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                    var valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                    if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs)))
                        throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                    var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, hashFnLocals = {$id: hashKey};
                    return trackByExp ? trackByExpGetter = $parse(trackByExp) : (trackByIdArrayFn = function (key, value) {
                        return hashKey(value)
                    }, trackByIdObjFn = function (key) {
                        return key
                    }), function ($scope, $element, $attr, ctrl, $transclude) {
                        trackByExpGetter && (trackByIdExpFn = function (key, value, index) {
                            return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals)
                        });
                        var lastBlockMap = createMap();
                        $scope.$watchCollection(rhs, function (collection) {
                            var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                            if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection))
                                collectionKeys = collection, trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                            else {
                                trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                                for (var itemKey in collection)
                                    collection.hasOwnProperty(itemKey) && "$" != itemKey.charAt(0) && collectionKeys.push(itemKey);
                                collectionKeys.sort()
                            }
                            for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), index = 0; collectionLength > index; index++)
                                if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], trackById = trackByIdFn(key, value, index), lastBlockMap[trackById])
                                    block = lastBlockMap[trackById], delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block;
                                else {
                                    if (nextBlockMap[trackById])
                                        throw forEach(nextBlockOrder, function (block) {
                                            block && block.scope && (lastBlockMap[block.id] = block)
                                        }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                                    nextBlockOrder[index] = {id: trackById, scope: undefined, clone: undefined}, nextBlockMap[trackById] = !0
                                }
                            for (var blockKey in lastBlockMap) {
                                if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone), $animate.leave(elementsToRemove), elementsToRemove[0].parentNode)
                                    for (index = 0, length = elementsToRemove.length; length > index; index++)
                                        elementsToRemove[index][NG_REMOVED] = !0;
                                block.scope.$destroy()
                            }
                            for (index = 0; collectionLength > index; index++)
                                if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], block = nextBlockOrder[index], block.scope) {
                                    nextNode = previousNode;
                                    do
                                        nextNode = nextNode.nextSibling;
                                    while (nextNode && nextNode[NG_REMOVED]);
                                    getBlockStart(block) != nextNode && $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode)), previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                                } else
                                    $transclude(function (clone, scope) {
                                        block.scope = scope;
                                        var endNode = ngRepeatEndComment.cloneNode(!1);
                                        clone[clone.length++] = endNode, $animate.enter(clone, null, jqLite(previousNode)), previousNode = endNode, block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                                    });
                            lastBlockMap = nextBlockMap
                        })
                    }
                }}
        }], NG_HIDE_CLASS = "ng-hide", NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate", ngShowDirective = ["$animate", function ($animate) {
            return{restrict: "A", multiElement: !0, link: function (scope, element, attr) {
                    scope.$watch(attr.ngShow, function (value) {
                        $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS})
                    })
                }}
        }], ngHideDirective = ["$animate", function ($animate) {
            return{restrict: "A", multiElement: !0, link: function (scope, element, attr) {
                    scope.$watch(attr.ngHide, function (value) {
                        $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS})
                    })
                }}
        }], ngStyleDirective = ngDirective(function (scope, element, attr) {
        scope.$watchCollection(attr.ngStyle, function (newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function (val, style) {
                element.css(style, "")
            }), newStyles && element.css(newStyles)
        })
    }), ngSwitchDirective = ["$animate", function ($animate) {
            return{restrict: "EA", require: "ngSwitch", controller: ["$scope", function () {
                        this.cases = {}
                    }], link: function (scope, element, attr, ngSwitchController) {
                    var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function (array, index) {
                        return function () {
                            array.splice(index, 1)
                        }
                    };
                    scope.$watch(watchExpr, function (value) {
                        var i, ii;
                        for (i = 0, ii = previousLeaveAnimations.length; ii > i; ++i)
                            $animate.cancel(previousLeaveAnimations[i]);
                        for (previousLeaveAnimations.length = 0, i = 0, ii = selectedScopes.length; ii > i; ++i) {
                            var selected = getBlockNodes(selectedElements[i].clone);
                            selectedScopes[i].$destroy();
                            var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                            promise.then(spliceFactory(previousLeaveAnimations, i))
                        }
                        selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function (selectedTransclude) {
                            selectedTransclude.transclude(function (caseElement, selectedScope) {
                                selectedScopes.push(selectedScope);
                                var anchor = selectedTransclude.element;
                                caseElement[caseElement.length++] = document.createComment(" end ngSwitchWhen: ");
                                var block = {clone: caseElement};
                                selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor)
                            })
                        })
                    })
                }}
        }], ngSwitchWhenDirective = ngDirective({transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [], ctrl.cases["!" + attrs.ngSwitchWhen].push({transclude: $transclude, element: element})
        }}), ngSwitchDefaultDirective = ngDirective({transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({transclude: $transclude, element: element})
        }}), ngTranscludeDirective = ngDirective({restrict: "EAC", link: function ($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude)
                throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
            $transclude(function (clone) {
                $element.empty(), $element.append(clone)
            })
        }}), scriptDirective = ["$templateCache", function ($templateCache) {
            return{restrict: "E", terminal: !0, compile: function (element, attr) {
                    if ("text/ng-template" == attr.type) {
                        var templateUrl = attr.id, text = element[0].text;
                        $templateCache.put(templateUrl, text)
                    }
                }}
        }], ngOptionsMinErr = minErr("ngOptions"), ngOptionsDirective = valueFn({restrict: "A", terminal: !0}), selectDirective = ["$compile", "$parse", function ($compile, $parse) {
            var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {$setViewValue: noop};
            return{restrict: "E", require: ["select", "?ngModel"], controller: ["$element", "$scope", "$attrs", function ($element, $scope, $attrs) {
                        var nullOption, unknownOption, self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl;
                        self.databound = $attrs.ngModel, self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
                            ngModelCtrl = ngModelCtrl_, nullOption = nullOption_, unknownOption = unknownOption_
                        }, self.addOption = function (value, element) {
                            assertNotHasOwnProperty(value, '"option value"'), optionsMap[value] = !0, ngModelCtrl.$viewValue == value && ($element.val(value), unknownOption.parent() && unknownOption.remove()), element && element[0].hasAttribute("selected") && (element[0].selected = !0)
                        }, self.removeOption = function (value) {
                            this.hasOption(value) && (delete optionsMap[value], ngModelCtrl.$viewValue === value && this.renderUnknownOption(value))
                        }, self.renderUnknownOption = function (val) {
                            var unknownVal = "? " + hashKey(val) + " ?";
                            unknownOption.val(unknownVal), $element.prepend(unknownOption), $element.val(unknownVal), unknownOption.prop("selected", !0)
                        }, self.hasOption = function (value) {
                            return optionsMap.hasOwnProperty(value)
                        }, $scope.$on("$destroy", function () {
                            self.renderUnknownOption = noop
                        })
                    }], link: function (scope, element, attr, ctrls) {
                    function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                        ngModelCtrl.$render = function () {
                            var viewValue = ngModelCtrl.$viewValue;
                            selectCtrl.hasOption(viewValue) ? (unknownOption.parent() && unknownOption.remove(), selectElement.val(viewValue), "" === viewValue && emptyOption.prop("selected", !0)) : isUndefined(viewValue) && emptyOption ? selectElement.val("") : selectCtrl.renderUnknownOption(viewValue)
                        }, selectElement.on("change", function () {
                            scope.$apply(function () {
                                unknownOption.parent() && unknownOption.remove(), ngModelCtrl.$setViewValue(selectElement.val())
                            })
                        })
                    }
                    function setupAsMultiple(scope, selectElement, ctrl) {
                        var lastView;
                        ctrl.$render = function () {
                            var items = new HashMap(ctrl.$viewValue);
                            forEach(selectElement.find("option"), function (option) {
                                option.selected = isDefined(items.get(option.value))
                            })
                        }, scope.$watch(function () {
                            equals(lastView, ctrl.$viewValue) || (lastView = shallowCopy(ctrl.$viewValue), ctrl.$render())
                        }), selectElement.on("change", function () {
                            scope.$apply(function () {
                                var array = [];
                                forEach(selectElement.find("option"), function (option) {
                                    option.selected && array.push(option.value)
                                }), ctrl.$setViewValue(array)
                            })
                        })
                    }
                    function setupAsOptions(scope, selectElement, ctrl) {
                        function callExpression(exprFn, key, value) {
                            return locals[valueName] = value, keyName && (locals[keyName] = key), exprFn(scope, locals)
                        }
                        function selectionChanged() {
                            scope.$apply(function () {
                                var viewValue, collection = valuesFn(scope) || [];
                                if (multiple)
                                    viewValue = [], forEach(selectElement.val(), function (selectedKey) {
                                        selectedKey = trackFn ? trackKeysCache[selectedKey] : selectedKey, viewValue.push(getViewValue(selectedKey, collection[selectedKey]))
                                    });
                                else {
                                    var selectedKey = trackFn ? trackKeysCache[selectElement.val()] : selectElement.val();
                                    viewValue = getViewValue(selectedKey, collection[selectedKey])
                                }
                                ctrl.$setViewValue(viewValue), render()
                            })
                        }
                        function getViewValue(key, value) {
                            if ("?" === key)
                                return undefined;
                            if ("" === key)
                                return null;
                            var viewValueFn = selectAsFn ? selectAsFn : valueFn;
                            return callExpression(viewValueFn, key, value)
                        }
                        function getLabels() {
                            var toDisplay, values = valuesFn(scope);
                            if (values && isArray(values)) {
                                toDisplay = new Array(values.length);
                                for (var i = 0, ii = values.length; ii > i; i++)
                                    toDisplay[i] = callExpression(displayFn, i, values[i]);
                                return toDisplay
                            }
                            if (values) {
                                toDisplay = {};
                                for (var prop in values)
                                    values.hasOwnProperty(prop) && (toDisplay[prop] = callExpression(displayFn, prop, values[prop]))
                            }
                            return toDisplay
                        }
                        function createIsSelectedFn(viewValue) {
                            var selectedSet;
                            if (multiple)
                                if (trackFn && isArray(viewValue)) {
                                    selectedSet = new HashMap([]);
                                    for (var trackIndex = 0; trackIndex < viewValue.length; trackIndex++)
                                        selectedSet.put(callExpression(trackFn, null, viewValue[trackIndex]), !0)
                                } else
                                    selectedSet = new HashMap(viewValue);
                            else
                                trackFn && (viewValue = callExpression(trackFn, null, viewValue));
                            return function (key, value) {
                                var compareValueFn;
                                return compareValueFn = trackFn ? trackFn : selectAsFn ? selectAsFn : valueFn, multiple ? isDefined(selectedSet.remove(callExpression(compareValueFn, key, value))) : viewValue === callExpression(compareValueFn, key, value)
                            }
                        }
                        function scheduleRendering() {
                            renderScheduled || (scope.$$postDigest(render), renderScheduled = !0)
                        }
                        function updateLabelMap(labelMap, label, added) {
                            labelMap[label] = labelMap[label] || 0, labelMap[label] += added ? 1 : -1
                        }
                        function render() {
                            renderScheduled = !1;
                            var optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, key, value, groupLength, length, groupIndex, index, selected, lastElement, element, label, optionId, optionGroups = {"": []}, optionGroupNames = [""], viewValue = ctrl.$viewValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, labelMap = {}, isSelected = createIsSelectedFn(viewValue), anySelected = !1;
                            for (trackKeysCache = {}, index = 0; length = keys.length, length > index; index++)
                                key = index, keyName && (key = keys[index], "$" === key.charAt(0)) || (value = values[key], optionGroupName = callExpression(groupByFn, key, value) || "", (optionGroup = optionGroups[optionGroupName]) || (optionGroup = optionGroups[optionGroupName] = [], optionGroupNames.push(optionGroupName)), selected = isSelected(key, value), anySelected = anySelected || selected, label = callExpression(displayFn, key, value), label = isDefined(label) ? label : "", optionId = trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index, trackFn && (trackKeysCache[optionId] = key), optionGroup.push({id: optionId, label: label, selected: selected}));
                            for (multiple || (nullOption || null === viewValue ? optionGroups[""].unshift({id: "", label: "", selected: !anySelected}) : anySelected || optionGroups[""].unshift({id: "?", label: "", selected: !0})), groupIndex = 0, groupLength = optionGroupNames.length; groupLength > groupIndex; groupIndex++) {
                                for (optionGroupName = optionGroupNames[groupIndex], optionGroup = optionGroups[optionGroupName], optionGroupsCache.length <= groupIndex?(existingParent = {element:optGroupTemplate.clone().attr("label", optionGroupName), label:optionGroup.label}, existingOptions = [existingParent], optionGroupsCache.push(existingOptions), selectElement.append(existingParent.element)):(existingOptions = optionGroupsCache[groupIndex], existingParent = existingOptions[0], existingParent.label != optionGroupName && existingParent.element.attr("label", existingParent.label = optionGroupName)), lastElement = null, index = 0, length = optionGroup.length; length > index; index++)
                                    option = optionGroup[index], (existingOption = existingOptions[index + 1]) ? (lastElement = existingOption.element, existingOption.label !== option.label && (updateLabelMap(labelMap, existingOption.label, !1), updateLabelMap(labelMap, option.label, !0), lastElement.text(existingOption.label = option.label), lastElement.prop("label", existingOption.label)), existingOption.id !== option.id && lastElement.val(existingOption.id = option.id), lastElement[0].selected !== option.selected && (lastElement.prop("selected", existingOption.selected = option.selected), msie && lastElement.prop("selected", existingOption.selected))) : ("" === option.id && nullOption ? element = nullOption : (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).prop("label", option.label).text(option.label), existingOptions.push(existingOption = {element: element, label: option.label, id: option.id, selected: option.selected}), updateLabelMap(labelMap, option.label, !0), lastElement ? lastElement.after(element) : existingParent.element.append(element), lastElement = element);
                                for (index++; existingOptions.length > index; )
                                    option = existingOptions.pop(), updateLabelMap(labelMap, option.label, !1), option.element.remove()
                            }
                            for (; optionGroupsCache.length > groupIndex; ) {
                                for (optionGroup = optionGroupsCache.pop(), index = 1; index < optionGroup.length; ++index)
                                    updateLabelMap(labelMap, optionGroup[index].label, !1);
                                optionGroup[0].element.remove()
                            }
                            forEach(labelMap, function (count, label) {
                                count > 0 ? selectCtrl.addOption(label) : 0 > count && selectCtrl.removeOption(label)
                            })
                        }
                        var match;
                        if (!(match = optionsExp.match(NG_OPTIONS_REGEXP)))
                            throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                        var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], selectAs = / as /.test(match[0]) && match[1], selectAsFn = selectAs ? $parse(selectAs) : null, keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null, trackKeysCache = {}, optionGroupsCache = [[{element: selectElement, label: ""}]], locals = {};
                        nullOption && ($compile(nullOption)(scope), nullOption.removeClass("ng-scope"), nullOption.remove()), selectElement.empty(), selectElement.on("change", selectionChanged), ctrl.$render = render, scope.$watchCollection(valuesFn, scheduleRendering), scope.$watchCollection(getLabels, scheduleRendering), multiple && scope.$watchCollection(function () {
                            return ctrl.$modelValue
                        }, scheduleRendering)
                    }
                    if (ctrls[1]) {
                        for (var emptyOption, selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = !1, renderScheduled = !1, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone(), i = 0, children = element.children(), ii = children.length; ii > i; i++)
                            if ("" === children[i].value) {
                                emptyOption = nullOption = children.eq(i);
                                break
                            }
                        selectCtrl.init(ngModelCtrl, nullOption, unknownOption), multiple && (ngModelCtrl.$isEmpty = function (value) {
                            return!value || 0 === value.length
                        }), optionsExp ? setupAsOptions(scope, element, ngModelCtrl) : multiple ? setupAsMultiple(scope, element, ngModelCtrl) : setupAsSingle(scope, element, ngModelCtrl, selectCtrl)
                    }
                }}
        }], optionDirective = ["$interpolate", function ($interpolate) {
            var nullSelectCtrl = {addOption: noop, removeOption: noop};
            return{restrict: "E", priority: 100, compile: function (element, attr) {
                    if (isUndefined(attr.value)) {
                        var interpolateFn = $interpolate(element.text(), !0);
                        interpolateFn || attr.$set("value", element.text())
                    }
                    return function (scope, element, attr) {
                        var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                        selectCtrl && selectCtrl.databound || (selectCtrl = nullSelectCtrl), interpolateFn ? scope.$watch(interpolateFn, function (newVal, oldVal) {
                            attr.$set("value", newVal), oldVal !== newVal && selectCtrl.removeOption(oldVal), selectCtrl.addOption(newVal, element)
                        }) : selectCtrl.addOption(attr.value, element), element.on("$destroy", function () {
                            selectCtrl.removeOption(attr.value)
                        })
                    }
                }}
        }], styleDirective = valueFn({restrict: "E", terminal: !1}), requiredDirective = function () {
        return{restrict: "A", require: "?ngModel", link: function (scope, elm, attr, ctrl) {
                ctrl && (attr.required = !0, ctrl.$validators.required = function (modelValue, viewValue) {
                    return!attr.required || !ctrl.$isEmpty(viewValue)
                }, attr.$observe("required", function () {
                    ctrl.$validate()
                }))
            }}
    }, patternDirective = function () {
        return{restrict: "A", require: "?ngModel", link: function (scope, elm, attr, ctrl) {
                if (ctrl) {
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe("pattern", function (regex) {
                        if (isString(regex) && regex.length > 0 && (regex = new RegExp("^" + regex + "$")), regex && !regex.test)
                            throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                        regexp = regex || undefined, ctrl.$validate()
                    }), ctrl.$validators.pattern = function (value) {
                        return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value)
                    }
                }
            }}
    }, maxlengthDirective = function () {
        return{restrict: "A", require: "?ngModel", link: function (scope, elm, attr, ctrl) {
                if (ctrl) {
                    var maxlength = -1;
                    attr.$observe("maxlength", function (value) {
                        var intVal = int(value);
                        maxlength = isNaN(intVal) ? -1 : intVal, ctrl.$validate()
                    }), ctrl.$validators.maxlength = function (modelValue, viewValue) {
                        return 0 > maxlength || ctrl.$isEmpty(modelValue) || viewValue.length <= maxlength
                    }
                }
            }}
    }, minlengthDirective = function () {
        return{restrict: "A", require: "?ngModel", link: function (scope, elm, attr, ctrl) {
                if (ctrl) {
                    var minlength = 0;
                    attr.$observe("minlength", function (value) {
                        minlength = int(value) || 0, ctrl.$validate()
                    }), ctrl.$validators.minlength = function (modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength
                    }
                }
            }}
    };
    return window.angular.bootstrap ? void console.log("WARNING: Tried to load angular more than once.") : (bindJQuery(), publishExternalAPI(angular), void jqLite(document).ready(function () {
        angularInit(document, bootstrap)
    }))
}(window, document), !window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}</style>'), function (window, angular, undefined) {
    "use strict";
    angular.module("ngAnimate", ["ng"]).directive("ngAnimateChildren", function () {
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        return function (scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            angular.isString(val) && 0 === val.length ? element.data(NG_ANIMATE_CHILDREN, !0) : scope.$watch(val, function (value) {
                element.data(NG_ANIMATE_CHILDREN, !!value)
            })
        }
    }).factory("$$animateReflow", ["$$rAF", "$document", function ($$rAF, $document) {
            var bod = $document[0].body;
            return function (fn) {
                return $$rAF(function () {
                    bod.offsetWidth + 1;
                    fn()
                })
            }
        }]).config(["$provide", "$animateProvider", function ($provide, $animateProvider) {
            function extractElementNode(element) {
                for (var i = 0; i < element.length; i++) {
                    var elm = element[i];
                    if (elm.nodeType == ELEMENT_NODE)
                        return elm
                }
            }
            function prepareElement(element) {
                return element && angular.element(element)
            }
            function stripCommentsFromElement(element) {
                return angular.element(extractElementNode(element))
            }
            function isMatchingElement(elm1, elm2) {
                return extractElementNode(elm1) == extractElementNode(elm2)
            }
            var $$jqLite, noop = angular.noop, forEach = angular.forEach, selectors = $animateProvider.$$selectors, isArray = angular.isArray, isString = angular.isString, isObject = angular.isObject, ELEMENT_NODE = 1, NG_ANIMATE_STATE = "$$ngAnimateState", NG_ANIMATE_CHILDREN = "$$ngAnimateChildren", NG_ANIMATE_CLASS_NAME = "ng-animate", rootAnimateState = {
                running: !0};
            $provide.decorator("$animate", ["$delegate", "$$q", "$injector", "$sniffer", "$rootElement", "$$asyncCallback", "$rootScope", "$document", "$templateRequest", "$$jqLite", function ($delegate, $$q, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope, $document, $templateRequest, $$$jqLite) {
                    function classBasedAnimationsBlocked(element, setter) {
                        var data = element.data(NG_ANIMATE_STATE) || {};
                        return setter && (data.running = !0, data.structural = !0, element.data(NG_ANIMATE_STATE, data)), data.disabled || data.running && data.structural
                    }
                    function runAnimationPostDigest(fn) {
                        var cancelFn, defer = $$q.defer();
                        return defer.promise.$$cancelFn = function () {
                            cancelFn && cancelFn()
                        }, $rootScope.$$postDigest(function () {
                            cancelFn = fn(function () {
                                defer.resolve()
                            })
                        }), defer.promise
                    }
                    function parseAnimateOptions(options) {
                        return isObject(options) ? (options.tempClasses && isString(options.tempClasses) && (options.tempClasses = options.tempClasses.split(/\s+/)), options) : void 0
                    }
                    function resolveElementClasses(element, cache, runningAnimations) {
                        runningAnimations = runningAnimations || {};
                        var lookup = {};
                        forEach(runningAnimations, function (data, selector) {
                            forEach(selector.split(" "), function (s) {
                                lookup[s] = data
                            })
                        });
                        var hasClasses = Object.create(null);
                        forEach((element.attr("class") || "").split(/\s+/), function (className) {
                            hasClasses[className] = !0
                        });
                        var toAdd = [], toRemove = [];
                        return forEach(cache && cache.classes || [], function (status, className) {
                            var hasClass = hasClasses[className], matchingAnimation = lookup[className] || {};
                            status === !1 ? (hasClass || "addClass" == matchingAnimation.event) && toRemove.push(className) : status === !0 && (hasClass && "removeClass" != matchingAnimation.event || toAdd.push(className))
                        }), toAdd.length + toRemove.length > 0 && [toAdd.join(" "), toRemove.join(" ")]
                    }
                    function lookup(name) {
                        if (name) {
                            var matches = [], flagMap = {}, classes = name.substr(1).split(".");
                            ($sniffer.transitions || $sniffer.animations) && matches.push($injector.get(selectors[""]));
                            for (var i = 0; i < classes.length; i++) {
                                var klass = classes[i], selectorFactoryName = selectors[klass];
                                selectorFactoryName && !flagMap[klass] && (matches.push($injector.get(selectorFactoryName)), flagMap[klass] = !0)
                            }
                            return matches
                        }
                    }
                    function animationRunner(element, animationEvent, className, options) {
                        function registerAnimation(animationFactory, event) {
                            var afterFn = animationFactory[event], beforeFn = animationFactory["before" + event.charAt(0).toUpperCase() + event.substr(1)];
                            return afterFn || beforeFn ? ("leave" == event && (beforeFn = afterFn, afterFn = null), after.push({event: event, fn: afterFn}), before.push({event: event, fn: beforeFn}), !0) : void 0
                        }
                        function run(fns, cancellations, allCompleteFn) {
                            function afterAnimationComplete(index) {
                                if (cancellations) {
                                    if ((cancellations[index] || noop)(), ++count < animations.length)
                                        return;
                                    cancellations = null
                                }
                                allCompleteFn()
                            }
                            var animations = [];
                            forEach(fns, function (animation) {
                                animation.fn && animations.push(animation)
                            });
                            var count = 0;
                            forEach(animations, function (animation, index) {
                                var progress = function () {
                                    afterAnimationComplete(index)
                                };
                                switch (animation.event) {
                                    case"setClass":
                                        cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress, options));
                                        break;
                                    case"animate":
                                        cancellations.push(animation.fn(element, className, options.from, options.to, progress));
                                        break;
                                    case"addClass":
                                        cancellations.push(animation.fn(element, classNameAdd || className, progress, options));
                                        break;
                                    case"removeClass":
                                        cancellations.push(animation.fn(element, classNameRemove || className, progress, options));
                                        break;
                                    default:
                                        cancellations.push(animation.fn(element, progress, options))
                                    }
                            }), cancellations && 0 === cancellations.length && allCompleteFn()
                        }
                        var node = element[0];
                        if (node) {
                            options && (options.to = options.to || {}, options.from = options.from || {});
                            var classNameAdd, classNameRemove;
                            isArray(className) && (classNameAdd = className[0], classNameRemove = className[1], classNameAdd ? classNameRemove ? className = classNameAdd + " " + classNameRemove : (className = classNameAdd, animationEvent = "addClass") : (className = classNameRemove, animationEvent = "removeClass"));
                            var isSetClassOperation = "setClass" == animationEvent, isClassBased = isSetClassOperation || "addClass" == animationEvent || "removeClass" == animationEvent || "animate" == animationEvent, currentClassName = element.attr("class"), classes = currentClassName + " " + className;
                            if (isAnimatableClassName(classes)) {
                                var beforeComplete = noop, beforeCancel = [], before = [], afterComplete = noop, afterCancel = [], after = [], animationLookup = (" " + classes).replace(/\s+/g, ".");
                                return forEach(lookup(animationLookup), function (animationFactory) {
                                    var created = registerAnimation(animationFactory, animationEvent);
                                    !created && isSetClassOperation && (registerAnimation(animationFactory, "addClass"), registerAnimation(animationFactory, "removeClass"))
                                }), {node: node, event: animationEvent, className: className, isClassBased: isClassBased, isSetClassOperation: isSetClassOperation, applyStyles: function () {
                                        options && element.css(angular.extend(options.from || {}, options.to || {}))
                                    }, before: function (allCompleteFn) {
                                        beforeComplete = allCompleteFn, run(before, beforeCancel, function () {
                                            beforeComplete = noop, allCompleteFn()
                                        })
                                    }, after: function (allCompleteFn) {
                                        afterComplete = allCompleteFn, run(after, afterCancel, function () {
                                            afterComplete = noop, allCompleteFn()
                                        })
                                    }, cancel: function () {
                                        beforeCancel && (forEach(beforeCancel, function (cancelFn) {
                                            (cancelFn || noop)(!0)
                                        }), beforeComplete(!0)), afterCancel && (forEach(afterCancel, function (cancelFn) {
                                            (cancelFn || noop)(!0)
                                        }), afterComplete(!0))
                                    }}
                            }
                        }
                    }
                    function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, options, doneCallback) {
                        function fireDOMCallback(animationPhase) {
                            var eventName = "$animate:" + animationPhase;
                            elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0 && $$asyncCallback(function () {
                                element.triggerHandler(eventName, {event: animationEvent, className: className})
                            })
                        }
                        function fireBeforeCallbackAsync() {
                            fireDOMCallback("before")
                        }
                        function fireAfterCallbackAsync() {
                            fireDOMCallback("after")
                        }
                        function fireDoneCallbackAsync() {
                            fireDOMCallback("close"), doneCallback()
                        }
                        function fireDOMOperation() {
                            fireDOMOperation.hasBeenRun || (fireDOMOperation.hasBeenRun = !0, domOperation())
                        }
                        function closeAnimation() {
                            if (!closeAnimation.hasBeenRun) {
                                runner && runner.applyStyles(), closeAnimation.hasBeenRun = !0, options && options.tempClasses && forEach(options.tempClasses, function (className) {
                                    $$jqLite.removeClass(element, className)
                                });
                                var data = element.data(NG_ANIMATE_STATE);
                                data && (runner && runner.isClassBased ? cleanup(element, className) : ($$asyncCallback(function () {
                                    var data = element.data(NG_ANIMATE_STATE) || {};
                                    localAnimationCount == data.index && cleanup(element, className, animationEvent)
                                }), element.data(NG_ANIMATE_STATE, data))), fireDoneCallbackAsync()
                            }
                        }
                        var noopCancel = noop, runner = animationRunner(element, animationEvent, className, options);
                        if (!runner)
                            return fireDOMOperation(), fireBeforeCallbackAsync(), fireAfterCallbackAsync(), closeAnimation(), noopCancel;
                        animationEvent = runner.event, className = runner.className;
                        var elementEvents = angular.element._data(runner.node);
                        if (elementEvents = elementEvents && elementEvents.events, parentElement || (parentElement = afterElement ? afterElement.parent() : element.parent()), animationsDisabled(element, parentElement))
                            return fireDOMOperation(), fireBeforeCallbackAsync(), fireAfterCallbackAsync(), closeAnimation(), noopCancel;
                        var ngAnimateState = element.data(NG_ANIMATE_STATE) || {}, runningAnimations = ngAnimateState.active || {}, totalActiveAnimations = ngAnimateState.totalActive || 0, lastAnimation = ngAnimateState.last, skipAnimation = !1;
                        if (totalActiveAnimations > 0) {
                            var animationsToCancel = [];
                            if (runner.isClassBased) {
                                if ("setClass" == lastAnimation.event)
                                    animationsToCancel.push(lastAnimation), cleanup(element, className);
                                else if (runningAnimations[className]) {
                                    var current = runningAnimations[className];
                                    current.event == animationEvent ? skipAnimation = !0 : (animationsToCancel.push(current), cleanup(element, className))
                                }
                            } else if ("leave" == animationEvent && runningAnimations["ng-leave"])
                                skipAnimation = !0;
                            else {
                                for (var klass in runningAnimations)
                                    animationsToCancel.push(runningAnimations[klass]);
                                ngAnimateState = {}, cleanup(element, !0)
                            }
                            animationsToCancel.length > 0 && forEach(animationsToCancel, function (operation) {
                                operation.cancel()
                            })
                        }
                        if (!runner.isClassBased || runner.isSetClassOperation || "animate" == animationEvent || skipAnimation || (skipAnimation = "addClass" == animationEvent == element.hasClass(className)), skipAnimation)
                            return fireDOMOperation(), fireBeforeCallbackAsync(), fireAfterCallbackAsync(), fireDoneCallbackAsync(), noopCancel;
                        runningAnimations = ngAnimateState.active || {}, totalActiveAnimations = ngAnimateState.totalActive || 0, "leave" == animationEvent && element.one("$destroy", function (e) {
                            var element = angular.element(this), state = element.data(NG_ANIMATE_STATE);
                            if (state) {
                                var activeLeaveAnimation = state.active["ng-leave"];
                                activeLeaveAnimation && (activeLeaveAnimation.cancel(), cleanup(element, "ng-leave"))
                            }
                        }), $$jqLite.addClass(element, NG_ANIMATE_CLASS_NAME), options && options.tempClasses && forEach(options.tempClasses, function (className) {
                            $$jqLite.addClass(element, className)
                        });
                        var localAnimationCount = globalAnimationCounter++;
                        return totalActiveAnimations++, runningAnimations[className] = runner, element.data(NG_ANIMATE_STATE, {last: runner, active: runningAnimations, index: localAnimationCount, totalActive: totalActiveAnimations}), fireBeforeCallbackAsync(), runner.before(function (cancelled) {
                            var data = element.data(NG_ANIMATE_STATE);
                            cancelled = cancelled || !data || !data.active[className] || runner.isClassBased && data.active[className].event != animationEvent, fireDOMOperation(), cancelled === !0 ? closeAnimation() : (fireAfterCallbackAsync(), runner.after(closeAnimation))
                        }), runner.cancel
                    }
                    function cancelChildAnimations(element) {
                        var node = extractElementNode(element);
                        if (node) {
                            var nodes = angular.isFunction(node.getElementsByClassName) ? node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) : node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME);
                            forEach(nodes, function (element) {
                                element = angular.element(element);
                                var data = element.data(NG_ANIMATE_STATE);
                                data && data.active && forEach(data.active, function (runner) {
                                    runner.cancel()
                                })
                            })
                        }
                    }
                    function cleanup(element, className) {
                        if (isMatchingElement(element, $rootElement))
                            rootAnimateState.disabled || (rootAnimateState.running = !1, rootAnimateState.structural = !1);
                        else if (className) {
                            var data = element.data(NG_ANIMATE_STATE) || {}, removeAnimations = className === !0;
                            !removeAnimations && data.active && data.active[className] && (data.totalActive--, delete data.active[className]), (removeAnimations || !data.totalActive) && ($$jqLite.removeClass(element, NG_ANIMATE_CLASS_NAME), element.removeData(NG_ANIMATE_STATE))
                        }
                    }
                    function animationsDisabled(element, parentElement) {
                        if (rootAnimateState.disabled)
                            return!0;
                        if (isMatchingElement(element, $rootElement))
                            return rootAnimateState.running;
                        var allowChildAnimations, parentRunningAnimation, hasParent;
                        do {
                            if (0 === parentElement.length)
                                break;
                            var isRoot = isMatchingElement(parentElement, $rootElement), state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE) || {};
                            if (state.disabled)
                                return!0;
                            if (isRoot && (hasParent = !0), allowChildAnimations !== !1) {
                                var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);
                                angular.isDefined(animateChildrenFlag) && (allowChildAnimations = animateChildrenFlag)
                            }
                            parentRunningAnimation = parentRunningAnimation || state.running || state.last && !state.last.isClassBased
                        } while (parentElement = parentElement.parent());
                        return!hasParent || !allowChildAnimations && parentRunningAnimation
                    }
                    $$jqLite = $$$jqLite, $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);
                    var deregisterWatch = $rootScope.$watch(function () {
                        return $templateRequest.totalPendingRequests
                    }, function (val, oldVal) {
                        0 === val && (deregisterWatch(), $rootScope.$$postDigest(function () {
                            $rootScope.$$postDigest(function () {
                                rootAnimateState.running = !1
                            })
                        }))
                    }), globalAnimationCounter = 0, classNameFilter = $animateProvider.classNameFilter(), isAnimatableClassName = classNameFilter ? function (className) {
                        return classNameFilter.test(className)
                    } : function () {
                        return!0
                    };
                    return{animate: function (element, from, to, className, options) {
                            return className = className || "ng-inline-animate", options = parseAnimateOptions(options) || {}, options.from = to ? from : null, options.to = to ? to : from, runAnimationPostDigest(function (done) {
                                return performAnimation("animate", className, stripCommentsFromElement(element), null, null, noop, options, done)
                            })
                        }, enter: function (element, parentElement, afterElement, options) {
                            return options = parseAnimateOptions(options), element = angular.element(element), parentElement = prepareElement(parentElement), afterElement = prepareElement(afterElement), classBasedAnimationsBlocked(element, !0), $delegate.enter(element, parentElement, afterElement), runAnimationPostDigest(function (done) {
                                return performAnimation("enter", "ng-enter", stripCommentsFromElement(element), parentElement, afterElement, noop, options, done)
                            })
                        }, leave: function (element, options) {
                            return options = parseAnimateOptions(options), element = angular.element(element), cancelChildAnimations(element), classBasedAnimationsBlocked(element, !0), runAnimationPostDigest(function (done) {
                                return performAnimation("leave", "ng-leave", stripCommentsFromElement(element), null, null, function () {
                                    $delegate.leave(element)
                                }, options, done)
                            })
                        }, move: function (element, parentElement, afterElement, options) {
                            return options = parseAnimateOptions(options), element = angular.element(element), parentElement = prepareElement(parentElement), afterElement = prepareElement(afterElement), cancelChildAnimations(element), classBasedAnimationsBlocked(element, !0), $delegate.move(element, parentElement, afterElement), runAnimationPostDigest(function (done) {
                                return performAnimation("move", "ng-move", stripCommentsFromElement(element), parentElement, afterElement, noop, options, done)
                            })
                        }, addClass: function (element, className, options) {
                            return this.setClass(element, className, [], options)
                        }, removeClass: function (element, className, options) {
                            return this.setClass(element, [], className, options)
                        }, setClass: function (element, add, remove, options) {
                            options = parseAnimateOptions(options);
                            var STORAGE_KEY = "$$animateClasses";
                            if (element = angular.element(element), element = stripCommentsFromElement(element), classBasedAnimationsBlocked(element))
                                return $delegate.$$setClassImmediately(element, add, remove, options);
                            var classes, cache = element.data(STORAGE_KEY), hasCache = !!cache;
                            return cache || (cache = {}, cache.classes = {}), classes = cache.classes, add = isArray(add) ? add : add.split(" "), forEach(add, function (c) {
                                c && c.length && (classes[c] = !0)
                            }), remove = isArray(remove) ? remove : remove.split(" "), forEach(remove, function (c) {
                                c && c.length && (classes[c] = !1)
                            }), hasCache ? (options && cache.options && (cache.options = angular.extend(cache.options || {}, options)), cache.promise) : (element.data(STORAGE_KEY, cache = {classes: classes, options: options}), cache.promise = runAnimationPostDigest(function (done) {
                                var parentElement = element.parent(), elementNode = extractElementNode(element), parentNode = elementNode.parentNode;
                                if (!parentNode || parentNode.$$NG_REMOVED || elementNode.$$NG_REMOVED)
                                    return void done();
                                var cache = element.data(STORAGE_KEY);
                                element.removeData(STORAGE_KEY);
                                var state = element.data(NG_ANIMATE_STATE) || {}, classes = resolveElementClasses(element, cache, state.active);
                                return classes ? performAnimation("setClass", classes, element, parentElement, null, function () {
                                    classes[0] && $delegate.$$addClassImmediately(element, classes[0]), classes[1] && $delegate.$$removeClassImmediately(element, classes[1])
                                }, cache.options, done) : done()
                            }))
                        }, cancel: function (promise) {
                            promise.$$cancelFn()
                        }, enabled: function (value, element) {
                            switch (arguments.length) {
                                case 2:
                                    if (value)
                                        cleanup(element);
                                    else {
                                        var data = element.data(NG_ANIMATE_STATE) || {};
                                        data.disabled = !0, element.data(NG_ANIMATE_STATE, data)
                                    }
                                    break;
                                case 1:
                                    rootAnimateState.disabled = !value;
                                    break;
                                default:
                                    value = !rootAnimateState.disabled
                            }
                            return!!value
                        }}
                }]), $animateProvider.register("", ["$window", "$sniffer", "$timeout", "$$animateReflow", function ($window, $sniffer, $timeout, $$animateReflow) {
                    function clearCacheAfterReflow() {
                        cancelAnimationReflow || (cancelAnimationReflow = $$animateReflow(function () {
                            animationReflowQueue = [], cancelAnimationReflow = null, lookupCache = {}
                        }))
                    }
                    function afterReflow(element, callback) {
                        cancelAnimationReflow && cancelAnimationReflow(), animationReflowQueue.push(callback), cancelAnimationReflow = $$animateReflow(function () {
                            forEach(animationReflowQueue, function (fn) {
                                fn()
                            }), animationReflowQueue = [], cancelAnimationReflow = null, lookupCache = {}
                        })
                    }
                    function animationCloseHandler(element, totalTime) {
                        var node = extractElementNode(element);
                        element = angular.element(node), animationElementQueue.push(element);
                        var futureTimestamp = Date.now() + totalTime;
                        closingTimestamp >= futureTimestamp || ($timeout.cancel(closingTimer), closingTimestamp = futureTimestamp, closingTimer = $timeout(function () {
                            closeAllAnimations(animationElementQueue), animationElementQueue = []
                        }, totalTime, !1))
                    }
                    function closeAllAnimations(elements) {
                        forEach(elements, function (element) {
                            var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                            elementData && forEach(elementData.closeAnimationFns, function (fn) {
                                fn()
                            })
                        })
                    }
                    function getElementAnimationDetails(element, cacheKey) {
                        var data = cacheKey ? lookupCache[cacheKey] : null;
                        if (!data) {
                            var transitionDuration = 0, transitionDelay = 0, animationDuration = 0, animationDelay = 0;
                            forEach(element, function (element) {
                                if (element.nodeType == ELEMENT_NODE) {
                                    var elementStyles = $window.getComputedStyle(element) || {}, transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];
                                    transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);
                                    var transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];
                                    transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);
                                    elementStyles[ANIMATION_PROP + DELAY_KEY];
                                    animationDelay = Math.max(parseMaxTime(elementStyles[ANIMATION_PROP + DELAY_KEY]), animationDelay);
                                    var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);
                                    aDuration > 0 && (aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1), animationDuration = Math.max(aDuration, animationDuration)
                                }
                            }), data = {total: 0, transitionDelay: transitionDelay, transitionDuration: transitionDuration, animationDelay: animationDelay, animationDuration: animationDuration}, cacheKey && (lookupCache[cacheKey] = data)
                        }
                        return data
                    }
                    function parseMaxTime(str) {
                        var maxValue = 0, values = isString(str) ? str.split(/\s*,\s*/) : [];
                        return forEach(values, function (value) {
                            maxValue = Math.max(parseFloat(value) || 0, maxValue)
                        }), maxValue
                    }
                    function getCacheKey(element) {
                        var parentElement = element.parent(), parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
                        return parentID || (parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter), parentID = parentCounter), parentID + "-" + extractElementNode(element).getAttribute("class")
                    }
                    function animateSetup(animationEvent, element, className, styles) {
                        var structural = ["ng-enter", "ng-leave", "ng-move"].indexOf(className) >= 0, cacheKey = getCacheKey(element), eventCacheKey = cacheKey + " " + className, itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0, stagger = {};
                        if (itemIndex > 0) {
                            var staggerClassName = className + "-stagger", staggerCacheKey = cacheKey + " " + staggerClassName, applyClasses = !lookupCache[staggerCacheKey];
                            applyClasses && $$jqLite.addClass(element, staggerClassName), stagger = getElementAnimationDetails(element, staggerCacheKey), applyClasses && $$jqLite.removeClass(element, staggerClassName)
                        }
                        $$jqLite.addClass(element, className);
                        var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {}, timings = getElementAnimationDetails(element, eventCacheKey), transitionDuration = timings.transitionDuration, animationDuration = timings.animationDuration;
                        if (structural && 0 === transitionDuration && 0 === animationDuration)
                            return $$jqLite.removeClass(element, className), !1;
                        var blockTransition = styles || structural && transitionDuration > 0, blockAnimation = animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration, closeAnimationFns = formerData.closeAnimationFns || [];
                        element.data(NG_ANIMATE_CSS_DATA_KEY, {stagger: stagger, cacheKey: eventCacheKey, running: formerData.running || 0, itemIndex: itemIndex, blockTransition: blockTransition, closeAnimationFns: closeAnimationFns});
                        var node = extractElementNode(element);
                        return blockTransition && (blockTransitions(node, !0), styles && element.css(styles)), blockAnimation && blockAnimations(node, !0), !0
                    }
                    function animateRun(animationEvent, element, className, activeAnimationComplete, styles) {
                        function onEnd() {
                            element.off(css3AnimationEvents, onAnimationProgress), $$jqLite.removeClass(element, activeClassName), $$jqLite.removeClass(element, pendingClassName), staggerTimeout && $timeout.cancel(staggerTimeout), animateClose(element, className);
                            var node = extractElementNode(element);
                            for (var i in appliedStyles)
                                node.style.removeProperty(appliedStyles[i])
                        }
                        function onAnimationProgress(event) {
                            event.stopPropagation();
                            var ev = event.originalEvent || event, timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                            Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && activeAnimationComplete()
                        }
                        var node = extractElementNode(element), elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                        if (-1 == node.getAttribute("class").indexOf(className) || !elementData)
                            return void activeAnimationComplete();
                        var activeClassName = "", pendingClassName = "";
                        forEach(className.split(" "), function (klass, i) {
                            var prefix = (i > 0 ? " " : "") + klass;
                            activeClassName += prefix + "-active", pendingClassName += prefix + "-pending"
                        });
                        var style = "", appliedStyles = [], itemIndex = elementData.itemIndex, stagger = elementData.stagger, staggerTime = 0;
                        if (itemIndex > 0) {
                            var transitionStaggerDelay = 0;
                            stagger.transitionDelay > 0 && 0 === stagger.transitionDuration && (transitionStaggerDelay = stagger.transitionDelay * itemIndex);
                            var animationStaggerDelay = 0;
                            stagger.animationDelay > 0 && 0 === stagger.animationDuration && (animationStaggerDelay = stagger.animationDelay * itemIndex, appliedStyles.push(CSS_PREFIX + "animation-play-state")), staggerTime = Math.round(100 * Math.max(transitionStaggerDelay, animationStaggerDelay)) / 100
                        }
                        staggerTime || ($$jqLite.addClass(element, activeClassName), elementData.blockTransition && blockTransitions(node, !1));
                        var eventCacheKey = elementData.cacheKey + " " + activeClassName, timings = getElementAnimationDetails(element, eventCacheKey), maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);
                        if (0 === maxDuration)
                            return $$jqLite.removeClass(element, activeClassName), animateClose(element, className), void activeAnimationComplete();
                        !staggerTime && styles && Object.keys(styles).length > 0 && (timings.transitionDuration || (element.css("transition", timings.animationDuration + "s linear all"), appliedStyles.push("transition")), element.css(styles));
                        var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay), maxDelayTime = maxDelay * ONE_SECOND;
                        if (appliedStyles.length > 0) {
                            var oldStyle = node.getAttribute("style") || "";
                            ";" !== oldStyle.charAt(oldStyle.length - 1) && (oldStyle += ";"), node.setAttribute("style", oldStyle + " " + style)
                        }
                        var staggerTimeout, startTime = Date.now(), css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT, animationTime = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER, totalTime = (staggerTime + animationTime) * ONE_SECOND;
                        return staggerTime > 0 && ($$jqLite.addClass(element, pendingClassName), staggerTimeout = $timeout(function () {
                            staggerTimeout = null, timings.transitionDuration > 0 && blockTransitions(node, !1), timings.animationDuration > 0 && blockAnimations(node, !1), $$jqLite.addClass(element, activeClassName), $$jqLite.removeClass(element, pendingClassName), styles && (0 === timings.transitionDuration && element.css("transition", timings.animationDuration + "s linear all"), element.css(styles), appliedStyles.push("transition"))
                        }, staggerTime * ONE_SECOND, !1)), element.on(css3AnimationEvents, onAnimationProgress), elementData.closeAnimationFns.push(function () {
                            onEnd(), activeAnimationComplete()
                        }), elementData.running++, animationCloseHandler(element, totalTime), onEnd
                    }
                    function blockTransitions(node, bool) {
                        node.style[TRANSITION_PROP + PROPERTY_KEY] = bool ? "none" : ""
                    }
                    function blockAnimations(node, bool) {
                        node.style[ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY] = bool ? "paused" : ""
                    }
                    function animateBefore(animationEvent, element, className, styles) {
                        return animateSetup(animationEvent, element, className, styles) ? function (cancelled) {
                            cancelled && animateClose(element, className)
                        } : void 0
                    }
                    function animateAfter(animationEvent, element, className, afterAnimationComplete, styles) {
                        return element.data(NG_ANIMATE_CSS_DATA_KEY) ? animateRun(animationEvent, element, className, afterAnimationComplete, styles) : (animateClose(element, className), void afterAnimationComplete())
                    }
                    function animate(animationEvent, element, className, animationComplete, options) {
                        var preReflowCancellation = animateBefore(animationEvent, element, className, options.from);
                        if (!preReflowCancellation)
                            return clearCacheAfterReflow(), void animationComplete();
                        var cancel = preReflowCancellation;
                        return afterReflow(element, function () {
                            cancel = animateAfter(animationEvent, element, className, animationComplete, options.to)
                        }), function (cancelled) {
                            (cancel || noop)(cancelled)
                        }
                    }
                    function animateClose(element, className) {
                        $$jqLite.removeClass(element, className);
                        var data = element.data(NG_ANIMATE_CSS_DATA_KEY);
                        data && (data.running && data.running--, data.running && 0 !== data.running || element.removeData(NG_ANIMATE_CSS_DATA_KEY))
                    }
                    function suffixClasses(classes, suffix) {
                        var className = "";
                        return classes = isArray(classes) ? classes : classes.split(/\s+/), forEach(classes, function (klass, i) {
                            klass && klass.length > 0 && (className += (i > 0 ? " " : "") + klass + suffix)
                        }), className
                    }
                    var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, CSS_PREFIX = "";
                    window.ontransitionend === undefined && window.onwebkittransitionend !== undefined ? (CSS_PREFIX = "-webkit-", TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", TRANSITIONEND_EVENT = "transitionend"), window.onanimationend === undefined && window.onwebkitanimationend !== undefined ? (CSS_PREFIX = "-webkit-", ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", ANIMATIONEND_EVENT = "animationend");
                    var cancelAnimationReflow, DURATION_KEY = "Duration", PROPERTY_KEY = "Property", DELAY_KEY = "Delay", ANIMATION_ITERATION_COUNT_KEY = "IterationCount", ANIMATION_PLAYSTATE_KEY = "PlayState", NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey", NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data", ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, CLOSING_TIME_BUFFER = 1.5, ONE_SECOND = 1e3, lookupCache = {}, parentCounter = 0, animationReflowQueue = [], closingTimer = null, closingTimestamp = 0, animationElementQueue = [];
                    return{animate: function (element, className, from, to, animationCompleted, options) {
                            return options = options || {}, options.from = from, options.to = to, animate("animate", element, className, animationCompleted, options)
                        }, enter: function (element, animationCompleted, options) {
                            return options = options || {}, animate("enter", element, "ng-enter", animationCompleted, options)
                        }, leave: function (element, animationCompleted, options) {
                            return options = options || {}, animate("leave", element, "ng-leave", animationCompleted, options)
                        }, move: function (element, animationCompleted, options) {
                            return options = options || {}, animate("move", element, "ng-move", animationCompleted, options)
                        }, beforeSetClass: function (element, add, remove, animationCompleted, options) {
                            options = options || {};
                            var className = suffixClasses(remove, "-remove") + " " + suffixClasses(add, "-add"), cancellationMethod = animateBefore("setClass", element, className, options.from);
                            return cancellationMethod ? (afterReflow(element, animationCompleted), cancellationMethod) : (clearCacheAfterReflow(), void animationCompleted())
                        }, beforeAddClass: function (element, className, animationCompleted, options) {
                            options = options || {};
                            var cancellationMethod = animateBefore("addClass", element, suffixClasses(className, "-add"), options.from);
                            return cancellationMethod ? (afterReflow(element, animationCompleted), cancellationMethod) : (clearCacheAfterReflow(), void animationCompleted())
                        }, beforeRemoveClass: function (element, className, animationCompleted, options) {
                            options = options || {};
                            var cancellationMethod = animateBefore("removeClass", element, suffixClasses(className, "-remove"), options.from);
                            return cancellationMethod ? (afterReflow(element, animationCompleted), cancellationMethod) : (clearCacheAfterReflow(), void animationCompleted())
                        }, setClass: function (element, add, remove, animationCompleted, options) {
                            options = options || {}, remove = suffixClasses(remove, "-remove"), add = suffixClasses(add, "-add");
                            var className = remove + " " + add;
                            return animateAfter("setClass", element, className, animationCompleted, options.to)
                        }, addClass: function (element, className, animationCompleted, options) {
                            return options = options || {}, animateAfter("addClass", element, suffixClasses(className, "-add"), animationCompleted, options.to)
                        }, removeClass: function (element, className, animationCompleted, options) {
                            return options = options || {}, animateAfter("removeClass", element, suffixClasses(className, "-remove"), animationCompleted, options.to)
                        }}
                }])
        }])
}(window, window.angular), function (window, angular, undefined) {
    "use strict";
    function $SanitizeProvider() {
        this.$get = ["$$sanitizeUri", function ($$sanitizeUri) {
                return function (html) {
                    var buf = [];
                    return htmlParser(html, htmlSanitizeWriter(buf, function (uri, isImage) {
                        return!/^unsafe/.test($$sanitizeUri(uri, isImage))
                    })), buf.join("")
                }
            }]
    }
    function sanitizeText(chars) {
        var buf = [], writer = htmlSanitizeWriter(buf, angular.noop);
        return writer.chars(chars), buf.join("")
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++)
            obj[items[i]] = !0;
        return obj
    }
    function htmlParser(html, handler) {
        function parseStartTag(tag, tagName, rest, unary) {
            if (tagName = angular.lowercase(tagName), blockElements[tagName])
                for (; stack.last() && inlineElements[stack.last()]; )
                    parseEndTag("", stack.last());
            optionalEndTagElements[tagName] && stack.last() == tagName && parseEndTag("", tagName), unary = voidElements[tagName] || !!unary, unary || stack.push(tagName);
            var attrs = {};
            rest.replace(ATTR_REGEXP, function (match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
                attrs[name] = decodeEntities(value)
            }), handler.start && handler.start(tagName, attrs, unary)
        }
        function parseEndTag(tag, tagName) {
            var i, pos = 0;
            if (tagName = angular.lowercase(tagName))
                for (pos = stack.length - 1; pos >= 0 && stack[pos] != tagName; pos--)
                    ;
            if (pos >= 0) {
                for (i = stack.length - 1; i >= pos; i--)
                    handler.end && handler.end(stack[i]);
                stack.length = pos
            }
        }
        "string" != typeof html && (html = null === html || "undefined" == typeof html ? "" : "" + html);
        var index, chars, match, text, stack = [], last = html;
        for (stack.last = function () {
            return stack[stack.length - 1]
        }; html; ) {
            if (text = "", chars = !0, stack.last() && specialElements[stack.last()] ? (html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"), function (all, text) {
                return text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1"), handler.chars && handler.chars(decodeEntities(text)), ""
            }), parseEndTag("", stack.last())) : (0 === html.indexOf("<!--") ? (index = html.indexOf("--", 4), index >= 0 && html.lastIndexOf("-->", index) === index && (handler.comment && handler.comment(html.substring(4, index)), html = html.substring(index + 3), chars = !1)) : DOCTYPE_REGEXP.test(html) ? (match = html.match(DOCTYPE_REGEXP), match && (html = html.replace(match[0], ""), chars = !1)) : BEGING_END_TAGE_REGEXP.test(html) ? (match = html.match(END_TAG_REGEXP), match && (html = html.substring(match[0].length), match[0].replace(END_TAG_REGEXP, parseEndTag), chars = !1)) : BEGIN_TAG_REGEXP.test(html) && (match = html.match(START_TAG_REGEXP), match ? (match[4] && (html = html.substring(match[0].length), match[0].replace(START_TAG_REGEXP, parseStartTag)), chars = !1) : (text += "<", html = html.substring(1))), chars && (index = html.indexOf("<"), text += 0 > index ? html : html.substring(0, index), html = 0 > index ? "" : html.substring(index), handler.chars && handler.chars(decodeEntities(text)))), html == last)
                throw $sanitizeMinErr("badparse", "The sanitizer was unable to parse the following block of html: {0}", html);
            last = html
        }
        parseEndTag()
    }
    function decodeEntities(value) {
        if (!value)
            return"";
        var parts = spaceRe.exec(value), spaceBefore = parts[1], spaceAfter = parts[3], content = parts[2];
        return content && (hiddenPre.innerHTML = content.replace(/</g, "&lt;"), content = "textContent"in hiddenPre ? hiddenPre.textContent : hiddenPre.innerText), spaceBefore + content + spaceAfter
    }
    function encodeEntities(value) {
        return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function (value) {
            var hi = value.charCodeAt(0), low = value.charCodeAt(1);
            return"&#" + (1024 * (hi - 55296) + (low - 56320) + 65536) + ";"
        }).replace(NON_ALPHANUMERIC_REGEXP, function (value) {
            return"&#" + value.charCodeAt(0) + ";"
        }).replace(/</g, "&lt;").replace(/>/g, "&gt;")
    }
    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = !1, out = angular.bind(buf, buf.push);
        return{start: function (tag, attrs, unary) {
                tag = angular.lowercase(tag), !ignore && specialElements[tag] && (ignore = tag), ignore || validElements[tag] !== !0 || (out("<"),
                        out(tag), angular.forEach(attrs, function (value, key) {
                    var lkey = angular.lowercase(key), isImage = "img" === tag && "src" === lkey || "background" === lkey;
                    validAttrs[lkey] !== !0 || uriAttrs[lkey] === !0 && !uriValidator(value, isImage) || (out(" "), out(key), out('="'), out(encodeEntities(value)), out('"'))
                }), out(unary ? "/>" : ">"))
            }, end: function (tag) {
                tag = angular.lowercase(tag), ignore || validElements[tag] !== !0 || (out("</"), out(tag), out(">")), tag == ignore && (ignore = !1)
            }, chars: function (chars) {
                ignore || out(encodeEntities(chars))
            }}
    }
    var $sanitizeMinErr = angular.$$minErr("$sanitize"), START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/, ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, BEGIN_TAG_REGEXP = /^</, BEGING_END_TAGE_REGEXP = /^<\//, COMMENT_REGEXP = /<!--(.*?)-->/g, DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i, CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g, voidElements = makeMap("area,br,col,hr,img,wbr"), optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = makeMap("rp,rt"), optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements), blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")), inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set,stop,svg,switch,text,title,tspan,use"), specialElements = makeMap("script,style"), validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements), uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href"), htmlAttrs = makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,target,title,type,valign,value,vspace,width"), svgAttrs = makeMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan"), validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs), hiddenPre = document.createElement("pre"), spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider), angular.module("ngSanitize").filter("linky", ["$sanitize", function ($sanitize) {
            var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/, MAILTO_REGEXP = /^mailto:/;
            return function (text, target) {
                function addText(text) {
                    text && html.push(sanitizeText(text))
                }
                function addLink(url, text) {
                    html.push("<a "), angular.isDefined(target) && html.push('target="', target, '" '), html.push('href="', url.replace(/"/g, "&quot;"), '">'), addText(text), html.push("</a>")
                }
                if (!text)
                    return text;
                for (var match, url, i, raw = text, html = []; match = raw.match(LINKY_URL_REGEXP); )
                    url = match[0], match[2] || match[4] || (url = (match[3] ? "http://" : "mailto:") + url), i = match.index, addText(raw.substr(0, i)), addLink(url, match[0].replace(MAILTO_REGEXP, "")), raw = raw.substring(i + match[0].length);
                return addText(raw), $sanitize(html.join(""))
            }
        }])
}(window, window.angular), function (window, angular, undefined) {
    "use strict";
    function isStringNumber(num) {
        return/^-?\d+\.?\d*$/.test(num.replace(/["']/g, ""))
    }
    var isDefined = angular.isDefined, isUndefined = angular.isUndefined, isNumber = angular.isNumber, isObject = angular.isObject, isArray = angular.isArray, extend = angular.extend, toJson = angular.toJson, fromJson = angular.fromJson, angularLocalStorage = angular.module("LocalStorageModule", []);
    angularLocalStorage.provider("localStorageService", function () {
        this.prefix = "ls", this.storageType = "localStorage", this.cookie = {expiry: 30, path: "/"}, this.notify = {setItem: !0, removeItem: !1}, this.setPrefix = function (prefix) {
            return this.prefix = prefix, this
        }, this.setStorageType = function (storageType) {
            return this.storageType = storageType, this
        }, this.setStorageCookie = function (exp, path) {
            return this.cookie = {expiry: exp, path: path}, this
        }, this.setStorageCookieDomain = function (domain) {
            return this.cookie.domain = domain, this
        }, this.setNotify = function (itemSet, itemRemove) {
            return this.notify = {setItem: itemSet, removeItem: itemRemove}, this
        }, this.$get = ["$rootScope", "$window", "$document", "$parse", function ($rootScope, $window, $document, $parse) {
                var webStorage, self = this, prefix = self.prefix, cookie = self.cookie, notify = self.notify, storageType = self.storageType;
                $document ? $document[0] && ($document = $document[0]) : $document = document, "." !== prefix.substr(-1) && (prefix = prefix ? prefix + "." : "");
                var deriveQualifiedKey = function (key) {
                    return prefix + key
                }, browserSupportsLocalStorage = function () {
                    try {
                        var supported = storageType in $window && null !== $window[storageType], key = deriveQualifiedKey("__" + Math.round(1e7 * Math.random()));
                        return supported && (webStorage = $window[storageType], webStorage.setItem(key, ""), webStorage.removeItem(key)), supported
                    } catch (e) {
                        return storageType = "cookie", $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), !1
                    }
                }(), addToLocalStorage = function (key, value) {
                    if (isUndefined(value) ? value = null : (isObject(value) || isArray(value) || isNumber(+value || value)) && (value = toJson(value)), !browserSupportsLocalStorage || "cookie" === self.storageType)
                        return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {key: key, newvalue: value, storageType: "cookie"}), addToCookies(key, value);
                    try {
                        (isObject(value) || isArray(value)) && (value = toJson(value)), webStorage && webStorage.setItem(deriveQualifiedKey(key), value), notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {key: key, newvalue: value, storageType: self.storageType})
                    } catch (e) {
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), addToCookies(key, value)
                    }
                    return!0
                }, getFromLocalStorage = function (key) {
                    if (!browserSupportsLocalStorage || "cookie" === self.storageType)
                        return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), getFromCookies(key);
                    var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
                    return item && "null" !== item ? "{" === item.charAt(0) || "[" === item.charAt(0) || isStringNumber(item) ? fromJson(item) : item : null
                }, removeFromLocalStorage = function (key) {
                    if (!browserSupportsLocalStorage || "cookie" === self.storageType)
                        return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {key: key, storageType: "cookie"}), removeFromCookies(key);
                    try {
                        webStorage.removeItem(deriveQualifiedKey(key)), notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {key: key, storageType: self.storageType})
                    } catch (e) {
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), removeFromCookies(key)
                    }
                    return!0
                }, getKeysForLocalStorage = function () {
                    if (!browserSupportsLocalStorage)
                        return $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), !1;
                    var prefixLength = prefix.length, keys = [];
                    for (var key in webStorage)
                        if (key.substr(0, prefixLength) === prefix)
                            try {
                                keys.push(key.substr(prefixLength))
                            } catch (e) {
                                return $rootScope.$broadcast("LocalStorageModule.notification.error", e.Description), []
                            }
                    return keys
                }, clearAllFromLocalStorage = function (regularExpression) {
                    regularExpression = regularExpression || "";
                    var tempPrefix = prefix.slice(0, -1), testRegex = new RegExp(tempPrefix + "." + regularExpression);
                    if (!browserSupportsLocalStorage || "cookie" === self.storageType)
                        return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), clearAllFromCookies();
                    var prefixLength = prefix.length;
                    for (var key in webStorage)
                        if (testRegex.test(key))
                            try {
                                removeFromLocalStorage(key.substr(prefixLength))
                            } catch (e) {
                                return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), clearAllFromCookies()
                            }
                    return!0
                }, browserSupportsCookies = function () {
                    try {
                        return $window.navigator.cookieEnabled || "cookie"in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1)
                    } catch (e) {
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), !1
                    }
                }(), addToCookies = function (key, value) {
                    if (isUndefined(value))
                        return!1;
                    if ((isArray(value) || isObject(value)) && (value = toJson(value)), !browserSupportsCookies)
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED"), !1;
                    try {
                        var expiry = "", expiryDate = new Date, cookieDomain = "";
                        if (null === value ? (expiryDate.setTime(expiryDate.getTime() + -864e5), expiry = "; expires=" + expiryDate.toGMTString(), value = "") : 0 !== cookie.expiry && (expiryDate.setTime(expiryDate.getTime() + 24 * cookie.expiry * 60 * 60 * 1e3), expiry = "; expires=" + expiryDate.toGMTString()), key) {
                            var cookiePath = "; path=" + cookie.path;
                            cookie.domain && (cookieDomain = "; domain=" + cookie.domain), $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain
                        }
                    } catch (e) {
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), !1
                    }
                    return!0
                }, getFromCookies = function (key) {
                    if (!browserSupportsCookies)
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED"), !1;
                    for (var cookies = $document.cookie && $document.cookie.split(";") || [], i = 0; i < cookies.length; i++) {
                        for (var thisCookie = cookies[i]; " " === thisCookie.charAt(0); )
                            thisCookie = thisCookie.substring(1, thisCookie.length);
                        if (0 === thisCookie.indexOf(deriveQualifiedKey(key) + "=")) {
                            var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
                            try {
                                var obj = JSON.parse(storedValues);
                                return fromJson(obj)
                            } catch (e) {
                                return storedValues
                            }
                        }
                    }
                    return null
                }, removeFromCookies = function (key) {
                    addToCookies(key, null)
                }, clearAllFromCookies = function () {
                    for (var thisCookie = null, prefixLength = prefix.length, cookies = $document.cookie.split(";"), i = 0; i < cookies.length; i++) {
                        for (thisCookie = cookies[i]; " " === thisCookie.charAt(0); )
                            thisCookie = thisCookie.substring(1, thisCookie.length);
                        var key = thisCookie.substring(prefixLength, thisCookie.indexOf("="));
                        removeFromCookies(key)
                    }
                }, getStorageType = function () {
                    return storageType
                }, bindToScope = function (scope, key, def, lsKey) {
                    lsKey = lsKey || key;
                    var value = getFromLocalStorage(lsKey);
                    return null === value && isDefined(def) ? value = def : isObject(value) && isObject(def) && (value = extend(def, value)), $parse(key).assign(scope, value), scope.$watch(key, function (newVal) {
                        addToLocalStorage(lsKey, newVal)
                    }, isObject(scope[key]))
                }, lengthOfLocalStorage = function () {
                    for (var count = 0, storage = $window[storageType], i = 0; i < storage.length; i++)
                        0 === storage.key(i).indexOf(prefix) && count++;
                    return count
                };
                return{isSupported: browserSupportsLocalStorage, getStorageType: getStorageType, set: addToLocalStorage, add: addToLocalStorage, get: getFromLocalStorage, keys: getKeysForLocalStorage, remove: removeFromLocalStorage, clearAll: clearAllFromLocalStorage, bind: bindToScope, deriveKey: deriveQualifiedKey, length: lengthOfLocalStorage, cookie: {isSupported: browserSupportsCookies, set: addToCookies, add: addToCookies, get: getFromCookies, remove: removeFromCookies, clearAll: clearAllFromCookies}}
            }]
    })
}(window, window.angular), angular.module("ui.bootstrap.transition", []).factory("$transition", ["$q", "$timeout", "$rootScope", function ($q, $timeout, $rootScope) {
        function findEndEventName(endEventNames) {
            for (var name in endEventNames)
                if (void 0 !== transElement.style[name])
                    return endEventNames[name]
        }
        var $transition = function (element, trigger, options) {
            options = options || {};
            var deferred = $q.defer(), endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"], transitionEndHandler = function (event) {
                $rootScope.$apply(function () {
                    element.unbind(endEventName, transitionEndHandler), deferred.resolve(element)
                })
            };
            return endEventName && element.bind(endEventName, transitionEndHandler), $timeout(function () {
                angular.isString(trigger) ? element.addClass(trigger) : angular.isFunction(trigger) ? trigger(element) : angular.isObject(trigger) && element.css(trigger), endEventName || deferred.resolve(element)
            }), deferred.promise.cancel = function () {
                endEventName && element.unbind(endEventName, transitionEndHandler), deferred.reject("Transition cancelled")
            }, deferred.promise
        }, transElement = document.createElement("trans"), transitionEndEventNames = {WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd", transition: "transitionend"}, animationEndEventNames = {WebkitTransition: "webkitAnimationEnd", MozTransition: "animationend", OTransition: "oAnimationEnd", transition: "animationend"};
        return $transition.transitionEndEventName = findEndEventName(transitionEndEventNames), $transition.animationEndEventName = findEndEventName(animationEndEventNames), $transition
    }]), angular.module("ui.bootstrap.modal", ["ui.bootstrap.transition"]).factory("$$stackedMap", function () {
    return{createNew: function () {
            var stack = [];
            return{add: function (key, value) {
                    stack.push({key: key, value: value})
                }, get: function (key) {
                    for (var i = 0; i < stack.length; i++)
                        if (key == stack[i].key)
                            return stack[i]
                }, keys: function () {
                    for (var keys = [], i = 0; i < stack.length; i++)
                        keys.push(stack[i].key);
                    return keys
                }, top: function () {
                    return stack[stack.length - 1]
                }, remove: function (key) {
                    for (var idx = -1, i = 0; i < stack.length; i++)
                        if (key == stack[i].key) {
                            idx = i;
                            break
                        }
                    return stack.splice(idx, 1)[0]
                }, removeTop: function () {
                    return stack.splice(stack.length - 1, 1)[0]
                }, length: function () {
                    return stack.length
                }}
        }}
}).directive("modalBackdrop", ["$timeout", function ($timeout) {
        return{restrict: "EA", replace: !0, templateUrl: "template/modal/backdrop.html", link: function (scope, element, attrs) {
                scope.backdropClass = attrs.backdropClass || "", scope.animate = !1, $timeout(function () {
                    scope.animate = !0
                })
            }}
    }]).directive("modalWindow", ["$modalStack", "$timeout", function ($modalStack, $timeout) {
        return{restrict: "EA", scope: {index: "@", animate: "="}, replace: !0, transclude: !0, templateUrl: function (tElement, tAttrs) {
                return tAttrs.templateUrl || "template/modal/window.html"
            }, link: function (scope, element, attrs) {
                element.addClass(attrs.windowClass || ""), scope.size = attrs.size, $timeout(function () {
                    scope.animate = !0, element[0].querySelectorAll("[autofocus]").length || element[0].focus()
                }), scope.close = function (evt) {
                    var modal = $modalStack.getTop();
                    modal && modal.value.backdrop && "static" != modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"))
                }
            }}
    }]).directive("modalTransclude", function () {
    return{link: function ($scope, $element, $attrs, controller, $transclude) {
            $transclude($scope.$parent, function (clone) {
                $element.empty(), $element.append(clone)
            })
        }}
}).factory("$modalStack", ["$transition", "$timeout", "$document", "$compile", "$rootScope", "$$stackedMap", function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
        function backdropIndex() {
            for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++)
                openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
            return topBackdropIndex
        }
        function removeModalWindow(modalInstance) {
            var body = $document.find("body").eq(0), modalWindow = openedWindows.get(modalInstance).value;
            openedWindows.remove(modalInstance), removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function () {
                modalWindow.modalScope.$destroy(), body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0), checkRemoveBackdrop()
            })
        }
        function checkRemoveBackdrop() {
            if (backdropDomEl && -1 == backdropIndex()) {
                var backdropScopeRef = backdropScope;
                removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {
                    backdropScopeRef.$destroy(), backdropScopeRef = null
                }), backdropDomEl = void 0, backdropScope = void 0
            }
        }
        function removeAfterAnimate(domEl, scope, emulateTime, done) {
            function afterAnimating() {
                afterAnimating.done || (afterAnimating.done = !0, domEl.remove(), done && done())
            }
            scope.animate = !1;
            var transitionEndEventName = $transition.transitionEndEventName;
            if (transitionEndEventName) {
                var timeout = $timeout(afterAnimating, emulateTime);
                domEl.bind(transitionEndEventName, function () {
                    $timeout.cancel(timeout), afterAnimating(), scope.$apply()
                })
            } else
                $timeout(afterAnimating)
        }
        var backdropDomEl, backdropScope, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), $modalStack = {};
        return $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
            backdropScope && (backdropScope.index = newBackdropIndex)
        }), $document.bind("keydown", function (evt) {
            var modal;
            27 === evt.which && (modal = openedWindows.top(), modal && modal.value.keyboard && (evt.preventDefault(), $rootScope.$apply(function () {
                $modalStack.dismiss(modal.key, "escape key press")
            })))
        }), $modalStack.open = function (modalInstance, modal) {
            openedWindows.add(modalInstance, {deferred: modal.deferred, modalScope: modal.scope, backdrop: modal.backdrop, keyboard: modal.keyboard});
            var body = $document.find("body").eq(0), currBackdropIndex = backdropIndex();
            if (currBackdropIndex >= 0 && !backdropDomEl) {
                backdropScope = $rootScope.$new(!0), backdropScope.index = currBackdropIndex;
                var angularBackgroundDomEl = angular.element("<div modal-backdrop></div>");
                angularBackgroundDomEl.attr("backdrop-class", modal.backdropClass), backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope), body.append(backdropDomEl)
            }
            var angularDomEl = angular.element("<div modal-window></div>");
            angularDomEl.attr({"template-url": modal.windowTemplateUrl, "window-class": modal.windowClass, size: modal.size, index: openedWindows.length() - 1, animate: "animate"}).html(modal.content);
            var modalDomEl = $compile(angularDomEl)(modal.scope);
            openedWindows.top().value.modalDomEl = modalDomEl, body.append(modalDomEl), body.addClass(OPENED_MODAL_CLASS)
        }, $modalStack.close = function (modalInstance, result) {
            var modalWindow = openedWindows.get(modalInstance);
            modalWindow && (modalWindow.value.deferred.resolve(result), removeModalWindow(modalInstance))
        }, $modalStack.dismiss = function (modalInstance, reason) {
            var modalWindow = openedWindows.get(modalInstance);
            modalWindow && (modalWindow.value.deferred.reject(reason), removeModalWindow(modalInstance))
        }, $modalStack.dismissAll = function (reason) {
            for (var topModal = this.getTop(); topModal; )
                this.dismiss(topModal.key, reason), topModal = this.getTop()
        }, $modalStack.getTop = function () {
            return openedWindows.top()
        }, $modalStack
    }]).provider("$modal", function () {
    var $modalProvider = {options: {backdrop: !0, keyboard: !0}, $get: ["$injector", "$rootScope", "$q", "$http", "$templateCache", "$controller", "$modalStack", function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
                function getTemplatePromise(options) {
                    return options.template ? $q.when(options.template) : $http.get(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl, {cache: $templateCache}).then(function (result) {
                        return result.data
                    })
                }
                function getResolvePromises(resolves) {
                    var promisesArr = [];
                    return angular.forEach(resolves, function (value) {
                        (angular.isFunction(value) || angular.isArray(value)) && promisesArr.push($q.when($injector.invoke(value)))
                    }), promisesArr
                }
                var $modal = {};
                return $modal.open = function (modalOptions) {
                    var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalInstance = {result: modalResultDeferred.promise, opened: modalOpenedDeferred.promise, close: function (result) {
                            $modalStack.close(modalInstance, result)
                        }, dismiss: function (reason) {
                            $modalStack.dismiss(modalInstance, reason)
                        }};
                    if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, !modalOptions.template && !modalOptions.templateUrl)
                        throw new Error("One of template or templateUrl options is required.");
                    var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
                    return templateAndResolvePromise.then(function (tplAndVars) {
                        var modalScope = (modalOptions.scope || $rootScope).$new();
                        modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss;
                        var ctrlInstance, ctrlLocals = {}, resolveIter = 1;
                        modalOptions.controller && (ctrlLocals.$scope = modalScope, ctrlLocals.$modalInstance = modalInstance, angular.forEach(modalOptions.resolve, function (value, key) {
                            ctrlLocals[key] = tplAndVars[resolveIter++]
                        }), ctrlInstance = $controller(modalOptions.controller, ctrlLocals), modalOptions.controllerAs && (modalScope[modalOptions.controllerAs] = ctrlInstance)), $modalStack.open(modalInstance, {scope: modalScope, deferred: modalResultDeferred, content: tplAndVars[0], backdrop: modalOptions.backdrop, keyboard: modalOptions.keyboard, backdropClass: modalOptions.backdropClass, windowClass: modalOptions.windowClass, windowTemplateUrl: modalOptions.windowTemplateUrl, size: modalOptions.size})
                    }, function (reason) {
                        modalResultDeferred.reject(reason)
                    }), templateAndResolvePromise.then(function () {
                        modalOpenedDeferred.resolve(!0)
                    }, function () {
                        modalOpenedDeferred.reject(!1)
                    }), modalInstance
                }, $modal
            }]};
    return $modalProvider
}), angular.module("ui.bootstrap.dropdown", []).constant("dropdownConfig", {openClass: "open"}).service("dropdownService", ["$document", function ($document) {
        var openScope = null;
        this.open = function (dropdownScope) {
            openScope || ($document.bind("click", closeDropdown), $document.bind("keydown", escapeKeyBind)), openScope && openScope !== dropdownScope && (openScope.isOpen = !1), openScope = dropdownScope
        }, this.close = function (dropdownScope) {
            openScope === dropdownScope && (openScope = null, $document.unbind("click", closeDropdown), $document.unbind("keydown", escapeKeyBind))
        };
        var closeDropdown = function (evt) {
            if (openScope) {
                var toggleElement = openScope.getToggleElement();
                evt && toggleElement && toggleElement[0].contains(evt.target) || openScope.$apply(function () {
                    openScope.isOpen = !1
                })
            }
        }, escapeKeyBind = function (evt) {
            27 === evt.which && (openScope.focusToggleElement(), closeDropdown())
        }
    }]).controller("DropdownController", ["$scope", "$attrs", "$parse", "dropdownConfig", "dropdownService", "$animate", function ($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {
        var getIsOpen, self = this, scope = $scope.$new(), openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;
        this.init = function (element) {
            self.$element = element, $attrs.isOpen && (getIsOpen = $parse($attrs.isOpen), setIsOpen = getIsOpen.assign, $scope.$watch(getIsOpen, function (value) {
                scope.isOpen = !!value
            }))
        }, this.toggle = function (open) {
            return scope.isOpen = arguments.length ? !!open : !scope.isOpen
        }, this.isOpen = function () {
            return scope.isOpen
        }, scope.getToggleElement = function () {
            return self.toggleElement
        }, scope.focusToggleElement = function () {
            self.toggleElement && self.toggleElement[0].focus()
        }, scope.$watch("isOpen", function (isOpen, wasOpen) {
            $animate[isOpen ? "addClass" : "removeClass"](self.$element, openClass), isOpen ? (scope.focusToggleElement(), dropdownService.open(scope)) : dropdownService.close(scope), setIsOpen($scope, isOpen), angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {open: !!isOpen})
        }), $scope.$on("$locationChangeSuccess", function () {
            scope.isOpen = !1
        }), $scope.$on("$destroy", function () {
            scope.$destroy()
        })
    }]).directive("dropdown", function () {
    return{controller: "DropdownController", link: function (scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init(element)
        }}
}).directive("dropdownToggle", function () {
    return{require: "?^dropdown", link: function (scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl) {
                dropdownCtrl.toggleElement = element;
                var toggleDropdown = function (event) {
                    event.preventDefault(), element.hasClass("disabled") || attrs.disabled || scope.$apply(function () {
                        dropdownCtrl.toggle()
                    })
                };
                element.bind("click", toggleDropdown), element.attr({"aria-haspopup": !0, "aria-expanded": !1}), scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
                    element.attr("aria-expanded", !!isOpen)
                }), scope.$on("$destroy", function () {
                    element.unbind("click", toggleDropdown)
                })
            }
        }}
}), angular.module("ui.bootstrap.bindHtml", []).directive("bindHtmlUnsafe", function () {
    return function (scope, element, attr) {
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe), scope.$watch(attr.bindHtmlUnsafe, function (value) {
            element.html(value || "")
        })
    }
}), angular.module("ui.bootstrap.tooltip", ["ui.bootstrap.position", "ui.bootstrap.bindHtml"]).provider("$tooltip", function () {
    function snake_case(name) {
        var regexp = /[A-Z]/g, separator = "-";
        return name.replace(regexp, function (letter, pos) {
            return(pos ? separator : "") + letter.toLowerCase()
        })
    }
    var defaultOptions = {placement: "top", animation: !0, popupDelay: 0}, triggerMap = {mouseenter: "mouseleave", click: "click", focus: "blur"}, globalOptions = {};
    this.options = function (value) {
        angular.extend(globalOptions, value)
    }, this.setTriggers = function (triggers) {
        angular.extend(triggerMap, triggers)
    }, this.$get = ["$window", "$compile", "$timeout", "$document", "$position", "$interpolate", function ($window, $compile, $timeout, $document, $position, $interpolate) {
            return function (type, prefix, defaultTriggerShow) {
                function getTriggers(trigger) {
                    var show = trigger || options.trigger || defaultTriggerShow, hide = triggerMap[show] || show;
                    return{show: show, hide: hide}
                }
                var options = angular.extend({}, defaultOptions, globalOptions), directiveName = snake_case(type), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup title="' + startSym + "title" + endSym + '" content="' + startSym + "content" + endSym + '" placement="' + startSym + "placement" + endSym + '" animation="animation" is-open="isOpen"></div>';
                return{restrict: "EA", compile: function (tElem, tAttrs) {
                        var tooltipLinker = $compile(template);
                        return function (scope, element, attrs) {
                            function toggleTooltipBind() {
                                ttScope.isOpen ? hideTooltipBind() : showTooltipBind()
                            }
                            function showTooltipBind() {
                                (!hasEnableExp || scope.$eval(attrs[prefix + "Enable"])) && (prepareTooltip(), ttScope.popupDelay ? popupTimeout || (popupTimeout = $timeout(show, ttScope.popupDelay, !1), popupTimeout.then(function (reposition) {
                                    reposition()
                                })) : show()())
                            }
                            function hideTooltipBind() {
                                scope.$apply(function () {
                                    hide()
                                })
                            }
                            function show() {
                                return popupTimeout = null, transitionTimeout && ($timeout.cancel(transitionTimeout), transitionTimeout = null), ttScope.content ? (createTooltip(), tooltip.css({top: 0, left: 0, display: "block"}), appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip), positionTooltip(), ttScope.isOpen = !0, ttScope.$digest(), positionTooltip) : angular.noop
                            }
                            function hide() {
                                ttScope.isOpen = !1, $timeout.cancel(popupTimeout), popupTimeout = null, ttScope.animation ? transitionTimeout || (transitionTimeout = $timeout(removeTooltip, 500)) : removeTooltip()
                            }
                            function createTooltip() {
                                tooltip && removeTooltip(), tooltipLinkedScope = ttScope.$new(), tooltip = tooltipLinker(tooltipLinkedScope, angular.noop)
                            }
                            function removeTooltip() {
                                transitionTimeout = null, tooltip && (tooltip.remove(), tooltip = null), tooltipLinkedScope && (tooltipLinkedScope.$destroy(), tooltipLinkedScope = null)
                            }
                            function prepareTooltip() {
                                prepPlacement(), prepPopupDelay()
                            }
                            function prepPlacement() {
                                var val = attrs[prefix + "Placement"];
                                ttScope.placement = angular.isDefined(val) ? val : options.placement
                            }
                            function prepPopupDelay() {
                                var val = attrs[prefix + "PopupDelay"], delay = parseInt(val, 10);
                                ttScope.popupDelay = isNaN(delay) ? options.popupDelay : delay
                            }
                            function prepTriggers() {
                                var val = attrs[prefix + "Trigger"];
                                unregisterTriggers(), triggers = getTriggers(val), triggers.show === triggers.hide ? element.bind(triggers.show, toggleTooltipBind) : (element.bind(triggers.show, showTooltipBind), element.bind(triggers.hide, hideTooltipBind))
                            }
                            var tooltip, tooltipLinkedScope, transitionTimeout, popupTimeout, appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : !1, triggers = getTriggers(void 0), hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), ttScope = scope.$new(!0), positionTooltip = function () {
                                var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                                ttPosition.top += "px", ttPosition.left += "px", tooltip.css(ttPosition)
                            };
                            ttScope.isOpen = !1, attrs.$observe(type, function (val) {
                                ttScope.content = val, !val && ttScope.isOpen && hide()
                            }), attrs.$observe(prefix + "Title", function (val) {
                                ttScope.title = val
                            });
                            var unregisterTriggers = function () {
                                element.unbind(triggers.show, showTooltipBind), element.unbind(triggers.hide, hideTooltipBind)
                            };
                            prepTriggers();
                            var animation = scope.$eval(attrs[prefix + "Animation"]);
                            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                            var appendToBodyVal = scope.$eval(attrs[prefix + "AppendToBody"]);
                            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody, appendToBody && scope.$on("$locationChangeSuccess", function () {
                                ttScope.isOpen && hide()
                            }), scope.$on("$destroy", function () {
                                $timeout.cancel(transitionTimeout), $timeout.cancel(popupTimeout), unregisterTriggers(), removeTooltip(), ttScope = null
                            })
                        }
                    }}
            }
        }]
}).directive("tooltipPopup", function () {
    return{restrict: "EA", replace: !0, scope: {content: "@", placement: "@", animation: "&", isOpen: "&"}, templateUrl: "template/tooltip/tooltip-popup.html"}
}).directive("tooltip", ["$tooltip", function ($tooltip) {
        return $tooltip("tooltip", "tooltip", "mouseenter")
    }]).directive("tooltipHtmlUnsafePopup", function () {
    return{restrict: "EA", replace: !0, scope: {content: "@", placement: "@", animation: "&", isOpen: "&"}, templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"}
}).directive("tooltipHtmlUnsafe", ["$tooltip", function ($tooltip) {
        return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter")
    }]), angular.module("ui.bootstrap.popover", ["ui.bootstrap.tooltip"]).directive("popoverPopup", function () {
    return{restrict: "EA", replace: !0, scope: {title: "@", content: "@", placement: "@", animation: "&", isOpen: "&"}, templateUrl: "template/popover/popover.html"}
}).directive("popover", ["$tooltip", function ($tooltip) {
        return $tooltip("popover", "popover", "click")
    }]), angular.module("ui.bootstrap.position", []).factory("$position", ["$document", "$window", function ($document, $window) {
        function getStyle(el, cssprop) {
            return el.currentStyle ? el.currentStyle[cssprop] : $window.getComputedStyle ? $window.getComputedStyle(el)[cssprop] : el.style[cssprop]
        }
        function isStaticPositioned(element) {
            return"static" === (getStyle(element, "position") || "static")
        }
        var parentOffsetEl = function (element) {
            for (var docDomEl = $document[0], offsetParent = element.offsetParent || docDomEl; offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent); )
                offsetParent = offsetParent.offsetParent;
            return offsetParent || docDomEl
        };
        return{position: function (element) {
                var elBCR = this.offset(element), offsetParentBCR = {top: 0, left: 0}, offsetParentEl = parentOffsetEl(element[0]);
                offsetParentEl != $document[0] && (offsetParentBCR = this.offset(angular.element(offsetParentEl)), offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop, offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft);
                var boundingClientRect = element[0].getBoundingClientRect();
                return{width: boundingClientRect.width || element.prop("offsetWidth"),
                    height: boundingClientRect.height || element.prop("offsetHeight"), top: elBCR.top - offsetParentBCR.top, left: elBCR.left - offsetParentBCR.left}
            }, offset: function (element) {
                var boundingClientRect = element[0].getBoundingClientRect();
                return{width: boundingClientRect.width || element.prop("offsetWidth"), height: boundingClientRect.height || element.prop("offsetHeight"), top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop), left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)}
            }, positionElements: function (hostEl, targetEl, positionStr, appendToBody) {
                var hostElPos, targetElWidth, targetElHeight, targetElPos, positionStrParts = positionStr.split("-"), pos0 = positionStrParts[0], pos1 = positionStrParts[1] || "center";
                hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl), targetElWidth = targetEl.prop("offsetWidth"), targetElHeight = targetEl.prop("offsetHeight");
                var shiftWidth = {center: function () {
                        return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2
                    }, left: function () {
                        return hostElPos.left
                    }, right: function () {
                        return hostElPos.left + hostElPos.width
                    }}, shiftHeight = {center: function () {
                        return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2
                    }, top: function () {
                        return hostElPos.top
                    }, bottom: function () {
                        return hostElPos.top + hostElPos.height
                    }};
                switch (pos0) {
                    case"right":
                        targetElPos = {top: shiftHeight[pos1](), left: shiftWidth[pos0]()};
                        break;
                    case"left":
                        targetElPos = {top: shiftHeight[pos1](), left: hostElPos.left - targetElWidth};
                        break;
                    case"bottom":
                        targetElPos = {top: shiftHeight[pos0](), left: shiftWidth[pos1]()};
                        break;
                    default:
                        targetElPos = {top: hostElPos.top - targetElHeight, left: shiftWidth[pos1]()}
                }
                return targetElPos
            }}
    }]), angular.module("ui.bootstrap.tabs", []).controller("TabsetController", ["$scope", function ($scope) {
        var ctrl = this, tabs = ctrl.tabs = $scope.tabs = [];
        ctrl.select = function (selectedTab) {
            angular.forEach(tabs, function (tab) {
                tab.active && tab !== selectedTab && (tab.active = !1, tab.onDeselect())
            }), selectedTab.active = !0, selectedTab.onSelect()
        }, ctrl.addTab = function (tab) {
            tabs.push(tab), 1 === tabs.length ? tab.active = !0 : tab.active && ctrl.select(tab)
        }, ctrl.removeTab = function (tab) {
            var index = tabs.indexOf(tab);
            if (tab.active && tabs.length > 1 && !destroyed) {
                var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
                ctrl.select(tabs[newActiveIndex])
            }
            tabs.splice(index, 1)
        };
        var destroyed;
        $scope.$on("$destroy", function () {
            destroyed = !0
        })
    }]).directive("tabset", function () {
    return{restrict: "EA", transclude: !0, replace: !0, scope: {type: "@"}, controller: "TabsetController", templateUrl: "template/tabs/tabset.html", link: function (scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : !1, scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : !1
        }}
}).directive("tab", ["$parse", function ($parse) {
        return{require: "^tabset", restrict: "EA", replace: !0, templateUrl: "template/tabs/tab.html", transclude: !0, scope: {active: "=?", heading: "@", onSelect: "&select", onDeselect: "&deselect"}, controller: function () {
            }, compile: function (elm, attrs, transclude) {
                return function (scope, elm, attrs, tabsetCtrl) {
                    scope.$watch("active", function (active) {
                        active && tabsetCtrl.select(scope)
                    }), scope.disabled = !1, attrs.disabled && scope.$parent.$watch($parse(attrs.disabled), function (value) {
                        scope.disabled = !!value
                    }), scope.select = function () {
                        scope.disabled || (scope.active = !0)
                    }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function () {
                        tabsetCtrl.removeTab(scope)
                    }), scope.$transcludeFn = transclude
                }
            }}
    }]).directive("tabHeadingTransclude", [function () {
        return{restrict: "A", require: "^tab", link: function (scope, elm, attrs, tabCtrl) {
                scope.$watch("headingElement", function (heading) {
                    heading && (elm.html(""), elm.append(heading))
                })
            }}
    }]).directive("tabContentTransclude", function () {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || "tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase())
    }
    return{restrict: "A", require: "^tabset", link: function (scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude);
            tab.$transcludeFn(tab.$parent, function (contents) {
                angular.forEach(contents, function (node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node)
                })
            })
        }}
}), angular.module("ui.bootstrap.carousel", ["ui.bootstrap.transition"]).controller("CarouselController", ["$scope", "$timeout", "$interval", "$transition", function ($scope, $timeout, $interval, $transition) {
        function restartTimer() {
            resetTimer();
            var interval = +$scope.interval;
            !isNaN(interval) && interval > 0 && (currentInterval = $interval(timerFn, interval))
        }
        function resetTimer() {
            currentInterval && ($interval.cancel(currentInterval), currentInterval = null)
        }
        function timerFn() {
            var interval = +$scope.interval;
            isPlaying && !isNaN(interval) && interval > 0 ? $scope.next() : $scope.pause()
        }
        var currentInterval, isPlaying, self = this, slides = self.slides = $scope.slides = [], currentIndex = -1;
        self.currentSlide = null;
        var destroyed = !1;
        self.select = $scope.select = function (nextSlide, direction) {
            function goNext() {
                if (!destroyed) {
                    if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
                        nextSlide.$element.addClass(direction);
                        nextSlide.$element[0].offsetWidth;
                        angular.forEach(slides, function (slide) {
                            angular.extend(slide, {direction: "", entering: !1, leaving: !1, active: !1})
                        }), angular.extend(nextSlide, {direction: direction, active: !0, entering: !0}), angular.extend(self.currentSlide || {}, {direction: direction, leaving: !0}), $scope.$currentTransition = $transition(nextSlide.$element, {}), function (next, current) {
                            $scope.$currentTransition.then(function () {
                                transitionDone(next, current)
                            }, function () {
                                transitionDone(next, current)
                            })
                        }(nextSlide, self.currentSlide)
                    } else
                        transitionDone(nextSlide, self.currentSlide);
                    self.currentSlide = nextSlide, currentIndex = nextIndex, restartTimer()
                }
            }
            function transitionDone(next, current) {
                angular.extend(next, {direction: "", active: !0, leaving: !1, entering: !1}), angular.extend(current || {}, {direction: "", active: !1, leaving: !1, entering: !1}), $scope.$currentTransition = null
            }
            var nextIndex = slides.indexOf(nextSlide);
            void 0 === direction && (direction = nextIndex > currentIndex ? "next" : "prev"), nextSlide && nextSlide !== self.currentSlide && ($scope.$currentTransition ? ($scope.$currentTransition.cancel(), $timeout(goNext)) : goNext())
        }, $scope.$on("$destroy", function () {
            destroyed = !0
        }), self.indexOfSlide = function (slide) {
            return slides.indexOf(slide)
        }, $scope.next = function () {
            var newIndex = (currentIndex + 1) % slides.length;
            return $scope.$currentTransition ? void 0 : self.select(slides[newIndex], "next")
        }, $scope.prev = function () {
            var newIndex = 0 > currentIndex - 1 ? slides.length - 1 : currentIndex - 1;
            return $scope.$currentTransition ? void 0 : self.select(slides[newIndex], "prev")
        }, $scope.isActive = function (slide) {
            return self.currentSlide === slide
        }, $scope.$watch("interval", restartTimer), $scope.$on("$destroy", resetTimer), $scope.play = function () {
            isPlaying || (isPlaying = !0, restartTimer())
        }, $scope.pause = function () {
            $scope.noPause || (isPlaying = !1, resetTimer())
        }, self.addSlide = function (slide, element) {
            slide.$element = element, slides.push(slide), 1 === slides.length || slide.active ? (self.select(slides[slides.length - 1]), 1 == slides.length && $scope.play()) : slide.active = !1
        }, self.removeSlide = function (slide) {
            var index = slides.indexOf(slide);
            slides.splice(index, 1), slides.length > 0 && slide.active ? index >= slides.length ? self.select(slides[index - 1]) : self.select(slides[index]) : currentIndex > index && currentIndex--
        }
    }]).directive("carousel", [function () {
        return{restrict: "EA", transclude: !0, replace: !0, controller: "CarouselController", require: "carousel", templateUrl: "template/carousel/carousel.html", scope: {interval: "=", noTransition: "=", noPause: "="}}
    }]).directive("slide", function () {
    return{require: "^carousel", restrict: "EA", transclude: !0, replace: !0, templateUrl: "template/carousel/slide.html", scope: {active: "=?"}, link: function (scope, element, attrs, carouselCtrl) {
            carouselCtrl.addSlide(scope, element), scope.$on("$destroy", function () {
                carouselCtrl.removeSlide(scope)
            }), scope.$watch("active", function (active) {
                active && carouselCtrl.select(scope)
            })
        }}
}), function (window, angular, undefined) {
    "use strict";
    angular.module("ui.sortable", []).value("uiSortableConfig", {}).directive("uiSortable", ["uiSortableConfig", "$timeout", "$log", function (uiSortableConfig, $timeout, $log) {
            return{require: "?ngModel", scope: {ngModel: "=", uiSortable: "="}, link: function (scope, element, attrs, ngModel) {
                    function combineCallbacks(first, second) {
                        return second && "function" == typeof second ? function (e, ui) {
                            first(e, ui), second(e, ui)
                        } : first
                    }
                    function getSortableWidgetInstance(element) {
                        var data = element.data("ui-sortable");
                        return data && "object" == typeof data && "ui-sortable" === data.widgetFullName ? data : null
                    }
                    function hasSortingHelper(element, ui) {
                        var helperOption = element.sortable("option", "helper");
                        return"clone" === helperOption || "function" == typeof helperOption && ui.item.sortable.isCustomHelperUsed()
                    }
                    function isFloating(item) {
                        return/left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"))
                    }
                    function getElementScope(elementScopes, element) {
                        for (var result = null, i = 0; i < elementScopes.length; i++) {
                            var x = elementScopes[i];
                            if (x.element[0] === element[0]) {
                                result = x.scope;
                                break
                            }
                        }
                        return result
                    }
                    function afterStop(e, ui) {
                        ui.item.sortable._destroy()
                    }
                    var savedNodes, opts = {}, directiveOpts = {"ui-floating": undefined}, callbacks = {receive: null, remove: null, start: null, stop: null, update: null}, wrappers = {helper: null};
                    return angular.extend(opts, directiveOpts, uiSortableConfig, scope.uiSortable), angular.element.fn && angular.element.fn.jquery ? (ngModel ? (scope.$watch("ngModel.length", function () {
                        $timeout(function () {
                            getSortableWidgetInstance(element) && element.sortable("refresh")
                        }, 0, !1)
                    }), callbacks.start = function (e, ui) {
                        if ("auto" === opts["ui-floating"]) {
                            var siblings = ui.item.siblings(), sortableWidgetInstance = getSortableWidgetInstance(angular.element(e.target));
                            sortableWidgetInstance.floating = isFloating(siblings)
                        }
                        ui.item.sortable = {model: ngModel.$modelValue[ui.item.index()], index: ui.item.index(), source: ui.item.parent(), sourceModel: ngModel.$modelValue, cancel: function () {
                                ui.item.sortable._isCanceled = !0
                            }, isCanceled: function () {
                                return ui.item.sortable._isCanceled
                            }, isCustomHelperUsed: function () {
                                return!!ui.item.sortable._isCustomHelperUsed
                            }, _isCanceled: !1, _isCustomHelperUsed: ui.item.sortable._isCustomHelperUsed, _destroy: function () {
                                angular.forEach(ui.item.sortable, function (value, key) {
                                    ui.item.sortable[key] = undefined
                                })
                            }}
                    }, callbacks.activate = function (e, ui) {
                        savedNodes = element.contents();
                        var placeholder = element.sortable("option", "placeholder");
                        if (placeholder && placeholder.element && "function" == typeof placeholder.element) {
                            var phElement = placeholder.element();
                            phElement = angular.element(phElement);
                            var excludes = element.find('[class="' + phElement.attr("class") + '"]:not([ng-repeat], [data-ng-repeat])');
                            savedNodes = savedNodes.not(excludes)
                        }
                        var connectedSortables = ui.item.sortable._connectedSortables || [];
                        connectedSortables.push({element: element, scope: scope}), ui.item.sortable._connectedSortables = connectedSortables
                    }, callbacks.update = function (e, ui) {
                        if (!ui.item.sortable.received) {
                            ui.item.sortable.dropindex = ui.item.index();
                            var droptarget = ui.item.parent();
                            ui.item.sortable.droptarget = droptarget;
                            var droptargetScope = getElementScope(ui.item.sortable._connectedSortables, droptarget);
                            ui.item.sortable.droptargetModel = droptargetScope.ngModel, element.sortable("cancel")
                        }
                        hasSortingHelper(element, ui) && !ui.item.sortable.received && "parent" === element.sortable("option", "appendTo") && (savedNodes = savedNodes.not(savedNodes.last())), savedNodes.appendTo(element), ui.item.sortable.received && (savedNodes = null), ui.item.sortable.received && !ui.item.sortable.isCanceled() && scope.$apply(function () {
                            ngModel.$modelValue.splice(ui.item.sortable.dropindex, 0, ui.item.sortable.moved)
                        })
                    }, callbacks.stop = function (e, ui) {
                        !ui.item.sortable.received && "dropindex"in ui.item.sortable && !ui.item.sortable.isCanceled() ? scope.$apply(function () {
                            ngModel.$modelValue.splice(ui.item.sortable.dropindex, 0, ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0])
                        }) : "dropindex"in ui.item.sortable && !ui.item.sortable.isCanceled() || hasSortingHelper(element, ui) || savedNodes.appendTo(element), savedNodes = null
                    }, callbacks.receive = function (e, ui) {
                        ui.item.sortable.received = !0
                    }, callbacks.remove = function (e, ui) {
                        "dropindex"in ui.item.sortable || (element.sortable("cancel"), ui.item.sortable.cancel()), ui.item.sortable.isCanceled() || scope.$apply(function () {
                            ui.item.sortable.moved = ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0]
                        })
                    }, wrappers.helper = function (inner) {
                        return inner && "function" == typeof inner ? function (e, item) {
                            var innerResult = inner(e, item);
                            return item.sortable._isCustomHelperUsed = item !== innerResult, innerResult
                        } : inner
                    }, scope.$watch("uiSortable", function (newVal) {
                        var sortableWidgetInstance = getSortableWidgetInstance(element);
                        sortableWidgetInstance && angular.forEach(newVal, function (value, key) {
                            return key in directiveOpts ? ("ui-floating" !== key || value !== !1 && value !== !0 || (sortableWidgetInstance.floating = value), void(opts[key] = value)) : (callbacks[key] ? ("stop" === key && (value = combineCallbacks(value, function () {
                                scope.$apply()
                            }), value = combineCallbacks(value, afterStop)), value = combineCallbacks(callbacks[key], value)) : wrappers[key] && (value = wrappers[key](value)), opts[key] = value, void element.sortable("option", key, value))
                        })
                    }, !0), angular.forEach(callbacks, function (value, key) {
                        opts[key] = combineCallbacks(value, opts[key]), "stop" === key && (opts[key] = combineCallbacks(opts[key], afterStop))
                    })) : $log.info("ui.sortable: ngModel not provided!", element), void element.sortable(opts)) : void $log.error("ui.sortable: jQuery should be included before AngularJS!")
                }}
        }])
}(window, window.angular), function (mod) {
    if ("object" == typeof exports && "object" == typeof module)
        module.exports = mod();
    else {
        if ("function" == typeof define && define.amd)
            return define([], mod);
        this.CodeMirror = mod()
    }
}(function () {
    "use strict";
    function CodeMirror(place, options) {
        if (!(this instanceof CodeMirror))
            return new CodeMirror(place, options);
        this.options = options = options ? copyObj(options) : {}, copyObj(defaults, options, !1), setGuttersForLineNumbers(options);
        var doc = options.value;
        "string" == typeof doc && (doc = new Doc(doc, options.mode)), this.doc = doc;
        var display = this.display = new Display(place, doc);
        display.wrapper.CodeMirror = this, updateGutters(this), themeChanged(this), options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), options.autofocus && !mobile && focusInput(this), initScrollbars(this), this.state = {keyMaps: [], overlays: [], modeGen: 0, overwrite: !1, focused: !1, suppressEdits: !1, pasteIncoming: !1, cutIncoming: !1, draggingText: !1, highlight: new Delayed, keySeq: null}, ie && 11 > ie_version && setTimeout(bind(resetInput, this, !0), 20), registerEventHandlers(this), ensureGlobalHandlers(), startOperation(this), this.curOp.forceUpdate = !0, attachDoc(this, doc), options.autofocus && !mobile || activeElt() == display.input ? setTimeout(bind(onFocus, this), 20) : onBlur(this);
        for (var opt in optionHandlers)
            optionHandlers.hasOwnProperty(opt) && optionHandlers[opt](this, options[opt], Init);
        maybeUpdateLineNumberWidth(this);
        for (var i = 0; i < initHooks.length; ++i)
            initHooks[i](this);
        endOperation(this)
    }
    function Display(place, doc) {
        var d = this, input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
        webkit ? input.style.width = "1000px" : input.setAttribute("wrap", "off"), ios && (input.style.border = "1px solid black"), input.setAttribute("autocorrect", "off"), input.setAttribute("autocapitalize", "off"), input.setAttribute("spellcheck", "false"), d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"), d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler"), d.scrollbarFiller.setAttribute("not-content", "true"), d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler"), d.gutterFiller.setAttribute("not-content", "true"), d.lineDiv = elt("div", null, "CodeMirror-code"), d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1"), d.cursorDiv = elt("div", null, "CodeMirror-cursors"), d.measure = elt("div", null, "CodeMirror-measure"), d.lineMeasure = elt("div", null, "CodeMirror-measure"), d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none"), d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative"), d.sizer = elt("div", [d.mover], "CodeMirror-sizer"), d.sizerWidth = null, d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"), d.gutters = elt("div", null, "CodeMirror-gutters"), d.lineGutter = null, d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll"), d.scroller.setAttribute("tabIndex", "-1"), d.wrapper = elt("div", [d.inputDiv, d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror"), ie && 8 > ie_version && (d.gutters.style.zIndex = -1, d.scroller.style.paddingRight = 0), ios && (input.style.width = "0px"), webkit || (d.scroller.draggable = !0), khtml && (d.inputDiv.style.height = "1px", d.inputDiv.style.position = "absolute"), place && (place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper)), d.viewFrom = d.viewTo = doc.first, d.reportedViewFrom = d.reportedViewTo = doc.first, d.view = [], d.renderedView = null, d.externalMeasured = null, d.viewOffset = 0, d.lastWrapHeight = d.lastWrapWidth = 0, d.updateLineNumbers = null, d.nativeBarWidth = d.barHeight = d.barWidth = 0, d.scrollbarsClipped = !1, d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null, d.prevInput = "", d.alignWidgets = !1, d.pollingFast = !1, d.poll = new Delayed, d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, d.inaccurateSelection = !1, d.maxLine = null, d.maxLineLength = 0, d.maxLineChanged = !1, d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null, d.shift = !1, d.selForContextMenu = null
    }
    function loadMode(cm) {
        cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption), resetModeState(cm)
    }
    function resetModeState(cm) {
        cm.doc.iter(function (line) {
            line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null)
        }), cm.doc.frontier = cm.doc.first, startWorker(cm, 100), cm.state.modeGen++, cm.curOp && regChange(cm)
    }
    function wrappingChanged(cm) {
        cm.options.lineWrapping ? (addClass(cm.display.wrapper, "CodeMirror-wrap"), cm.display.sizer.style.minWidth = "", cm.display.sizerWidth = null) : (rmClass(cm.display.wrapper, "CodeMirror-wrap"), findMaxLine(cm)), estimateLineHeights(cm), regChange(cm), clearCaches(cm), setTimeout(function () {
            updateScrollbars(cm)
        }, 100)
    }
    function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping, perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function (line) {
            if (lineIsHidden(cm.doc, line))
                return 0;
            var widgetsHeight = 0;
            if (line.widgets)
                for (var i = 0; i < line.widgets.length; i++)
                    line.widgets[i].height && (widgetsHeight += line.widgets[i].height);
            return wrapping ? widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th : widgetsHeight + th
        }
    }
    function estimateLineHeights(cm) {
        var doc = cm.doc, est = estimateHeight(cm);
        doc.iter(function (line) {
            var estHeight = est(line);
            estHeight != line.height && updateLineHeight(line, estHeight)
        })
    }
    function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), clearCaches(cm)
    }
    function guttersChanged(cm) {
        updateGutters(cm), regChange(cm), setTimeout(function () {
            alignHorizontally(cm)
        }, 20)
    }
    function updateGutters(cm) {
        var gutters = cm.display.gutters, specs = cm.options.gutters;
        removeChildren(gutters);
        for (var i = 0; i < specs.length; ++i) {
            var gutterClass = specs[i], gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
            "CodeMirror-linenumbers" == gutterClass && (cm.display.lineGutter = gElt, gElt.style.width = (cm.display.lineNumWidth || 1) + "px")
        }
        gutters.style.display = i ? "" : "none", updateGutterSpace(cm)
    }
    function updateGutterSpace(cm) {
        var width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + "px"
    }
    function lineLength(line) {
        if (0 == line.height)
            return 0;
        for (var merged, len = line.text.length, cur = line; merged = collapsedSpanAtStart(cur); ) {
            var found = merged.find(0, !0);
            cur = found.from.line, len += found.from.ch - found.to.ch
        }
        for (cur = line; merged = collapsedSpanAtEnd(cur); ) {
            var found = merged.find(0, !0);
            len -= cur.text.length - found.from.ch, cur = found.to.line, len += cur.text.length - found.to.ch
        }
        return len
    }
    function findMaxLine(cm) {
        var d = cm.display, doc = cm.doc;
        d.maxLine = getLine(doc, doc.first), d.maxLineLength = lineLength(d.maxLine), d.maxLineChanged = !0, doc.iter(function (line) {
            var len = lineLength(line);
            len > d.maxLineLength && (d.maxLineLength = len, d.maxLine = line)
        })
    }
    function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, "CodeMirror-linenumbers");
        -1 == found && options.lineNumbers ? options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]) : found > -1 && !options.lineNumbers && (options.gutters = options.gutters.slice(0), options.gutters.splice(found, 1))
    }
    function measureForScrollbars(cm) {
        var d = cm.display, gutterW = d.gutters.offsetWidth, docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return{clientHeight: d.scroller.clientHeight, viewHeight: d.wrapper.clientHeight, scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth, viewWidth: d.wrapper.clientWidth, barLeft: cm.options.fixedGutter ? gutterW : 0, docHeight: docH, scrollHeight: docH + scrollGap(cm) + d.barHeight, nativeBarWidth: d.nativeBarWidth, gutterWidth: gutterW}
    }
    function NativeScrollbars(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        place(vert), place(horiz), on(vert, "scroll", function () {
            vert.clientHeight && scroll(vert.scrollTop, "vertical")
        }), on(horiz, "scroll", function () {
            horiz.clientWidth && scroll(horiz.scrollLeft, "horizontal")
        }), this.checkedOverlay = !1, ie && 8 > ie_version && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px")
    }
    function NullScrollbars() {
    }
    function initScrollbars(cm) {
        cm.display.scrollbars && (cm.display.scrollbars.clear(), cm.display.scrollbars.addClass && rmClass(cm.display.wrapper, cm.display.scrollbars.addClass)), cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function (node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller), on(node, "mousedown", function () {
                cm.state.focused && setTimeout(bind(focusInput, cm), 0)
            }), node.setAttribute("not-content", "true")
        }, function (pos, axis) {
            "horizontal" == axis ? setScrollLeft(cm, pos) : setScrollTop(cm, pos)
        }, cm), cm.display.scrollbars.addClass && addClass(cm.display.wrapper, cm.display.scrollbars.addClass)
    }
    function updateScrollbars(cm, measure) {
        measure || (measure = measureForScrollbars(cm));
        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i = 0; 4 > i && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++)
            startWidth != cm.display.barWidth && cm.options.lineWrapping && updateHeightsInViewport(cm), updateScrollbarsInner(cm, measureForScrollbars(cm)), startWidth = cm.display.barWidth, startHeight = cm.display.barHeight
    }
    function updateScrollbarsInner(cm, measure) {
        var d = cm.display, sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px", d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px", sizes.right && sizes.bottom ? (d.scrollbarFiller.style.display = "block", d.scrollbarFiller.style.height = sizes.bottom + "px", d.scrollbarFiller.style.width = sizes.right + "px") : d.scrollbarFiller.style.display = "", sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter ? (d.gutterFiller.style.display = "block", d.gutterFiller.style.height = sizes.bottom + "px", d.gutterFiller.style.width = measure.gutterWidth + "px") : d.gutterFiller.style.display = ""
    }
    function visibleLines(display, doc, viewport) {
        var top = viewport && null != viewport.top ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && null != viewport.bottom ? viewport.bottom : top + display.wrapper.clientHeight, from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
            from > ensureFrom ? (from = ensureFrom, to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)) : Math.min(ensureTo, doc.lastLine()) >= to && (from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight), to = ensureTo)
        }
        return{from: from, to: Math.max(to, from + 1)}
    }
    function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (display.alignWidgets || display.gutters.firstChild && cm.options.fixedGutter) {
            for (var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft, gutterW = display.gutters.offsetWidth, left = comp + "px", i = 0; i < view.length; i++)
                if (!view[i].hidden) {
                    cm.options.fixedGutter && view[i].gutter && (view[i].gutter.style.left = left);
                    var align = view[i].alignable;
                    if (align)
                        for (var j = 0; j < align.length; j++)
                            align[j].style.left = left
                }
            cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px")
        }
    }
    function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers)
            return!1;
        var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt")), innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            return display.lineGutter.style.width = "", display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding), display.lineNumWidth = display.lineNumInnerWidth + padding, display.lineNumChars = display.lineNumInnerWidth ? last.length : -1, display.lineGutter.style.width = display.lineNumWidth + "px", updateGutterSpace(cm), !0
        }
        return!1
    }
    function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber))
    }
    function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
    }
    function DisplayUpdate(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport, this.visible = visibleLines(display, cm.doc, viewport), this.editorIsHidden = !display.wrapper.offsetWidth, this.wrapperHeight = display.wrapper.clientHeight, this.wrapperWidth = display.wrapper.clientWidth, this.oldDisplayWidth = displayWidth(cm), this.force = force, this.dims = getDimensions(cm)
    }
    function maybeClipScrollbars(cm) {
        var display = cm.display;
        !display.scrollbarsClipped && display.scroller.offsetWidth && (display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth, display.heightForcer.style.height = scrollGap(cm) + "px", display.sizer.style.marginBottom = -display.nativeBarWidth + "px", display.sizer.style.borderRightWidth = scrollGap(cm) + "px", display.scrollbarsClipped = !0)
    }
    function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc = cm.doc;
        if (update.editorIsHidden)
            return resetView(cm), !1;
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && 0 == countDirtyView(cm))
            return!1;
        maybeUpdateLineNumberWidth(cm) && (resetView(cm), update.dims = getDimensions(cm));
        var end = doc.first + doc.size, from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first), to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        display.viewFrom < from && from - display.viewFrom < 20 && (from = Math.max(doc.first, display.viewFrom)), display.viewTo > to && display.viewTo - to < 20 && (to = Math.min(end, display.viewTo)), sawCollapsedSpans && (from = visualLineNo(cm.doc, from), to = visualLineEndNo(cm.doc, to));
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to), display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom)), cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && 0 == toUpdate && !update.force && display.renderedView == display.view && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo))
            return!1;
        var focused = activeElt();
        return toUpdate > 4 && (display.lineDiv.style.display = "none"), patchDisplay(cm, display.updateLineNumbers, update.dims), toUpdate > 4 && (display.lineDiv.style.display = ""), display.renderedView = display.view, focused && activeElt() != focused && focused.offsetHeight && focused.focus(), removeChildren(display.cursorDiv), removeChildren(display.selectionDiv), display.gutters.style.height = 0, different && (display.lastWrapHeight = update.wrapperHeight, display.lastWrapWidth = update.wrapperWidth, startWorker(cm, 400)), display.updateLineNumbers = null, !0
    }
    function postUpdateDisplay(cm, update) {
        for (var force = update.force, viewport = update.viewport, first = !0; ; first = !1) {
            if (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm))
                force = !0;
            else if (force = !1, viewport && null != viewport.top && (viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}), update.visible = visibleLines(cm.display, cm.doc, viewport), update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
                break;
            if (!updateDisplayIfNeeded(cm, update))
                break;
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm), setDocumentHeight(cm, barMeasure), updateScrollbars(cm, barMeasure)
        }
        signalLater(cm, "update", cm), (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) && (signalLater(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo), cm.display.reportedViewFrom = cm.display.viewFrom, cm.display.reportedViewTo = cm.display.viewTo)
    }
    function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm), postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm), setDocumentHeight(cm, barMeasure), updateScrollbars(cm, barMeasure)
        }
    }
    function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        var total = measure.docHeight + cm.display.barHeight;
        cm.display.heightForcer.style.top = total + "px", cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + "px"
    }
    function updateHeightsInViewport(cm) {
        for (var display = cm.display, prevBottom = display.lineDiv.offsetTop, i = 0; i < display.view.length; i++) {
            var height, cur = display.view[i];
            if (!cur.hidden) {
                if (ie && 8 > ie_version) {
                    var bot = cur.node.offsetTop + cur.node.offsetHeight;
                    height = bot - prevBottom, prevBottom = bot
                } else {
                    var box = cur.node.getBoundingClientRect();
                    height = box.bottom - box.top
                }
                var diff = cur.line.height - height;
                if (2 > height && (height = textHeight(display)), (diff > .001 || -.001 > diff) && (updateLineHeight(cur.line, height), updateWidgetHeight(cur.line), cur.rest))
                    for (var j = 0; j < cur.rest.length; j++)
                        updateWidgetHeight(cur.rest[j])
            }
        }
    }
    function updateWidgetHeight(line) {
        if (line.widgets)
            for (var i = 0; i < line.widgets.length; ++i)
                line.widgets[i].height = line.widgets[i].node.offsetHeight
    }
    function getDimensions(cm) {
        for (var d = cm.display, left = {}, width = {}, gutterLeft = d.gutters.clientLeft, n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i)
            left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft, width[cm.options.gutters[i]] = n.clientWidth;
        return{fixedPos: compensateForHScroll(d), gutterTotalWidth: d.gutters.offsetWidth, gutterLeft: left, gutterWidth: width, wrapperWidth: d.wrapper.clientWidth}
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
        function rm(node) {
            var next = node.nextSibling;
            return webkit && mac && cm.display.currentWheelTarget == node ? node.style.display = "none" : node.parentNode.removeChild(node), next
        }
        for (var display = cm.display, lineNumbers = cm.options.lineNumbers, container = display.lineDiv, cur = container.firstChild, view = display.view, lineN = display.viewFrom, i = 0; i < view.length; i++) {
            var lineView = view[i];
            if (lineView.hidden)
                ;
            else if (lineView.node) {
                for (; cur != lineView.node; )
                    cur = rm(cur);
                var updateNumber = lineNumbers && null != updateNumbersFrom && lineN >= updateNumbersFrom && lineView.lineNumber;
                lineView.changes && (indexOf(lineView.changes, "gutter") > -1 && (updateNumber = !1), updateLineForChanges(cm, lineView, lineN, dims)), updateNumber && (removeChildren(lineView.lineNumber), lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))), cur = lineView.node.nextSibling
            } else {
                var node = buildLineElement(cm, lineView, lineN, dims);
                container.insertBefore(node, cur)
            }
            lineN += lineView.size
        }
        for (; cur; )
            cur = rm(cur)
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j];
            "text" == type ? updateLineText(cm, lineView) : "gutter" == type ? updateLineGutter(cm, lineView, lineN, dims) : "class" == type ? updateLineClasses(lineView) : "widget" == type && updateLineWidgets(lineView, dims);
        }
        lineView.changes = null
    }
    function ensureLineWrapped(lineView) {
        return lineView.node == lineView.text && (lineView.node = elt("div", null, null, "position: relative"), lineView.text.parentNode && lineView.text.parentNode.replaceChild(lineView.node, lineView.text), lineView.node.appendChild(lineView.text), ie && 8 > ie_version && (lineView.node.style.zIndex = 2)), lineView.node
    }
    function updateLineBackground(lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls && (cls += " CodeMirror-linebackground"), lineView.background)
            cls ? lineView.background.className = cls : (lineView.background.parentNode.removeChild(lineView.background), lineView.background = null);
        else if (cls) {
            var wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild)
        }
    }
    function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        return ext && ext.line == lineView.line ? (cm.display.externalMeasured = null, lineView.measure = ext.measure, ext.built) : buildLineContent(cm, lineView)
    }
    function updateLineText(cm, lineView) {
        var cls = lineView.text.className, built = getLineContent(cm, lineView);
        lineView.text == lineView.node && (lineView.node = built.pre), lineView.text.parentNode.replaceChild(built.pre, lineView.text), lineView.text = built.pre, built.bgClass != lineView.bgClass || built.textClass != lineView.textClass ? (lineView.bgClass = built.bgClass, lineView.textClass = built.textClass, updateLineClasses(lineView)) : cls && (lineView.text.className = cls)
    }
    function updateLineClasses(lineView) {
        updateLineBackground(lineView), lineView.line.wrapClass ? ensureLineWrapped(lineView).className = lineView.line.wrapClass : lineView.node != lineView.text && (lineView.node.className = "");
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || ""
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
        lineView.gutter && (lineView.node.removeChild(lineView.gutter), lineView.gutter = null);
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
            var wrap = ensureLineWrapped(lineView), gutterWrap = lineView.gutter = wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"), lineView.text);
            if (lineView.line.gutterClass && (gutterWrap.className += " " + lineView.line.gutterClass), !cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"))), markers)
                for (var k = 0; k < cm.options.gutters.length; ++k) {
                    var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                    found && gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"))
                }
        }
    }
    function updateLineWidgets(lineView, dims) {
        lineView.alignable && (lineView.alignable = null);
        for (var next, node = lineView.node.firstChild; node; node = next) {
            var next = node.nextSibling;
            "CodeMirror-linewidget" == node.className && lineView.node.removeChild(node)
        }
        insertLineWidgets(lineView, dims)
    }
    function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        return lineView.text = lineView.node = built.pre, built.bgClass && (lineView.bgClass = built.bgClass), built.textClass && (lineView.textClass = built.textClass), updateLineClasses(lineView), updateLineGutter(cm, lineView, lineN, dims), insertLineWidgets(lineView, dims), lineView.node
    }
    function insertLineWidgets(lineView, dims) {
        if (insertLineWidgetsFor(lineView.line, lineView, dims, !0), lineView.rest)
            for (var i = 0; i < lineView.rest.length; i++)
                insertLineWidgetsFor(lineView.rest[i], lineView, dims, !1)
    }
    function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
        if (line.widgets)
            for (var wrap = ensureLineWrapped(lineView), i = 0, ws = line.widgets; i < ws.length; ++i) {
                var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
                widget.handleMouseEvents || node.setAttribute("cm-ignore-events", "true"), positionLineWidget(widget, node, lineView, dims), allowAbove && widget.above ? wrap.insertBefore(node, lineView.gutter || lineView.text) : wrap.appendChild(node), signalLater(widget, "redraw")
            }
    }
    function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + "px", widget.coverGutter || (width -= dims.gutterTotalWidth, node.style.paddingLeft = dims.gutterTotalWidth + "px"), node.style.width = width + "px"
        }
        widget.coverGutter && (node.style.zIndex = 5, node.style.position = "relative", widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px"))
    }
    function copyPos(x) {
        return Pos(x.line, x.ch)
    }
    function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a
    }
    function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b
    }
    function Selection(ranges, primIndex) {
        this.ranges = ranges, this.primIndex = primIndex
    }
    function Range(anchor, head) {
        this.anchor = anchor, this.head = head
    }
    function normalizeSelection(ranges, primIndex) {
        var prim = ranges[primIndex];
        ranges.sort(function (a, b) {
            return cmp(a.from(), b.from())
        }), primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
            var cur = ranges[i], prev = ranges[i - 1];
            if (cmp(prev.to(), cur.from()) >= 0) {
                var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to()), inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                primIndex >= i && --primIndex, ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))
            }
        }
        return new Selection(ranges, primIndex)
    }
    function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0)
    }
    function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))
    }
    function clipPos(doc, pos) {
        if (pos.line < doc.first)
            return Pos(doc.first, 0);
        var last = doc.first + doc.size - 1;
        return pos.line > last ? Pos(last, getLine(doc, last).text.length) : clipToLen(pos, getLine(doc, pos.line).text.length)
    }
    function clipToLen(pos, linelen) {
        var ch = pos.ch;
        return null == ch || ch > linelen ? Pos(pos.line, linelen) : 0 > ch ? Pos(pos.line, 0) : pos
    }
    function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size
    }
    function clipPosArray(doc, array) {
        for (var out = [], i = 0; i < array.length; i++)
            out[i] = clipPos(doc, array[i]);
        return out
    }
    function extendRange(doc, range, head, other) {
        if (doc.cm && doc.cm.display.shift || doc.extend) {
            var anchor = range.anchor;
            if (other) {
                var posBefore = cmp(head, anchor) < 0;
                posBefore != cmp(other, anchor) < 0 ? (anchor = head, head = other) : posBefore != cmp(head, other) < 0 && (head = other)
            }
            return new Range(anchor, head)
        }
        return new Range(other || head, head)
    }
    function extendSelection(doc, head, other, options) {
        setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options)
    }
    function extendSelections(doc, heads, options) {
        for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
            out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
        var newSel = normalizeSelection(out, doc.sel.primIndex);
        setSelection(doc, newSel, options)
    }
    function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range, setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)
    }
    function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options)
    }
    function filterSelectionChange(doc, sel) {
        var obj = {ranges: sel.ranges, update: function (ranges) {
                this.ranges = [];
                for (var i = 0; i < ranges.length; i++)
                    this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head))
            }};
        return signal(doc, "beforeSelectionChange", doc, obj), doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, obj), obj.ranges != sel.ranges ? normalizeSelection(obj.ranges, obj.ranges.length - 1) : sel
    }
    function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done, last = lst(done);
        last && last.ranges ? (done[done.length - 1] = sel, setSelectionNoUndo(doc, sel, options)) : setSelection(doc, sel, options)
    }
    function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options), addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)
    }
    function setSelectionNoUndo(doc, sel, options) {
        (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) && (sel = filterSelectionChange(doc, sel));
        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, !0)), options && options.scroll === !1 || !doc.cm || ensureCursorVisible(doc.cm)
    }
    function setSelectionInner(doc, sel) {
        sel.equals(doc.sel) || (doc.sel = sel, doc.cm && (doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = !0, signalCursorActivity(doc.cm)), signalLater(doc, "cursorActivity", doc))
    }
    function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, !1), sel_dontScroll)
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
        for (var out, i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i], newAnchor = skipAtomic(doc, range.anchor, bias, mayClear), newHead = skipAtomic(doc, range.head, bias, mayClear);
            (out || newAnchor != range.anchor || newHead != range.head) && (out || (out = sel.ranges.slice(0, i)), out[i] = new Range(newAnchor, newHead))
        }
        return out ? normalizeSelection(out, sel.primIndex) : sel
    }
    function skipAtomic(doc, pos, bias, mayClear) {
        var flipped = !1, curPos = pos, dir = bias || 1;
        doc.cantEdit = !1;
        search:for (; ; ) {
            var line = getLine(doc, curPos.line);
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans.length; ++i) {
                    var sp = line.markedSpans[i], m = sp.marker;
                    if ((null == sp.from || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (null == sp.to || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                        if (mayClear && (signal(m, "beforeCursorEnter"), m.explicitlyCleared)) {
                            if (line.markedSpans) {
                                --i;
                                continue
                            }
                            break
                        }
                        if (!m.atomic)
                            continue;
                        var newPos = m.find(0 > dir ? -1 : 1);
                        if (0 == cmp(newPos, curPos) && (newPos.ch += dir, newPos.ch < 0 ? newPos = newPos.line > doc.first ? clipPos(doc, Pos(newPos.line - 1)) : null : newPos.ch > line.text.length && (newPos = newPos.line < doc.first + doc.size - 1 ? Pos(newPos.line + 1, 0) : null), !newPos)) {
                            if (flipped)
                                return mayClear ? (doc.cantEdit = !0, Pos(doc.first, 0)) : skipAtomic(doc, pos, bias, !0);
                            flipped = !0, newPos = pos, dir = -dir
                        }
                        curPos = newPos;
                        continue search
                    }
                }
            return curPos
        }
    }
    function drawSelection(cm) {
        for (var display = cm.display, doc = cm.doc, result = {}, curFragment = result.cursors = document.createDocumentFragment(), selFragment = result.selection = document.createDocumentFragment(), i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i], collapsed = range.empty();
            (collapsed || cm.options.showCursorWhenSelecting) && drawSelectionCursor(cm, range, curFragment), collapsed || drawSelectionRange(cm, range, selFragment)
        }
        if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, "div"), wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)), result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left))
        }
        return result
    }
    function showSelection(cm, drawn) {
        removeChildrenAndAdd(cm.display.cursorDiv, drawn.cursors), removeChildrenAndAdd(cm.display.selectionDiv, drawn.selection), null != drawn.teTop && (cm.display.inputDiv.style.top = drawn.teTop + "px", cm.display.inputDiv.style.left = drawn.teLeft + "px")
    }
    function updateSelection(cm) {
        showSelection(cm, drawSelection(cm))
    }
    function drawSelectionCursor(cm, range, output) {
        var pos = cursorCoords(cm, range.head, "div", null, null, !cm.options.singleCursorHeightPerLine), cursor = output.appendChild(elt("div", "\xa0", "CodeMirror-cursor"));
        if (cursor.style.left = pos.left + "px", cursor.style.top = pos.top + "px", cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px", pos.other) {
            var otherCursor = output.appendChild(elt("div", "\xa0", "CodeMirror-cursor CodeMirror-secondarycursor"));
            otherCursor.style.display = "", otherCursor.style.left = pos.other.left + "px", otherCursor.style.top = pos.other.top + "px", otherCursor.style.height = .85 * (pos.other.bottom - pos.other.top) + "px"
        }
    }
    function drawSelectionRange(cm, range, output) {
        function add(left, top, width, bottom) {
            0 > top && (top = 0), top = Math.round(top), bottom = Math.round(bottom), fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px; top: " + top + "px; width: " + (null == width ? rightSide - left : width) + "px; height: " + (bottom - top) + "px"))
        }
        function drawForLine(line, fromArg, toArg) {
            function coords(ch, bias) {
                return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
            }
            var start, end, lineObj = getLine(doc, line), lineLen = lineObj.text.length;
            return iterateBidiSections(getOrder(lineObj), fromArg || 0, null == toArg ? lineLen : toArg, function (from, to, dir) {
                var rightPos, left, right, leftPos = coords(from, "left");
                if (from == to)
                    rightPos = leftPos, left = right = leftPos.left;
                else {
                    if (rightPos = coords(to - 1, "right"), "rtl" == dir) {
                        var tmp = leftPos;
                        leftPos = rightPos, rightPos = tmp
                    }
                    left = leftPos.left, right = rightPos.right
                }
                null == fromArg && 0 == from && (left = leftSide), rightPos.top - leftPos.top > 3 && (add(left, leftPos.top, null, leftPos.bottom), left = leftSide, leftPos.bottom < rightPos.top && add(left, leftPos.bottom, null, rightPos.top)), null == toArg && to == lineLen && (right = rightSide), (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) && (start = leftPos), (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) && (end = rightPos), leftSide + 1 > left && (left = leftSide), add(left, rightPos.top, right - left, rightPos.bottom)
            }), {start: start, end: end}
        }
        var display = cm.display, doc = cm.doc, fragment = document.createDocumentFragment(), padding = paddingH(cm.display), leftSide = padding.left, rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right, sFrom = range.from(), sTo = range.to();
        if (sFrom.line == sTo.line)
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        else {
            var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line), singleVLine = visualLine(fromLine) == visualLine(toLine), leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end, rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            singleVLine && (leftEnd.top < rightStart.top - 2 ? (add(leftEnd.right, leftEnd.top, null, leftEnd.bottom), add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)) : add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)), leftEnd.bottom < rightStart.top && add(leftSide, leftEnd.bottom, null, rightStart.top)
        }
        output.appendChild(fragment)
    }
    function restartBlink(cm) {
        if (cm.state.focused) {
            var display = cm.display;
            clearInterval(display.blinker);
            var on = !0;
            display.cursorDiv.style.visibility = "", cm.options.cursorBlinkRate > 0 ? display.blinker = setInterval(function () {
                display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"
            }, cm.options.cursorBlinkRate) : cm.options.cursorBlinkRate < 0 && (display.cursorDiv.style.visibility = "hidden")
        }
    }
    function startWorker(cm, time) {
        cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo && cm.state.highlight.set(time, bind(highlightWorker, cm))
    }
    function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first && (doc.frontier = doc.first), !(doc.frontier >= cm.display.viewTo)) {
            var end = +new Date + cm.options.workTime, state = copyState(doc.mode, getStateBefore(cm, doc.frontier)), changedLines = [];
            doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
                if (doc.frontier >= cm.display.viewFrom) {
                    var oldStyles = line.styles, highlighted = highlightLine(cm, line, state, !0);
                    line.styles = highlighted.styles;
                    var oldCls = line.styleClasses, newCls = highlighted.classes;
                    newCls ? line.styleClasses = newCls : oldCls && (line.styleClasses = null);
                    for (var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass), i = 0; !ischange && i < oldStyles.length; ++i)
                        ischange = oldStyles[i] != line.styles[i];
                    ischange && changedLines.push(doc.frontier), line.stateAfter = copyState(doc.mode, state)
                } else
                    processLine(cm, line.text, state), line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
                return++doc.frontier, +new Date > end ? (startWorker(cm, cm.options.workDelay), !0) : void 0
            }), changedLines.length && runInOp(cm, function () {
                for (var i = 0; i < changedLines.length; i++)
                    regLineChange(cm, changedLines[i], "text")
            })
        }
    }
    function findStartLine(cm, n, precise) {
        for (var minindent, minline, doc = cm.doc, lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100), search = n; search > lim; --search) {
            if (search <= doc.first)
                return doc.first;
            var line = getLine(doc, search - 1);
            if (line.stateAfter && (!precise || search <= doc.frontier))
                return search;
            var indented = countColumn(line.text, null, cm.options.tabSize);
            (null == minline || minindent > indented) && (minline = search - 1, minindent = indented)
        }
        return minline
    }
    function getStateBefore(cm, n, precise) {
        var doc = cm.doc, display = cm.display;
        if (!doc.mode.startState)
            return!0;
        var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        return state = state ? copyState(doc.mode, state) : startState(doc.mode), doc.iter(pos, n, function (line) {
            processLine(cm, line.text, state);
            var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
            line.stateAfter = save ? copyState(doc.mode, state) : null, ++pos
        }), precise && (doc.frontier = pos), state
    }
    function paddingTop(display) {
        return display.lineSpace.offsetTop
    }
    function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight
    }
    function paddingH(display) {
        if (display.cachedPaddingH)
            return display.cachedPaddingH;
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x")), style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle, data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
        return isNaN(data.left) || isNaN(data.right) || (display.cachedPaddingH = data), data
    }
    function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth
    }
    function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
    }
    function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
    }
    function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping, curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
                lineView.measure.width = curWidth;
                for (var rects = lineView.text.firstChild.getClientRects(), i = 0; i < rects.length - 1; i++) {
                    var cur = rects[i], next = rects[i + 1];
                    Math.abs(cur.bottom - next.bottom) > 2 && heights.push((cur.bottom + next.top) / 2 - rect.top)
                }
            }
            heights.push(rect.bottom - rect.top)
        }
    }
    function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line)
            return{map: lineView.measure.map, cache: lineView.measure.cache};
        for (var i = 0; i < lineView.rest.length; i++)
            if (lineView.rest[i] == line)
                return{map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
        for (var i = 0; i < lineView.rest.length; i++)
            if (lineNo(lineView.rest[i]) > lineN)
                return{map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: !0}
    }
    function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line), view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        return view.text = built.pre, removeChildrenAndAdd(cm.display.lineMeasure, built.pre), view
    }
    function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
    }
    function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
            return cm.display.view[findViewIndex(cm, lineN)];
        var ext = cm.display.externalMeasured;
        return ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size ? ext : void 0
    }
    function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line), view = findViewForLine(cm, lineN);
        view && !view.text ? view = null : view && view.changes && updateLineForChanges(cm, view, lineN, getDimensions(cm)), view || (view = updateExternalMeasurement(cm, line));
        var info = mapFromLineView(view, line, lineN);
        return{line: line, view: view, rect: null, map: info.map, cache: info.cache, before: info.before, hasHeights: !1}
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        prepared.before && (ch = -1);
        var found, key = ch + (bias || "");
        return prepared.cache.hasOwnProperty(key) ? found = prepared.cache[key] : (prepared.rect || (prepared.rect = prepared.view.text.getBoundingClientRect()), prepared.hasHeights || (ensureLineHeights(cm, prepared.view, prepared.rect), prepared.hasHeights = !0), found = measureCharInner(cm, prepared, ch, bias), found.bogus || (prepared.cache[key] = found)), {left: found.left, right: found.right, top: varHeight ? found.rtop : found.top, bottom: varHeight ? found.rbottom : found.bottom}
    }
    function measureCharInner(cm, prepared, ch, bias) {
        for (var node, start, end, collapse, map = prepared.map, i = 0; i < map.length; i += 3) {
            var mStart = map[i], mEnd = map[i + 1];
            if (mStart > ch ? (start = 0, end = 1, collapse = "left") : mEnd > ch ? (start = ch - mStart, end = start + 1) : (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) && (end = mEnd - mStart, start = end - 1, ch >= mEnd && (collapse = "right")), null != start) {
                if (node = map[i + 2], mStart == mEnd && bias == (node.insertLeft ? "left" : "right") && (collapse = bias), "left" == bias && 0 == start)
                    for (; i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft; )
                        node = map[(i -= 3) + 2], collapse = "left";
                if ("right" == bias && start == mEnd - mStart)
                    for (; i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft; )
                        node = map[(i += 3) + 2], collapse = "right";
                break
            }
        }
        var rect;
        if (3 == node.nodeType) {
            for (var i = 0; 4 > i; i++) {
                for (; start && isExtendingChar(prepared.line.text.charAt(mStart + start)); )
                    --start;
                for (; mEnd > mStart + end && isExtendingChar(prepared.line.text.charAt(mStart + end)); )
                    ++end;
                if (ie && 9 > ie_version && 0 == start && end == mEnd - mStart)
                    rect = node.parentNode.getBoundingClientRect();
                else if (ie && cm.options.lineWrapping) {
                    var rects = range(node, start, end).getClientRects();
                    rect = rects.length ? rects["right" == bias ? rects.length - 1 : 0] : nullRect
                } else
                    rect = range(node, start, end).getBoundingClientRect() || nullRect;
                if (rect.left || rect.right || 0 == start)
                    break;
                end = start, start -= 1, collapse = "right"
            }
            ie && 11 > ie_version && (rect = maybeUpdateRectForZooming(cm.display.measure, rect))
        } else {
            start > 0 && (collapse = bias = "right");
            var rects;
            rect = cm.options.lineWrapping && (rects = node.getClientRects()).length > 1 ? rects["right" == bias ? rects.length - 1 : 0] : node.getBoundingClientRect()
        }
        if (ie && 9 > ie_version && !start && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            rect = rSpan ? {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom} : nullRect
        }
        for (var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top, mid = (rtop + rbot) / 2, heights = prepared.view.measure.heights, i = 0; i < heights.length - 1 && !(mid < heights[i]); i++)
            ;
        var top = i ? heights[i - 1] : 0, bot = heights[i], result = {left: ("right" == collapse ? rect.right : rect.left) - prepared.rect.left, right: ("left" == collapse ? rect.left : rect.right) - prepared.rect.left, top: top, bottom: bot};
        return rect.left || rect.right || (result.bogus = !0), cm.options.singleCursorHeightPerLine || (result.rtop = rtop, result.rbottom = rbot), result
    }
    function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
            return rect;
        var scaleX = screen.logicalXDPI / screen.deviceXDPI, scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return{left: rect.left * scaleX, right: rect.right * scaleX, top: rect.top * scaleY, bottom: rect.bottom * scaleY}
    }
    function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure && (lineView.measure.cache = {}, lineView.measure.heights = null, lineView.rest))
            for (var i = 0; i < lineView.rest.length; i++)
                lineView.measure.caches[i] = {}
    }
    function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null, removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++)
            clearLineMeasurementCacheFor(cm.display.view[i])
    }
    function clearCaches(cm) {
        clearLineMeasurementCache(cm), cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null, cm.options.lineWrapping || (cm.display.maxLineChanged = !0), cm.display.lineNumChars = null
    }
    function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft
    }
    function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop
    }
    function intoCoordSystem(cm, lineObj, rect, context) {
        if (lineObj.widgets)
            for (var i = 0; i < lineObj.widgets.length; ++i)
                if (lineObj.widgets[i].above) {
                    var size = widgetHeight(lineObj.widgets[i]);
                    rect.top += size, rect.bottom += size
                }
        if ("line" == context)
            return rect;
        context || (context = "local");
        var yOff = heightAtLine(lineObj);
        if ("local" == context ? yOff += paddingTop(cm.display) : yOff -= cm.display.viewOffset, "page" == context || "window" == context) {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
            var xOff = lOff.left + ("window" == context ? 0 : pageScrollX());
            rect.left += xOff, rect.right += xOff
        }
        return rect.top += yOff, rect.bottom += yOff, rect
    }
    function fromCoordSystem(cm, coords, context) {
        if ("div" == context)
            return coords;
        var left = coords.left, top = coords.top;
        if ("page" == context)
            left -= pageScrollX(), top -= pageScrollY();
        else if ("local" == context || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left, top += localBox.top
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return{left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
    }
    function charCoords(cm, pos, context, lineObj, bias) {
        return lineObj || (lineObj = getLine(cm.doc, pos.line)), intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        function get(ch, right) {
            var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
            return right ? m.left = m.right : m.right = m.left, intoCoordSystem(cm, lineObj, m, context)
        }
        function getBidi(ch, partPos) {
            var part = order[partPos], right = part.level % 2;
            return ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level ? (part = order[--partPos], ch = bidiRight(part) - (part.level % 2 ? 0 : 1), right = !0) : ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level && (part = order[++partPos], ch = bidiLeft(part) - part.level % 2, right = !1), right && ch == part.to && ch > part.from ? get(ch - 1) : get(ch, right)
        }
        lineObj = lineObj || getLine(cm.doc, pos.line), preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
        var order = getOrder(lineObj), ch = pos.ch;
        if (!order)
            return get(ch);
        var partPos = getBidiPartAt(order, ch), val = getBidi(ch, partPos);
        return null != bidiOther && (val.other = getBidi(ch, bidiOther)), val
    }
    function estimateCoords(cm, pos) {
        var left = 0, pos = clipPos(cm.doc, pos);
        cm.options.lineWrapping || (left = charWidth(cm.display) * pos.ch);
        var lineObj = getLine(cm.doc, pos.line), top = heightAtLine(lineObj) + paddingTop(cm.display);
        return{left: left, right: left, top: top, bottom: top + lineObj.height}
    }
    function PosWithInfo(line, ch, outside, xRel) {
        var pos = Pos(line, ch);
        return pos.xRel = xRel, outside && (pos.outside = !0), pos
    }
    function coordsChar(cm, x, y) {
        var doc = cm.doc;
        if (y += cm.display.viewOffset, 0 > y)
            return PosWithInfo(doc.first, 0, !0, -1);
        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
        if (lineN > last)
            return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, !0, 1);
        0 > x && (x = 0);
        for (var lineObj = getLine(doc, lineN); ; ) {
            var found = coordsCharInner(cm, lineObj, lineN, x, y), merged = collapsedSpanAtEnd(lineObj), mergedPos = merged && merged.find(0, !0);
            if (!merged || !(found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
                return found;
            lineN = lineNo(lineObj = mergedPos.to.line)
        }
    }
    function coordsCharInner(cm, lineObj, lineNo, x, y) {
        function getX(ch) {
            var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
            return wrongLine = !0, innerOff > sp.bottom ? sp.left - adjust : innerOff < sp.top ? sp.left + adjust : (wrongLine = !1, sp.left)
        }
        var innerOff = y - heightAtLine(lineObj), wrongLine = !1, adjust = 2 * cm.display.wrapper.clientWidth, preparedMeasure = prepareMeasureForLine(cm, lineObj), bidi = getOrder(lineObj), dist = lineObj.text.length, from = lineLeft(lineObj), to = lineRight(lineObj), fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
        if (x > toX)
            return PosWithInfo(lineNo, to, toOutside, 1);
        for (; ; ) {
            if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : 1 >= to - from) {
                for (var ch = fromX > x || toX - x >= x - fromX ? from : to, xDiff = x - (ch == from ? fromX : toX); isExtendingChar(lineObj.text.charAt(ch)); )
                    ++ch;
                var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, -1 > xDiff ? -1 : xDiff > 1 ? 1 : 0);
                return pos
            }
            var step = Math.ceil(dist / 2), middle = from + step;
            if (bidi) {
                middle = from;
                for (var i = 0; step > i; ++i)
                    middle = moveVisually(lineObj, middle, 1)
            }
            var middleX = getX(middle);
            middleX > x ? (to = middle, toX = middleX, (toOutside = wrongLine) && (toX += 1e3), dist = step) : (from = middle, fromX = middleX, fromOutside = wrongLine, dist -= step)
        }
    }
    function textHeight(display) {
        if (null != display.cachedTextHeight)
            return display.cachedTextHeight;
        if (null == measureText) {
            measureText = elt("pre");
            for (var i = 0; 49 > i; ++i)
                measureText.appendChild(document.createTextNode("x")), measureText.appendChild(elt("br"));
            measureText.appendChild(document.createTextNode("x"))
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        return height > 3 && (display.cachedTextHeight = height), removeChildren(display.measure), height || 1
    }
    function charWidth(display) {
        if (null != display.cachedCharWidth)
            return display.cachedCharWidth;
        var anchor = elt("span", "xxxxxxxxxx"), pre = elt("pre", [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        return width > 2 && (display.cachedCharWidth = width), width || 10
    }
    function startOperation(cm) {
        cm.curOp = {cm: cm, viewChanged: !1, startHeight: cm.doc.height, forceUpdate: !1, updateInput: null, typing: !1, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: !1, updateMaxLine: !1, scrollLeft: null, scrollTop: null, scrollToPos: null, id: ++nextOpId}, operationGroup ? operationGroup.ops.push(cm.curOp) : cm.curOp.ownsGroup = operationGroup = {ops: [cm.curOp], delayedCallbacks: []}
    }
    function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks, i = 0;
        do {
            for (; i < callbacks.length; i++)
                callbacks[i]();
            for (var j = 0; j < group.ops.length; j++) {
                var op = group.ops[j];
                if (op.cursorActivityHandlers)
                    for (; op.cursorActivityCalled < op.cursorActivityHandlers.length; )
                        op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm)
            }
        } while (i < callbacks.length)
    }
    function endOperation(cm) {
        var op = cm.curOp, group = op.ownsGroup;
        if (group)
            try {
                fireCallbacksForOps(group)
            } finally {
                operationGroup = null;
                for (var i = 0; i < group.ops.length; i++)
                    group.ops[i].cm.curOp = null;
                endOperations(group)
            }
    }
    function endOperations(group) {
        for (var ops = group.ops, i = 0; i < ops.length; i++)
            endOperation_R1(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_W1(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_R2(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_W2(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_finish(ops[i])
    }
    function endOperation_R1(op) {
        var cm = op.cm, display = cm.display;
        maybeClipScrollbars(cm), op.updateMaxLine && findMaxLine(cm), op.mustUpdate = op.viewChanged || op.forceUpdate || null != op.scrollTop || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping, op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate)
    }
    function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)
    }
    function endOperation_R2(op) {
        var cm = op.cm, display = cm.display;
        op.updatedDisplay && updateHeightsInViewport(cm), op.barMeasure = measureForScrollbars(cm), display.maxLineChanged && !cm.options.lineWrapping && (op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3, cm.display.sizerWidth = op.adjustWidthTo, op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth), op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))), (op.updatedDisplay || op.selectionChanged) && (op.newSelectionNodes = drawSelection(cm))
    }
    function endOperation_W2(op) {
        var cm = op.cm;
        null != op.adjustWidthTo && (cm.display.sizer.style.minWidth = op.adjustWidthTo + "px", op.maxScrollLeft < cm.doc.scrollLeft && setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), !0), cm.display.maxLineChanged = !1), op.newSelectionNodes && showSelection(cm, op.newSelectionNodes), op.updatedDisplay && setDocumentHeight(cm, op.barMeasure), (op.updatedDisplay || op.startHeight != cm.doc.height) && updateScrollbars(cm, op.barMeasure), op.selectionChanged && restartBlink(cm), cm.state.focused && op.updateInput && resetInput(cm, op.typing)
    }
    function endOperation_finish(op) {
        var cm = op.cm, display = cm.display, doc = cm.doc;
        if (op.updatedDisplay && postUpdateDisplay(cm, op.update), null == display.wheelStartX || null == op.scrollTop && null == op.scrollLeft && !op.scrollToPos || (display.wheelStartX = display.wheelStartY = null),
                null == op.scrollTop || display.scroller.scrollTop == op.scrollTop && !op.forceScroll || (doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop)), display.scrollbars.setScrollTop(doc.scrollTop), display.scroller.scrollTop = doc.scrollTop), null == op.scrollLeft || display.scroller.scrollLeft == op.scrollLeft && !op.forceScroll || (doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft)), display.scrollbars.setScrollLeft(doc.scrollLeft), display.scroller.scrollLeft = doc.scrollLeft, alignHorizontally(cm)), op.scrollToPos) {
            var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
            op.scrollToPos.isCursor && cm.state.focused && maybeScrollWindow(cm, coords)
        }
        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden)
            for (var i = 0; i < hidden.length; ++i)
                hidden[i].lines.length || signal(hidden[i], "hide");
        if (unhidden)
            for (var i = 0; i < unhidden.length; ++i)
                unhidden[i].lines.length && signal(unhidden[i], "unhide");
        display.wrapper.offsetHeight && (doc.scrollTop = cm.display.scroller.scrollTop), op.changeObjs && signal(cm, "changes", cm, op.changeObjs)
    }
    function runInOp(cm, f) {
        if (cm.curOp)
            return f();
        startOperation(cm);
        try {
            return f()
        } finally {
            endOperation(cm)
        }
    }
    function operation(cm, f) {
        return function () {
            if (cm.curOp)
                return f.apply(cm, arguments);
            startOperation(cm);
            try {
                return f.apply(cm, arguments)
            } finally {
                endOperation(cm)
            }
        }
    }
    function methodOp(f) {
        return function () {
            if (this.curOp)
                return f.apply(this, arguments);
            startOperation(this);
            try {
                return f.apply(this, arguments)
            } finally {
                endOperation(this)
            }
        }
    }
    function docMethodOp(f) {
        return function () {
            var cm = this.cm;
            if (!cm || cm.curOp)
                return f.apply(this, arguments);
            startOperation(cm);
            try {
                return f.apply(this, arguments)
            } finally {
                endOperation(cm)
            }
        }
    }
    function LineView(doc, line, lineN) {
        this.line = line, this.rest = visualLineContinued(line), this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1, this.node = this.text = null, this.hidden = lineIsHidden(doc, line)
    }
    function buildViewArray(cm, from, to) {
        for (var nextPos, array = [], pos = from; to > pos; pos = nextPos) {
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size, array.push(view)
        }
        return array
    }
    function regChange(cm, from, to, lendiff) {
        null == from && (from = cm.doc.first), null == to && (to = cm.doc.first + cm.doc.size), lendiff || (lendiff = 0);
        var display = cm.display;
        if (lendiff && to < display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers > from) && (display.updateLineNumbers = from), cm.curOp.viewChanged = !0, from >= display.viewTo)
            sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo && resetView(cm);
        else if (to <= display.viewFrom)
            sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom ? resetView(cm) : (display.viewFrom += lendiff, display.viewTo += lendiff);
        else if (from <= display.viewFrom && to >= display.viewTo)
            resetView(cm);
        else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            cut ? (display.view = display.view.slice(cut.index), display.viewFrom = cut.lineN, display.viewTo += lendiff) : resetView(cm)
        } else if (to >= display.viewTo) {
            var cut = viewCuttingPoint(cm, from, from, -1);
            cut ? (display.view = display.view.slice(0, cut.index), display.viewTo = cut.lineN) : resetView(cm)
        } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1), cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            cutTop && cutBot ? (display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index)), display.viewTo += lendiff) : resetView(cm)
        }
        var ext = display.externalMeasured;
        ext && (to < ext.lineN ? ext.lineN += lendiff : from < ext.lineN + ext.size && (display.externalMeasured = null))
    }
    function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = !0;
        var display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size && (display.externalMeasured = null), !(line < display.viewFrom || line >= display.viewTo)) {
            var lineView = display.view[findViewIndex(cm, line)];
            if (null != lineView.node) {
                var arr = lineView.changes || (lineView.changes = []);
                -1 == indexOf(arr, type) && arr.push(type)
            }
        }
    }
    function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first, cm.display.view = [], cm.display.viewOffset = 0
    }
    function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo)
            return null;
        if (n -= cm.display.viewFrom, 0 > n)
            return null;
        for (var view = cm.display.view, i = 0; i < view.length; i++)
            if (n -= view[i].size, 0 > n)
                return i
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
        var diff, index = findViewIndex(cm, oldN), view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
            return{index: index, lineN: newN};
        for (var i = 0, n = cm.display.viewFrom; index > i; i++)
            n += view[i].size;
        if (n != oldN) {
            if (dir > 0) {
                if (index == view.length - 1)
                    return null;
                diff = n + view[index].size - oldN, index++
            } else
                diff = n - oldN;
            oldN += diff, newN += diff
        }
        for (; visualLineNo(cm.doc, newN) != newN; ) {
            if (index == (0 > dir ? 0 : view.length - 1))
                return null;
            newN += dir * view[index - (0 > dir ? 1 : 0)].size, index += dir
        }
        return{index: index, lineN: newN}
    }
    function adjustView(cm, from, to) {
        var display = cm.display, view = display.view;
        0 == view.length || from >= display.viewTo || to <= display.viewFrom ? (display.view = buildViewArray(cm, from, to), display.viewFrom = from) : (display.viewFrom > from ? display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) : display.viewFrom < from && (display.view = display.view.slice(findViewIndex(cm, from))), display.viewFrom = from, display.viewTo < to ? display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) : display.viewTo > to && (display.view = display.view.slice(0, findViewIndex(cm, to)))), display.viewTo = to
    }
    function countDirtyView(cm) {
        for (var view = cm.display.view, dirty = 0, i = 0; i < view.length; i++) {
            var lineView = view[i];
            lineView.hidden || lineView.node && !lineView.changes || ++dirty
        }
        return dirty
    }
    function slowPoll(cm) {
        cm.display.pollingFast || cm.display.poll.set(cm.options.pollInterval, function () {
            readInput(cm), cm.state.focused && slowPoll(cm)
        })
    }
    function fastPoll(cm) {
        function p() {
            var changed = readInput(cm);
            changed || missed ? (cm.display.pollingFast = !1, slowPoll(cm)) : (missed = !0, cm.display.poll.set(60, p))
        }
        var missed = !1;
        cm.display.pollingFast = !0, cm.display.poll.set(20, p)
    }
    function readInput(cm) {
        var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;
        if (!cm.state.focused || hasSelection(input) && !prevInput || isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)
            return!1;
        cm.state.pasteIncoming && cm.state.fakedLastChar && (input.value = input.value.substring(0, input.value.length - 1), cm.state.fakedLastChar = !1);
        var text = input.value;
        if (text == prevInput && !cm.somethingSelected())
            return!1;
        if (ie && ie_version >= 9 && cm.display.inputHasSelection === text || mac && /[\uf700-\uf7ff]/.test(text))
            return resetInput(cm), !1;
        var withOp = !cm.curOp;
        withOp && startOperation(cm), cm.display.shift = !1, 8203 != text.charCodeAt(0) || doc.sel != cm.display.selForContextMenu || prevInput || (prevInput = "\u200b");
        for (var same = 0, l = Math.min(prevInput.length, text.length); l > same && prevInput.charCodeAt(same) == text.charCodeAt(same); )
            ++same;
        var inserted = text.slice(same), textLines = splitLines(inserted), multiPaste = null;
        cm.state.pasteIncoming && doc.sel.ranges.length > 1 && (lastCopied && lastCopied.join("\n") == inserted ? multiPaste = doc.sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines) : textLines.length == doc.sel.ranges.length && (multiPaste = map(textLines, function (l) {
            return[l]
        })));
        for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
            var range = doc.sel.ranges[i], from = range.from(), to = range.to();
            same < prevInput.length ? from = Pos(from.line, from.ch - (prevInput.length - same)) : cm.state.overwrite && range.empty() && !cm.state.pasteIncoming && (to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)));
            var updateInput = cm.curOp.updateInput, changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines, origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};
            if (makeChange(cm.doc, changeEvent), signalLater(cm, "inputRead", cm, changeEvent), inserted && !cm.state.pasteIncoming && cm.options.electricChars && cm.options.smartIndent && range.head.ch < 100 && (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
                var mode = cm.getModeAt(range.head), end = changeEnd(changeEvent);
                if (mode.electricChars) {
                    for (var j = 0; j < mode.electricChars.length; j++)
                        if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                            indentLine(cm, end.line, "smart");
                            break
                        }
                } else
                    mode.electricInput && mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)) && indentLine(cm, end.line, "smart")
            }
        }
        return ensureCursorVisible(cm), cm.curOp.updateInput = updateInput, cm.curOp.typing = !0, text.length > 1e3 || text.indexOf("\n") > -1 ? input.value = cm.display.prevInput = "" : cm.display.prevInput = text, withOp && endOperation(cm), cm.state.pasteIncoming = cm.state.cutIncoming = !1, !0
    }
    function resetInput(cm, typing) {
        if (!cm.display.contextMenuPending) {
            var minimal, selected, doc = cm.doc;
            if (cm.somethingSelected()) {
                cm.display.prevInput = "";
                var range = doc.sel.primary();
                minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1e3);
                var content = minimal ? "-" : selected || cm.getSelection();
                cm.display.input.value = content, cm.state.focused && selectInput(cm.display.input), ie && ie_version >= 9 && (cm.display.inputHasSelection = content)
            } else
                typing || (cm.display.prevInput = cm.display.input.value = "", ie && ie_version >= 9 && (cm.display.inputHasSelection = null));
            cm.display.inaccurateSelection = minimal
        }
    }
    function focusInput(cm) {
        "nocursor" == cm.options.readOnly || mobile && activeElt() == cm.display.input || cm.display.input.focus()
    }
    function ensureFocus(cm) {
        cm.state.focused || (focusInput(cm), onFocus(cm))
    }
    function isReadOnly(cm) {
        return cm.options.readOnly || cm.doc.cantEdit
    }
    function registerEventHandlers(cm) {
        function drag_(e) {
            signalDOMEvent(cm, e) || e_stop(e)
        }
        function prepareCopyCut(e) {
            if (cm.somethingSelected())
                lastCopied = cm.getSelections(), d.inaccurateSelection && (d.prevInput = "", d.inaccurateSelection = !1, d.input.value = lastCopied.join("\n"), selectInput(d.input));
            else {
                for (var text = [], ranges = [], i = 0; i < cm.doc.sel.ranges.length; i++) {
                    var line = cm.doc.sel.ranges[i].head.line, lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
                    ranges.push(lineRange), text.push(cm.getRange(lineRange.anchor, lineRange.head))
                }
                "cut" == e.type ? cm.setSelections(ranges, null, sel_dontScroll) : (d.prevInput = "", d.input.value = text.join("\n"), selectInput(d.input)), lastCopied = text
            }
            "cut" == e.type && (cm.state.cutIncoming = !0)
        }
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown)), ie && 11 > ie_version ? on(d.scroller, "dblclick", operation(cm, function (e) {
            if (!signalDOMEvent(cm, e)) {
                var pos = posFromMouse(cm, e);
                if (pos && !clickInGutter(cm, e) && !eventInWidget(cm.display, e)) {
                    e_preventDefault(e);
                    var word = cm.findWordAt(pos);
                    extendSelection(cm.doc, word.anchor, word.head)
                }
            }
        })) : on(d.scroller, "dblclick", function (e) {
            signalDOMEvent(cm, e) || e_preventDefault(e)
        }), on(d.lineSpace, "selectstart", function (e) {
            eventInWidget(d, e) || e_preventDefault(e)
        }), captureRightClick || on(d.scroller, "contextmenu", function (e) {
            onContextMenu(cm, e)
        }), on(d.scroller, "scroll", function () {
            d.scroller.clientHeight && (setScrollTop(cm, d.scroller.scrollTop), setScrollLeft(cm, d.scroller.scrollLeft, !0), signal(cm, "scroll", cm))
        }), on(d.scroller, "mousewheel", function (e) {
            onScrollWheel(cm, e)
        }), on(d.scroller, "DOMMouseScroll", function (e) {
            onScrollWheel(cm, e)
        }), on(d.wrapper, "scroll", function () {
            d.wrapper.scrollTop = d.wrapper.scrollLeft = 0
        }), on(d.input, "keyup", function (e) {
            onKeyUp.call(cm, e)
        }), on(d.input, "input", function () {
            ie && ie_version >= 9 && cm.display.inputHasSelection && (cm.display.inputHasSelection = null), readInput(cm)
        }), on(d.input, "keydown", operation(cm, onKeyDown)), on(d.input, "keypress", operation(cm, onKeyPress)), on(d.input, "focus", bind(onFocus, cm)), on(d.input, "blur", bind(onBlur, cm)), cm.options.dragDrop && (on(d.scroller, "dragstart", function (e) {
            onDragStart(cm, e)
        }), on(d.scroller, "dragenter", drag_), on(d.scroller, "dragover", drag_), on(d.scroller, "drop", operation(cm, onDrop))), on(d.scroller, "paste", function (e) {
            eventInWidget(d, e) || (cm.state.pasteIncoming = !0, focusInput(cm), fastPoll(cm))
        }), on(d.input, "paste", function () {
            if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
                var start = d.input.selectionStart, end = d.input.selectionEnd;
                d.input.value += "$", d.input.selectionEnd = end, d.input.selectionStart = start, cm.state.fakedLastChar = !0
            }
            cm.state.pasteIncoming = !0, fastPoll(cm)
        }), on(d.input, "cut", prepareCopyCut), on(d.input, "copy", prepareCopyCut), khtml && on(d.sizer, "mouseup", function () {
            activeElt() == d.input && d.input.blur(), focusInput(cm)
        })
    }
    function onResize(cm) {
        var d = cm.display;
        (d.lastWrapHeight != d.wrapper.clientHeight || d.lastWrapWidth != d.wrapper.clientWidth) && (d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, d.scrollbarsClipped = !1, cm.setSize())
    }
    function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode)
            if (!n || "true" == n.getAttribute("cm-ignore-events") || n.parentNode == display.sizer && n != display.mover)
                return!0
    }
    function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && "true" == e_target(e).getAttribute("not-content"))
            return null;
        var x, y, space = display.lineSpace.getBoundingClientRect();
        try {
            x = e.clientX - space.left, y = e.clientY - space.top
        } catch (e) {
            return null
        }
        var line, coords = coordsChar(cm, x, y);
        if (forRect && 1 == coords.xRel && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))
        }
        return coords
    }
    function onMouseDown(e) {
        if (!signalDOMEvent(this, e)) {
            var cm = this, display = cm.display;
            if (display.shift = e.shiftKey, eventInWidget(display, e))
                return void(webkit || (display.scroller.draggable = !1, setTimeout(function () {
                    display.scroller.draggable = !0
                }, 100)));
            if (!clickInGutter(cm, e)) {
                var start = posFromMouse(cm, e);
                switch (window.focus(), e_button(e)) {
                    case 1:
                        start ? leftButtonDown(cm, e, start) : e_target(e) == display.scroller && e_preventDefault(e);
                        break;
                    case 2:
                        webkit && (cm.state.lastMiddleDown = +new Date), start && extendSelection(cm.doc, start), setTimeout(bind(focusInput, cm), 20), e_preventDefault(e);
                        break;
                    case 3:
                        captureRightClick && onContextMenu(cm, e)
                    }
            }
        }
    }
    function leftButtonDown(cm, e, start) {
        setTimeout(bind(ensureFocus, cm), 0);
        var type, now = +new Date;
        lastDoubleClick && lastDoubleClick.time > now - 400 && 0 == cmp(lastDoubleClick.pos, start) ? type = "triple" : lastClick && lastClick.time > now - 400 && 0 == cmp(lastClick.pos, start) ? (type = "double", lastDoubleClick = {time: now, pos: start}) : (type = "single", lastClick = {time: now, pos: start});
        var contained, sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;
        cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && "single" == type && (contained = sel.contains(start)) > -1 && !sel.ranges[contained].empty() ? leftButtonStartDrag(cm, e, start, modifier) : leftButtonSelect(cm, e, start, type, modifier)
    }
    function leftButtonStartDrag(cm, e, start, modifier) {
        var display = cm.display, dragEnd = operation(cm, function (e2) {
            webkit && (display.scroller.draggable = !1), cm.state.draggingText = !1, off(document, "mouseup", dragEnd), off(display.scroller, "drop", dragEnd), Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10 && (e_preventDefault(e2), modifier || extendSelection(cm.doc, start), focusInput(cm), ie && 9 == ie_version && setTimeout(function () {
                document.body.focus(), focusInput(cm)
            }, 20))
        });
        webkit && (display.scroller.draggable = !0), cm.state.draggingText = dragEnd, display.scroller.dragDrop && display.scroller.dragDrop(), on(document, "mouseup", dragEnd), on(display.scroller, "drop", dragEnd)
    }
    function leftButtonSelect(cm, e, start, type, addNew) {
        function extendTo(pos) {
            if (0 != cmp(lastPos, pos))
                if (lastPos = pos, "rect" == type) {
                    for (var ranges = [], tabSize = cm.options.tabSize, startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize), posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize), left = Math.min(startCol, posCol), right = Math.max(startCol, posCol), line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); end >= line; line++) {
                        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                        left == right ? ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) : text.length > leftPos && ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))))
                    }
                    ranges.length || ranges.push(new Range(start, start)), setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {origin: "*mouse", scroll: !1}), cm.scrollIntoView(pos)
                } else {
                    var oldRange = ourRange, anchor = oldRange.anchor, head = pos;
                    if ("single" != type) {
                        if ("double" == type)
                            var range = cm.findWordAt(pos);
                        else
                            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
                        cmp(range.anchor, anchor) > 0 ? (head = range.head, anchor = minPos(oldRange.from(), range.anchor)) : (head = range.anchor, anchor = maxPos(oldRange.to(), range.head))
                    }
                    var ranges = startSel.ranges.slice(0);
                    ranges[ourIndex] = new Range(clipPos(doc, anchor), head), setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse)
                }
        }
        function extend(e) {
            var curCount = ++counter, cur = posFromMouse(cm, e, !0, "rect" == type);
            if (cur)
                if (0 != cmp(cur, lastPos)) {
                    ensureFocus(cm), extendTo(cur);
                    var visible = visibleLines(display, doc);
                    (cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm, function () {
                        counter == curCount && extend(e)
                    }), 150)
                } else {
                    var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                    outside && setTimeout(operation(cm, function () {
                        counter == curCount && (display.scroller.scrollTop += outside, extend(e))
                    }), 50)
                }
        }
        function done(e) {
            counter = 1 / 0, e_preventDefault(e), focusInput(cm), off(document, "mousemove", move), off(document, "mouseup", up), doc.history.lastSelOrigin = null
        }
        var display = cm.display, doc = cm.doc;
        e_preventDefault(e);
        var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
        if (addNew && !e.shiftKey ? (ourIndex = doc.sel.contains(start), ourRange = ourIndex > -1 ? ranges[ourIndex] : new Range(start, start)) : ourRange = doc.sel.primary(), e.altKey)
            type = "rect", addNew || (ourRange = new Range(start, start)), start = posFromMouse(cm, e, !0, !0), ourIndex = -1;
        else if ("double" == type) {
            var word = cm.findWordAt(start);
            ourRange = cm.display.shift || doc.extend ? extendRange(doc, ourRange, word.anchor, word.head) : word
        } else if ("triple" == type) {
            var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
            ourRange = cm.display.shift || doc.extend ? extendRange(doc, ourRange, line.anchor, line.head) : line
        } else
            ourRange = extendRange(doc, ourRange, start);
        addNew ? -1 == ourIndex ? (ourIndex = ranges.length, setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), {scroll: !1, origin: "*mouse"})) : ranges.length > 1 && ranges[ourIndex].empty() && "single" == type ? (setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0)), startSel = doc.sel) : replaceOneSelection(doc, ourIndex, ourRange, sel_mouse) : (ourIndex = 0, setSelection(doc, new Selection([ourRange], 0), sel_mouse), startSel = doc.sel);
        var lastPos = start, editorSize = display.wrapper.getBoundingClientRect(), counter = 0, move = operation(cm, function (e) {
            e_button(e) ? extend(e) : done(e)
        }), up = operation(cm, done);
        on(document, "mousemove", move), on(document, "mouseup", up)
    }
    function gutterEvent(cm, e, type, prevent, signalfn) {
        try {
            var mX = e.clientX, mY = e.clientY
        } catch (e) {
            return!1
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right))
            return!1;
        prevent && e_preventDefault(e);
        var display = cm.display, lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type))
            return e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;
        for (var i = 0; i < cm.options.gutters.length; ++i) {
            var g = display.gutters.childNodes[i];
            if (g && g.getBoundingClientRect().right >= mX) {
                var line = lineAtHeight(cm.doc, mY), gutter = cm.options.gutters[i];
                return signalfn(cm, type, cm, line, gutter, e), e_defaultPrevented(e)
            }
        }
    }
    function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", !0, signalLater)
    }
    function onDrop(e) {
        var cm = this;
        if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e)) {
            e_preventDefault(e), ie && (lastDrop = +new Date);
            var pos = posFromMouse(cm, e, !0), files = e.dataTransfer.files;
            if (pos && !isReadOnly(cm))
                if (files && files.length && window.FileReader && window.File)
                    for (var n = files.length, text = Array(n), read = 0, loadFile = function (file, i) {
                        var reader = new FileReader;
                        reader.onload = operation(cm, function () {
                            if (text[i] = reader.result, ++read == n) {
                                pos = clipPos(cm.doc, pos);
                                var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
                                makeChange(cm.doc, change), setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))
                            }
                        }), reader.readAsText(file)
                    }, i = 0; n > i; ++i)
                        loadFile(files[i], i);
                else {
                    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1)
                        return cm.state.draggingText(e), void setTimeout(bind(focusInput, cm), 20);
                    try {
                        var text = e.dataTransfer.getData("Text");
                        if (text) {
                            if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
                                var selected = cm.listSelections();
                            if (setSelectionNoUndo(cm.doc, simpleSelection(pos, pos)), selected)
                                for (var i = 0; i < selected.length; ++i)
                                    replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
                            cm.replaceSelection(text, "around", "paste"), focusInput(cm)
                        }
                    } catch (e) {
                    }
                }
        }
    }
    function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100))
            return void e_stop(e);
        if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e) && (e.dataTransfer.setData("Text", cm.getSelection()), e.dataTransfer.setDragImage && !safari)) {
            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", presto && (img.width = img.height = 1, cm.display.wrapper.appendChild(img), img._top = img.offsetTop), e.dataTransfer.setDragImage(img, 0, 0), presto && img.parentNode.removeChild(img)
        }
    }
    function setScrollTop(cm, val) {
        Math.abs(cm.doc.scrollTop - val) < 2 || (cm.doc.scrollTop = val, gecko || updateDisplaySimple(cm, {top: val}), cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val), cm.display.scrollbars.setScrollTop(val), gecko && updateDisplaySimple(cm), startWorker(cm, 100))
    }
    function setScrollLeft(cm, val, isScroller) {
        (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) || (val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth), cm.doc.scrollLeft = val, alignHorizontally(cm), cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val), cm.display.scrollbars.setScrollLeft(val))
    }
    function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y, display = cm.display, scroll = display.scroller;
        if (dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight) {
            if (dy && mac && webkit)
                outer:for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode)
                    for (var i = 0; i < view.length; i++)
                        if (view[i].node == cur) {
                            cm.display.currentWheelTarget = cur;
                            break outer
                        }
            if (dx && !gecko && !presto && null != wheelPixelsPerUnit)
                return dy && setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))), setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth))), e_preventDefault(e), void(display.wheelStartX = null);
            if (dy && null != wheelPixelsPerUnit) {
                var pixels = dy * wheelPixelsPerUnit, top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
                0 > pixels ? top = Math.max(0, top + pixels - 50) : bot = Math.min(cm.doc.height, bot + pixels + 50), updateDisplaySimple(cm, {top: top, bottom: bot})
            }
            20 > wheelSamples && (null == display.wheelStartX ? (display.wheelStartX = scroll.scrollLeft, display.wheelStartY = scroll.scrollTop, display.wheelDX = dx, display.wheelDY = dy, setTimeout(function () {
                if (null != display.wheelStartX) {
                    var movedX = scroll.scrollLeft - display.wheelStartX, movedY = scroll.scrollTop - display.wheelStartY, sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                    display.wheelStartX = display.wheelStartY = null, sample && (wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1), ++wheelSamples)
                }
            }, 200)) : (display.wheelDX += dx, display.wheelDY += dy))
        }
    }
    function doHandleBinding(cm, bound, dropShift) {
        if ("string" == typeof bound && (bound = commands[bound], !bound))
            return!1;
        cm.display.pollingFast && readInput(cm) && (cm.display.pollingFast = !1);
        var prevShift = cm.display.shift, done = !1;
        try {
            isReadOnly(cm) && (cm.state.suppressEdits = !0), dropShift && (cm.display.shift = !1), done = bound(cm) != Pass
        } finally {
            cm.display.shift = prevShift, cm.state.suppressEdits = !1
        }
        return done
    }
    function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
            var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
            if (result)
                return result
        }
        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm)
    }
    function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
            if (isModifierKey(name))
                return"handled";
            stopSeq.set(50, function () {
                cm.state.keySeq == seq && (cm.state.keySeq = null, resetInput(cm))
            }), name = seq + " " + name
        }
        var result = lookupKeyForEditor(cm, name, handle);
        return"multi" == result && (cm.state.keySeq = name), "handled" == result && signalLater(cm, "keyHandled", cm, name, e), ("handled" == result || "multi" == result) && (e_preventDefault(e), restartBlink(cm)), seq && !result && /\'$/.test(name) ? (e_preventDefault(e), !0) : !!result
    }
    function handleKeyBinding(cm, e) {
        var name = keyName(e, !0);
        return name ? e.shiftKey && !cm.state.keySeq ? dispatchKey(cm, "Shift-" + name, e, function (b) {
            return doHandleBinding(cm, b, !0)
        }) || dispatchKey(cm, name, e, function (b) {
            return("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion) ? doHandleBinding(cm, b) : void 0
        }) : dispatchKey(cm, name, e, function (b) {
            return doHandleBinding(cm, b)
        }) : !1
    }
    function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function (b) {
            return doHandleBinding(cm, b, !0)
        })
    }
    function onKeyDown(e) {
        var cm = this;
        if (ensureFocus(cm), !signalDOMEvent(cm, e)) {
            ie && 11 > ie_version && 27 == e.keyCode && (e.returnValue = !1);
            var code = e.keyCode;
            cm.display.shift = 16 == code || e.shiftKey;
            var handled = handleKeyBinding(cm, e);
            presto && (lastStoppedKey = handled ? code : null, !handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection("", null, "cut")), 18 != code || /\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className) || showCrossHair(cm)
        }
    }
    function showCrossHair(cm) {
        function up(e) {
            18 != e.keyCode && e.altKey || (rmClass(lineDiv, "CodeMirror-crosshair"), off(document, "keyup", up), off(document, "mouseover", up))
        }
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair"), on(document, "keyup", up), on(document, "mouseover", up)
    }
    function onKeyUp(e) {
        16 == e.keyCode && (this.doc.sel.shift = !1), signalDOMEvent(this, e)
    }
    function onKeyPress(e) {
        var cm = this;
        if (!(signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)) {
            var keyCode = e.keyCode, charCode = e.charCode;
            if (presto && keyCode == lastStoppedKey)
                return lastStoppedKey = null, void e_preventDefault(e);
            if (!(presto && (!e.which || e.which < 10) || khtml) || !handleKeyBinding(cm, e)) {
                var ch = String.fromCharCode(null == charCode ? keyCode : charCode);
                handleCharBinding(cm, e, ch) || (ie && ie_version >= 9 && (cm.display.inputHasSelection = null), fastPoll(cm))
            }
        }
    }
    function onFocus(cm) {
        "nocursor" != cm.options.readOnly && (cm.state.focused || (signal(cm, "focus", cm), cm.state.focused = !0, addClass(cm.display.wrapper, "CodeMirror-focused"), cm.curOp || cm.display.selForContextMenu == cm.doc.sel || (resetInput(cm), webkit && setTimeout(bind(resetInput, cm, !0), 0))), slowPoll(cm), restartBlink(cm))
    }
    function onBlur(cm) {
        cm.state.focused && (signal(cm, "blur", cm), cm.state.focused = !1, rmClass(cm.display.wrapper, "CodeMirror-focused")), clearInterval(cm.display.blinker), setTimeout(function () {
            cm.state.focused || (cm.display.shift = !1)
        }, 150)
    }
    function onContextMenu(cm, e) {
        function prepareSelectAllHack() {
            if (null != display.input.selectionStart) {
                var selected = cm.somethingSelected(), extval = display.input.value = "\u200b" + (selected ? display.input.value : "");
                display.prevInput = selected ? "" : "\u200b", display.input.selectionStart = 1, display.input.selectionEnd = extval.length, display.selForContextMenu = cm.doc.sel
            }
        }
        function rehide() {
            if (display.contextMenuPending = !1, display.inputDiv.style.position = "relative", display.input.style.cssText = oldCSS, ie && 9 > ie_version && display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos), slowPoll(cm), null != display.input.selectionStart) {
                (!ie || ie && 9 > ie_version) && prepareSelectAllHack();
                var i = 0, poll = function () {
                    display.selForContextMenu == cm.doc.sel && 0 == display.input.selectionStart ? operation(cm, commands.selectAll)(cm) : i++ < 10 ? display.detectingSelectAll = setTimeout(poll, 500) : resetInput(cm)
                };
                display.detectingSelectAll = setTimeout(poll, 200)
            }
        }
        if (!signalDOMEvent(cm, e, "contextmenu")) {
            var display = cm.display;
            if (!eventInWidget(display, e) && !contextMenuInGutter(cm, e)) {
                var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
                if (pos && !presto) {
                    var reset = cm.options.resetSelectionOnContextMenu;
                    reset && -1 == cm.doc.sel.contains(pos) && operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
                    var oldCSS = display.input.style.cssText;
                    if (display.inputDiv.style.position = "absolute", display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) + "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);", webkit)
                        var oldScrollY = window.scrollY;
                    if (focusInput(cm), webkit && window.scrollTo(null, oldScrollY), resetInput(cm), cm.somethingSelected() || (display.input.value = display.prevInput = " "), display.contextMenuPending = !0, display.selForContextMenu = cm.doc.sel, clearTimeout(display.detectingSelectAll), ie && ie_version >= 9 && prepareSelectAllHack(), captureRightClick) {
                        e_stop(e);
                        var mouseup = function () {
                            off(window, "mouseup", mouseup), setTimeout(rehide, 20)
                        };
                        on(window, "mouseup", mouseup)
                    } else
                        setTimeout(rehide, 50)
                }
            }
        }
    }
    function contextMenuInGutter(cm, e) {
        return hasHandler(cm, "gutterContextMenu") ? gutterEvent(cm, e, "gutterContextMenu", !1, signal) : !1
    }
    function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0)
            return pos;
        if (cmp(pos, change.to) <= 0)
            return changeEnd(change);
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        return pos.line == change.to.line && (ch += changeEnd(change).ch - change.to.ch), Pos(line, ch)
    }
    function computeSelAfterChange(doc, change) {
        for (var out = [], i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i];
            out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)))
        }
        return normalizeSelection(out, doc.sel.primIndex)
    }
    function offsetPos(pos, old, nw) {
        return pos.line == old.line ? Pos(nw.line, pos.ch - old.ch + nw.ch) : Pos(nw.line + (pos.line - old.line), pos.ch)
    }
    function computeReplacedSel(doc, changes, hint) {
        for (var out = [], oldPrev = Pos(doc.first, 0), newPrev = oldPrev, i = 0; i < changes.length; i++) {
            var change = changes[i], from = offsetPos(change.from, oldPrev, newPrev), to = offsetPos(changeEnd(change), oldPrev, newPrev);
            if (oldPrev = change.to, newPrev = to, "around" == hint) {
                var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
                out[i] = new Range(inv ? to : from, inv ? from : to)
            } else
                out[i] = new Range(from, from)
        }
        return new Selection(out, doc.sel.primIndex)
    }
    function filterChange(doc, change, update) {
        var obj = {canceled: !1, from: change.from, to: change.to, text: change.text, origin: change.origin, cancel: function () {
                this.canceled = !0
            }};
        return update && (obj.update = function (from, to, text, origin) {
            from && (this.from = clipPos(doc, from)), to && (this.to = clipPos(doc, to)), text && (this.text = text), void 0 !== origin && (this.origin = origin)
        }), signal(doc, "beforeChange", doc, obj), doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj), obj.canceled ? null : {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
    }
    function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
            if (!doc.cm.curOp)
                return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            if (doc.cm.state.suppressEdits)
                return
        }
        if (!(hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) || (change = filterChange(doc, change, !0))) {
            var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
            if (split)
                for (var i = split.length - 1; i >= 0; --i)
                    makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
            else
                makeChangeInner(doc, change)
        }
    }
    function makeChangeInner(doc, change) {
        if (1 != change.text.length || "" != change.text[0] || 0 != cmp(change.from, change.to)) {
            var selAfter = computeSelAfterChange(doc, change);
            addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN), makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
            var rebased = [];
            linkedDocs(doc, function (doc, sharedHist) {
                sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change), rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))
            })
        }
    }
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        if (!doc.cm || !doc.cm.state.suppressEdits) {
            for (var event, hist = doc.history, selAfter = doc.sel, source = "undo" == type ? hist.done : hist.undone, dest = "undo" == type ? hist.undone : hist.done, i = 0; i < source.length && (event = source[i], allowSelectionOnly?!event.ranges || event.equals(doc.sel):event.ranges); i++)
                ;
            if (i != source.length) {
                for (hist.lastOrigin = hist.lastSelOrigin = null; event = source.pop(), event.ranges; ) {
                    if (pushSelectionToHistory(event, dest), allowSelectionOnly && !event.equals(doc.sel))
                        return void setSelection(doc, event, {clearRedo: !1});
                    selAfter = event
                }
                var antiChanges = [];
                pushSelectionToHistory(selAfter, dest), dest.push({changes: antiChanges, generation: hist.generation}), hist.generation = event.generation || ++hist.maxGeneration;
                for (var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange"), i = event.changes.length - 1; i >= 0; --i) {
                    var change = event.changes[i];
                    if (change.origin = type, filter && !filterChange(doc, change, !1))
                        return void(source.length = 0);
                    antiChanges.push(historyChangeFromChange(doc, change));
                    var after = i ? computeSelAfterChange(doc, change) : lst(source);
                    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change)), !i && doc.cm && doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
                    var rebased = [];
                    linkedDocs(doc, function (doc, sharedHist) {
                        sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change), rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
                    })
                }
            }
        }
    }
    function shiftDoc(doc, distance) {
        if (0 != distance && (doc.first += distance, doc.sel = new Selection(map(doc.sel.ranges, function (range) {
            return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch))
        }), doc.sel.primIndex), doc.cm)) {
            regChange(doc.cm, doc.first, doc.first - distance, distance);
            for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
                regLineChange(doc.cm, l, "gutter")
        }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp)
            return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        if (change.to.line < doc.first)
            return void shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
        if (!(change.from.line > doc.lastLine())) {
            if (change.from.line < doc.first) {
                var shift = change.text.length - 1 - (doc.first - change.from.line);
                shiftDoc(doc, shift), change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch), text: [lst(change.text)], origin: change.origin}
            }
            var last = doc.lastLine();
            change.to.line > last && (change = {from: change.from, to: Pos(last, getLine(doc, last).text.length), text: [change.text[0]], origin: change.origin}), change.removed = getBetween(doc, change.from, change.to), selAfter || (selAfter = computeSelAfterChange(doc, change)), doc.cm ? makeChangeSingleDocInEditor(doc.cm, change, spans) : updateDoc(doc, change, spans), setSelectionNoUndo(doc, selAfter, sel_dontScroll)
        }
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc, display = cm.display, from = change.from, to = change.to, recomputeMaxLength = !1, checkWidthStart = from.line;
        cm.options.lineWrapping || (checkWidthStart = lineNo(visualLine(getLine(doc, from.line))), doc.iter(checkWidthStart, to.line + 1, function (line) {
            return line == display.maxLine ? (recomputeMaxLength = !0, !0) : void 0
        })), doc.sel.contains(change.from, change.to) > -1 && signalCursorActivity(cm), updateDoc(doc, change, spans, estimateHeight(cm)), cm.options.lineWrapping || (doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
            var len = lineLength(line);
            len > display.maxLineLength && (display.maxLine = line, display.maxLineLength = len, display.maxLineChanged = !0, recomputeMaxLength = !1)
        }), recomputeMaxLength && (cm.curOp.updateMaxLine = !0)), doc.frontier = Math.min(doc.frontier, from.line), startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        from.line != to.line || 1 != change.text.length || isWholeLineUpdate(cm.doc, change) ? regChange(cm, from.line, to.line + 1, lendiff) : regLineChange(cm, from.line, "text");
        var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
            var obj = {from: from, to: to, text: change.text, removed: change.removed, origin: change.origin};
            changeHandler && signalLater(cm, "change", cm, obj), changesHandler && (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj)
        }
        cm.display.selForContextMenu = null
    }
    function replaceRange(doc, code, from, to, origin) {
        if (to || (to = from), cmp(to, from) < 0) {
            var tmp = to;
            to = from, from = tmp
        }
        "string" == typeof code && (code = splitLines(code)), makeChange(doc, {from: from, to: to, text: code, origin: origin})
    }
    function maybeScrollWindow(cm, coords) {
        if (!signalDOMEvent(cm, "scrollCursorIntoView")) {
            var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
            if (coords.top + box.top < 0 ? doScroll = !0 : coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = !1), null != doScroll && !phantom) {
                var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " + coords.left + "px; width: 2px;");
                cm.display.lineSpace.appendChild(scrollNode), scrollNode.scrollIntoView(doScroll), cm.display.lineSpace.removeChild(scrollNode)
            }
        }
    }
    function scrollPosIntoView(cm, pos, end, margin) {
        null == margin && (margin = 0);
        for (var limit = 0; 5 > limit; limit++) {
            var changed = !1, coords = cursorCoords(cm, pos), endCoords = end && end != pos ? cursorCoords(cm, end) : coords, scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin), startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (null != scrollPos.scrollTop && (setScrollTop(cm, scrollPos.scrollTop), Math.abs(cm.doc.scrollTop - startTop) > 1 && (changed = !0)), null != scrollPos.scrollLeft && (setScrollLeft(cm, scrollPos.scrollLeft), Math.abs(cm.doc.scrollLeft - startLeft) > 1 && (changed = !0)), !changed)
                break
        }
        return coords
    }
    function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        null != scrollPos.scrollTop && setScrollTop(cm, scrollPos.scrollTop), null != scrollPos.scrollLeft && setScrollLeft(cm, scrollPos.scrollLeft)
    }
    function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display, snapMargin = textHeight(cm.display);
        0 > y1 && (y1 = 0);
        var screentop = cm.curOp && null != cm.curOp.scrollTop ? cm.curOp.scrollTop : display.scroller.scrollTop, screen = displayHeight(cm), result = {};
        y2 - y1 > screen && (y2 = y1 + screen);
        var docBottom = cm.doc.height + paddingVert(display), atTop = snapMargin > y1, atBottom = y2 > docBottom - snapMargin;
        if (screentop > y1)
            result.scrollTop = atTop ? 0 : y1;
        else if (y2 > screentop + screen) {
            var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
            newTop != screentop && (result.scrollTop = newTop)
        }
        var screenleft = cm.curOp && null != cm.curOp.scrollLeft ? cm.curOp.scrollLeft : display.scroller.scrollLeft, screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0), tooWide = x2 - x1 > screenw;
        return tooWide && (x2 = x1 + screenw), 10 > x1 ? result.scrollLeft = 0 : screenleft > x1 ? result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) : x2 > screenw + screenleft - 3 && (result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw), result
    }
    function addToScrollPos(cm, left, top) {
        (null != left || null != top) && resolveScrollToPos(cm), null != left && (cm.curOp.scrollLeft = (null == cm.curOp.scrollLeft ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left), null != top && (cm.curOp.scrollTop = (null == cm.curOp.scrollTop ? cm.doc.scrollTop : cm.curOp.scrollTop) + top)
    }
    function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor(), from = cur, to = cur;
        cm.options.lineWrapping || (from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur, to = Pos(cur.line, cur.ch + 1)), cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: !0}
    }
    function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;
        if (range) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to), sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
            cm.scrollTo(sPos.scrollLeft, sPos.scrollTop)
        }
    }
    function indentLine(cm, n, how, aggressive) {
        var state, doc = cm.doc;
        null == how && (how = "add"), "smart" == how && (doc.mode.indent ? state = getStateBefore(cm, n) : how = "prev");
        var tabSize = cm.options.tabSize, line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
        line.stateAfter && (line.stateAfter = null);
        var indentation, curSpaceString = line.text.match(/^\s*/)[0];
        if (aggressive || /\S/.test(line.text)) {
            if ("smart" == how && (indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text), indentation == Pass || indentation > 150)) {
                if (!aggressive)
                    return;
                how = "prev"
            }
        } else
            indentation = 0, how = "not";
        "prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how), indentation = Math.max(0, indentation);
        var indentString = "", pos = 0;
        if (cm.options.indentWithTabs)
            for (var i = Math.floor(indentation / tabSize); i; --i)
                pos += tabSize, indentString += "	";
        if (indentation > pos && (indentString += spaceStr(indentation - pos)), indentString != curSpaceString)
            replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
        else
            for (var i = 0; i < doc.sel.ranges.length; i++) {
                var range = doc.sel.ranges[i];
                if (range.head.line == n && range.head.ch < curSpaceString.length) {
                    var pos = Pos(n, curSpaceString.length);
                    replaceOneSelection(doc, i, new Range(pos, pos));
                    break
                }
            }
        line.stateAfter = null
    }
    function changeLine(doc, handle, changeType, op) {
        var no = handle, line = handle;
        return"number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle), null == no ? null : (op(line, no) && doc.cm && regLineChange(doc.cm, no, changeType), line)
    }
    function deleteNearSelection(cm, compute) {
        for (var ranges = cm.doc.sel.ranges, kill = [], i = 0; i < ranges.length; i++) {
            for (var toKill = compute(ranges[i]); kill.length && cmp(toKill.from, lst(kill).to) <= 0; ) {
                var replaced = kill.pop();
                if (cmp(replaced.from, toKill.from) < 0) {
                    toKill.from = replaced.from;
                    break
                }
            }
            kill.push(toKill)
        }
        runInOp(cm, function () {
            for (var i = kill.length - 1; i >= 0; i--)
                replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
            ensureCursorVisible(cm)
        })
    }
    function findPosH(doc, pos, dir, unit, visually) {
        function findNextLine() {
            var l = line + dir;
            return l < doc.first || l >= doc.first + doc.size ? possible = !1 : (line = l, lineObj = getLine(doc, l))
        }
        function moveOnce(boundToLine) {
            var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, !0);
            if (null == next) {
                if (boundToLine || !findNextLine())
                    return possible = !1;
                ch = visually ? (0 > dir ? lineRight : lineLeft)(lineObj) : 0 > dir ? lineObj.text.length : 0
            } else
                ch = next;
            return!0
        }
        var line = pos.line, ch = pos.ch, origDir = dir, lineObj = getLine(doc, line), possible = !0;
        if ("char" == unit)
            moveOnce();
        else if ("column" == unit)
            moveOnce(!0);
        else if ("word" == unit || "group" == unit)
            for (var sawType = null, group = "group" == unit, helper = doc.cm && doc.cm.getHelper(pos, "wordChars"), first = !0; !(0 > dir) || moveOnce(!first); first = !1) {
                var cur = lineObj.text.charAt(ch) || "\n", type = isWordChar(cur, helper) ? "w" : group && "\n" == cur ? "n" : !group || /\s/.test(cur) ? null : "p";
                if (!group || first || type || (type = "s"), sawType && sawType != type) {
                    0 > dir && (dir = 1, moveOnce());
                    break
                }
                if (type && (sawType = type), dir > 0 && !moveOnce(!first))
                    break
            }
        var result = skipAtomic(doc, Pos(line, ch), origDir, !0);
        return possible || (result.hitSide = !0), result
    }
    function findPosV(cm, pos, dir, unit) {
        var y, doc = cm.doc, x = pos.left;
        if ("page" == unit) {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            y = pos.top + dir * (pageSize - (0 > dir ? 1.5 : .5) * textHeight(cm.display))
        } else
            "line" == unit && (y = dir > 0 ? pos.bottom + 3 : pos.top - 3);
        for (; ; ) {
            var target = coordsChar(cm, x, y);
            if (!target.outside)
                break;
            if (0 > dir ? 0 >= y : y >= doc.height) {
                target.hitSide = !0;
                break
            }
            y += 5 * dir
        }
        return target
    }
    function option(name, deflt, handle, notOnInit) {
        CodeMirror.defaults[name] = deflt, handle && (optionHandlers[name] = notOnInit ? function (cm, val, old) {
            old != Init && handle(cm, val, old)
        } : handle)
    }
    function normalizeKeyName(name) {
        for (var alt, ctrl, shift, cmd, parts = name.split(/-(?!$)/), name = parts[parts.length - 1], i = 0; i < parts.length - 1; i++) {
            var mod = parts[i];
            if (/^(cmd|meta|m)$/i.test(mod))
                cmd = !0;
            else if (/^a(lt)?$/i.test(mod))
                alt = !0;
            else if (/^(c|ctrl|control)$/i.test(mod))
                ctrl = !0;
            else {
                if (!/^s(hift)$/i.test(mod))
                    throw new Error("Unrecognized modifier name: " + mod);
                shift = !0
            }
        }
        return alt && (name = "Alt-" + name), ctrl && (name = "Ctrl-" + name), cmd && (name = "Cmd-" + name), shift && (name = "Shift-" + name), name
    }
    function getKeyMap(val) {
        return"string" == typeof val ? keyMap[val] : val
    }
    function markText(doc, from, to, options, type) {
        if (options && options.shared)
            return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp)
            return operation(doc.cm, markText)(doc, from, to, options, type);
        var marker = new TextMarker(doc, type), diff = cmp(from, to);
        if (options && copyObj(options, marker, !1), diff > 0 || 0 == diff && marker.clearWhenEmpty !== !1)
            return marker;
        if (marker.replacedWith && (marker.collapsed = !0, marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget"), options.handleMouseEvents || marker.widgetNode.setAttribute("cm-ignore-events", "true"), options.insertLeft && (marker.widgetNode.insertLeft = !0)), marker.collapsed) {
            if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
                throw new Error("Inserting collapsed marker partially overlapping an existing one");
            sawCollapsedSpans = !0
        }
        marker.addToHistory && addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);
        var updateMaxLine, curLine = from.line, cm = doc.cm;
        if (doc.iter(curLine, to.line + 1, function (line) {
            cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine && (updateMaxLine = !0), marker.collapsed && curLine != from.line && updateLineHeight(line, 0), addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null)), ++curLine
        }), marker.collapsed && doc.iter(from.line, to.line + 1, function (line) {
            lineIsHidden(doc, line) && updateLineHeight(line, 0)
        }), marker.clearOnEnter && on(marker, "beforeCursorEnter", function () {
            marker.clear()
        }), marker.readOnly && (sawReadOnlySpans = !0, (doc.history.done.length || doc.history.undone.length) && doc.clearHistory()), marker.collapsed && (marker.id = ++nextMarkerId, marker.atomic = !0), cm) {
            if (updateMaxLine && (cm.curOp.updateMaxLine = !0), marker.collapsed)
                regChange(cm, from.line, to.line + 1);
            else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
                for (var i = from.line; i <= to.line; i++)
                    regLineChange(cm, i, "text");
            marker.atomic && reCheckSelection(cm.doc), signalLater(cm, "markerAdded", cm, marker)
        }
        return marker
    }
    function markTextShared(doc, from, to, options, type) {
        options = copyObj(options), options.shared = !1;
        var markers = [markText(doc, from, to, options, type)], primary = markers[0], widget = options.widgetNode;
        return linkedDocs(doc, function (doc) {
            widget && (options.widgetNode = widget.cloneNode(!0)), markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
            for (var i = 0; i < doc.linked.length; ++i)
                if (doc.linked[i].isParent)
                    return;
            primary = lst(markers)
        }), new SharedTextMarker(markers, primary)
    }
    function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
            return m.parent
        })
    }
    function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i], pos = marker.find(), mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
                var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                marker.markers.push(subMark), subMark.parent = marker
            }
        }
    }
    function detachSharedMarkers(markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i], linked = [marker.primary.doc];
            linkedDocs(marker.primary.doc, function (d) {
                linked.push(d)
            });
            for (var j = 0; j < marker.markers.length; j++) {
                var subMarker = marker.markers[j];
                -1 == indexOf(linked, subMarker.doc) && (subMarker.parent = null, marker.markers.splice(j--, 1))
            }
        }
    }
    function MarkedSpan(marker, from, to) {
        this.marker = marker, this.from = from, this.to = to
    }
    function getMarkedSpanFor(spans, marker) {
        if (spans)
            for (var i = 0; i < spans.length; ++i) {
                var span = spans[i];
                if (span.marker == marker)
                    return span
            }
    }
    function removeMarkedSpan(spans, span) {
        for (var r, i = 0; i < spans.length; ++i)
            spans[i] != span && (r || (r = [])).push(spans[i]);
        return r
    }
    function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span], span.marker.attachLine(line)
    }
    function markedSpansBefore(old, startCh, isInsert) {
        if (old)
            for (var nw, i = 0; i < old.length; ++i) {
                var span = old[i], marker = span.marker, startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                if (startsBefore || span.from == startCh && "bookmark" == marker.type && (!isInsert || !span.marker.insertLeft)) {
                    var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))
                }
            }
        return nw
    }
    function markedSpansAfter(old, endCh, isInsert) {
        if (old)
            for (var nw, i = 0; i < old.length; ++i) {
                var span = old[i], marker = span.marker, endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                if (endsAfter || span.from == endCh && "bookmark" == marker.type && (!isInsert || span.marker.insertLeft)) {
                    var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, null == span.to ? null : span.to - endCh))
                }
            }
        return nw
    }
    function stretchSpansOverChange(doc, change) {
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans, oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast)
            return null;
        var startCh = change.from.ch, endCh = change.to.ch, isInsert = 0 == cmp(change.from, change.to), first = markedSpansBefore(oldFirst, startCh, isInsert), last = markedSpansAfter(oldLast, endCh, isInsert), sameLine = 1 == change.text.length, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first)
            for (var i = 0; i < first.length; ++i) {
                var span = first[i];
                if (null == span.to) {
                    var found = getMarkedSpanFor(last, span.marker);
                    found ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh
                }
            }
        if (last)
            for (var i = 0; i < last.length; ++i) {
                var span = last[i];
                if (null != span.to && (span.to += offset), null == span.from) {
                    var found = getMarkedSpanFor(first, span.marker);
                    found || (span.from = offset, sameLine && (first || (first = [])).push(span))
                } else
                    span.from += offset, sameLine && (first || (first = [])).push(span)
            }
        first && (first = clearEmptySpans(first)), last && last != first && (last = clearEmptySpans(last));
        var newMarkers = [first];
        if (!sameLine) {
            var gapMarkers, gap = change.text.length - 2;
            if (gap > 0 && first)
                for (var i = 0; i < first.length; ++i)
                    null == first[i].to && (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
            for (var i = 0; gap > i; ++i)
                newMarkers.push(gapMarkers);
            newMarkers.push(last)
        }
        return newMarkers
    }
    function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            null != span.from && span.from == span.to && span.marker.clearWhenEmpty !== !1 && spans.splice(i--, 1)
        }
        return spans.length ? spans : null
    }
    function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change), stretched = stretchSpansOverChange(doc, change);
        if (!old)
            return stretched;
        if (!stretched)
            return old;
        for (var i = 0; i < old.length; ++i) {
            var oldCur = old[i], stretchCur = stretched[i];
            if (oldCur && stretchCur)
                spans:for (var j = 0; j < stretchCur.length; ++j) {
                    for (var span = stretchCur[j], k = 0; k < oldCur.length; ++k)
                        if (oldCur[k].marker == span.marker)
                            continue spans;
                    oldCur.push(span)
                }
            else
                stretchCur && (old[i] = stretchCur)
        }
        return old
    }
    function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        if (doc.iter(from.line, to.line + 1, function (line) {
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans.length; ++i) {
                    var mark = line.markedSpans[i].marker;
                    !mark.readOnly || markers && -1 != indexOf(markers, mark) || (markers || (markers = [])).push(mark)
                }
        }), !markers)
            return null;
        for (var parts = [{from: from, to: to}], i = 0; i < markers.length; ++i)
            for (var mk = markers[i], m = mk.find(0), j = 0; j < parts.length; ++j) {
                var p = parts[j];
                if (!(cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)) {
                    var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
                    (0 > dfrom || !mk.inclusiveLeft && !dfrom) && newParts.push({from: p.from, to: m.from}), (dto > 0 || !mk.inclusiveRight && !dto) && newParts.push({from: m.to, to: p.to}), parts.splice.apply(parts, newParts), j += newParts.length - 1
                }
            }
        return parts
    }
    function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (spans) {
            for (var i = 0; i < spans.length; ++i)
                spans[i].marker.detachLine(line);
            line.markedSpans = null
        }
    }
    function attachMarkedSpans(line, spans) {
        if (spans) {
            for (var i = 0; i < spans.length; ++i)
                spans[i].marker.attachLine(line);
            line.markedSpans = spans
        }
    }
    function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0
    }
    function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0
    }
    function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (0 != lenDiff)
            return lenDiff;
        var aPos = a.find(), bPos = b.find(), fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp)
            return-fromCmp;
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        return toCmp ? toCmp : b.id - a.id
    }
    function collapsedSpanAtSide(line, start) {
        var found, sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var sp, i = 0; i < sps.length; ++i)
                sp = sps[i], sp.marker.collapsed && null == (start ? sp.from : sp.to) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker);
        return found
    }
    function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, !0)
    }
    function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, !1)
    }
    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo), sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var i = 0; i < sps.length; ++i) {
                var sp = sps[i];
                if (sp.marker.collapsed) {
                    var found = sp.marker.find(0), fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker), toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                    if (!(fromCmp >= 0 && 0 >= toCmp || 0 >= fromCmp && toCmp >= 0) && (0 >= fromCmp && (cmp(found.to, from) > 0 || sp.marker.inclusiveRight && marker.inclusiveLeft) || fromCmp >= 0 && (cmp(found.from, to) < 0 || sp.marker.inclusiveLeft && marker.inclusiveRight)))
                        return!0
                }
            }
    }
    function visualLine(line) {
        for (var merged; merged = collapsedSpanAtStart(line); )
            line = merged.find(-1, !0).line;
        return line
    }
    function visualLineContinued(line) {
        for (var merged, lines; merged = collapsedSpanAtEnd(line); )
            line = merged.find(1, !0).line, (lines || (lines = [])).push(line);
        return lines
    }
    function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN), vis = visualLine(line);
        return line == vis ? lineN : lineNo(vis)
    }
    function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine())
            return lineN;
        var merged, line = getLine(doc, lineN);
        if (!lineIsHidden(doc, line))
            return lineN;
        for (; merged = collapsedSpanAtEnd(line); )
            line = merged.find(1, !0).line;
        return lineNo(line) + 1
    }
    function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var sp, i = 0; i < sps.length; ++i)
                if (sp = sps[i], sp.marker.collapsed) {
                    if (null == sp.from)
                        return!0;
                    if (!sp.marker.widgetNode && 0 == sp.from && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
                        return!0
                }
    }
    function lineIsHiddenInner(doc, line, span) {
        if (null == span.to) {
            var end = span.marker.find(1, !0);
            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
        }
        if (span.marker.inclusiveRight && span.to == line.text.length)
            return!0;
        for (var sp, i = 0; i < line.markedSpans.length; ++i)
            if (sp = line.markedSpans[i], sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (null == sp.to || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
                return!0
    }
    function adjustScrollWhenAboveVisible(cm, line, diff) {
        heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop) && addToScrollPos(cm, null, diff)
    }
    function widgetHeight(widget) {
        if (null != widget.height)
            return widget.height;
        if (!contains(document.body, widget.node)) {
            var parentStyle = "position: relative;";
            widget.coverGutter && (parentStyle += "margin-left: -" + widget.cm.getGutterElement().offsetWidth + "px;"), removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, parentStyle))
        }
        return widget.height = widget.node.offsetHeight
    }
    function addLineWidget(cm, handle, node, options) {
        var widget = new LineWidget(cm, node, options);
        return widget.noHScroll && (cm.display.alignWidgets = !0), changeLine(cm.doc, handle, "widget", function (line) {
            var widgets = line.widgets || (line.widgets = []);
            if (null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget), widget.line = line, !lineIsHidden(cm.doc, line)) {
                var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
                updateLineHeight(line, line.height + widgetHeight(widget)), aboveVisible && addToScrollPos(cm, null, widget.height), cm.curOp.forceUpdate = !0
            }
            return!0
        }), widget
    }
    function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text, line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null), null != line.order && (line.order = null), detachMarkedSpans(line), attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        estHeight != line.height && updateLineHeight(line, estHeight)
    }
    function cleanUpLine(line) {
        line.parent = null, detachMarkedSpans(line)
    }
    function extractLineClasses(type, output) {
        if (type)
            for (; ; ) {
                var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                if (!lineClass)
                    break;
                type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                var prop = lineClass[1] ? "bgClass" : "textClass";
                null == output[prop] ? output[prop] = lineClass[2] : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(output[prop]) || (output[prop] += " " + lineClass[2])
            }
        return type
    }
    function callBlankLine(mode, state) {
        if (mode.blankLine)
            return mode.blankLine(state);
        if (mode.innerMode) {
            var inner = CodeMirror.innerMode(mode, state);
            return inner.mode.blankLine ? inner.mode.blankLine(inner.state) : void 0
        }
    }
    function readToken(mode, stream, state, inner) {
        for (var i = 0; 10 > i; i++) {
            inner && (inner[0] = CodeMirror.innerMode(mode, state).mode);
            var style = mode.token(stream, state);
            if (stream.pos > stream.start)
                return style
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.")
    }
    function takeToken(cm, pos, precise, asArray) {
        function getObj(copy) {
            return{start: stream.start, end: stream.pos, string: stream.current(), type: style || null, state: copy ? copyState(doc.mode, state) : state}
        }
        var style, doc = cm.doc, mode = doc.mode;
        pos = clipPos(doc, pos);
        var tokens, line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise), stream = new StringStream(line.text, cm.options.tabSize);
        for (asArray && (tokens = []); (asArray || stream.pos < pos.ch) && !stream.eol(); )
            stream.start = stream.pos, style = readToken(mode, stream, state), asArray && tokens.push(getObj(!0));
        return asArray ? tokens : getObj()
    }
    function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        null == flattenSpans && (flattenSpans = cm.options.flattenSpans);
        var style, curStart = 0, curStyle = null, stream = new StringStream(text, cm.options.tabSize), inner = cm.options.addModeClass && [null];
        for ("" == text && extractLineClasses(callBlankLine(mode, state), lineClasses); !stream.eol(); ) {
            if (stream.pos > cm.options.maxHighlightLength ? (flattenSpans = !1, forceToEnd && processLine(cm, text, state, stream.pos), stream.pos = text.length, style = null) : style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses), inner) {
                var mName = inner[0].name;
                mName && (style = "m-" + (style ? mName + " " + style : mName))
            }
            if (!flattenSpans || curStyle != style) {
                for (; curStart < stream.start; )
                    curStart = Math.min(stream.start, curStart + 5e4), f(curStart, curStyle);
                curStyle = style
            }
            stream.start = stream.pos
        }
        for (; curStart < stream.pos; ) {
            var pos = Math.min(stream.pos, curStart + 5e4);
            f(pos, curStyle), curStart = pos
        }
    }
    function highlightLine(cm, line, state, forceToEnd) {
        var st = [cm.state.modeGen], lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
            st.push(end, style)
        }, lineClasses, forceToEnd);
        for (var o = 0; o < cm.state.overlays.length; ++o) {
            var overlay = cm.state.overlays[o], i = 1, at = 0;
            runMode(cm, line.text, overlay.mode, !0, function (end, style) {
                for (var start = i; end > at; ) {
                    var i_end = st[i];
                    i_end > end && st.splice(i, 1, end, st[i + 1], i_end), i += 2, at = Math.min(end, i_end)
                }
                if (style)
                    if (overlay.opaque)
                        st.splice(start, i - start, end, "cm-overlay " + style), i = start + 2;
                    else
                        for (; i > start; start += 2) {
                            var cur = st[start + 1];
                            st[start + 1] = (cur ? cur + " " : "") + "cm-overlay " + style
                        }
            }, lineClasses)
        }
        return{styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
    }
    function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
            line.styles = result.styles, result.classes ? line.styleClasses = result.classes : line.styleClasses && (line.styleClasses = null), updateFrontier === cm.doc.frontier && cm.doc.frontier++
        }
        return line.styles
    }
    function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode, stream = new StringStream(text, cm.options.tabSize);
        for (stream.start = stream.pos = startAt || 0, "" == text && callBlankLine(mode, state); !stream.eol() && stream.pos <= cm.options.maxHighlightLength; )
            readToken(mode, stream, state), stream.start = stream.pos
    }
    function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style))
            return null;
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"))
    }
    function buildLineContent(cm, lineView) {
        var content = elt("span", null, null, webkit ? "padding-right: .1px" : null), builder = {pre: elt("pre", [content]), content: content, col: 0, pos: 0, cm: cm};
        lineView.measure = {};
        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
            var order, line = i ? lineView.rest[i - 1] : lineView.line;
            builder.pos = 0, builder.addToken = buildToken, (ie || webkit) && cm.getOption("lineWrapping") && (builder.addToken = buildTokenSplitSpaces(builder.addToken)), hasBadBidiRects(cm.display.measure) && (order = getOrder(line)) && (builder.addToken = buildTokenBadBidi(builder.addToken, order)), builder.map = [];
            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate)), line.styleClasses && (line.styleClasses.bgClass && (builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "")), line.styleClasses.textClass && (builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""))), 0 == builder.map.length && builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))), 0 == i ? (lineView.measure.map = builder.map, lineView.measure.cache = {}) : ((lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map), (lineView.measure.caches || (lineView.measure.caches = [])).push({}))
        }
        return webkit && /\bcm-tab\b/.test(builder.content.lastChild.className) && (builder.content.className = "cm-tab-wrap-hack"), signal(cm, "renderLine", cm, lineView.line, builder.pre), builder.pre.className && (builder.textClass = joinClasses(builder.pre.className, builder.textClass || "")), builder
    }
    function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        return token.title = "\\u" + ch.charCodeAt(0).toString(16), token
    }
    function buildToken(builder, text, style, startStyle, endStyle, title, css) {
        if (text) {
            var special = builder.cm.options.specialChars, mustWrap = !1;
            if (special.test(text))
                for (var content = document.createDocumentFragment(), pos = 0; ; ) {
                    special.lastIndex = pos;
                    var m = special.exec(text), skipped = m ? m.index - pos : text.length - pos;
                    if (skipped) {
                        var txt = document.createTextNode(text.slice(pos, pos + skipped));
                        ie && 9 > ie_version ? content.appendChild(elt("span", [txt])) : content.appendChild(txt), builder.map.push(builder.pos, builder.pos + skipped, txt), builder.col += skipped, builder.pos += skipped
                    }
                    if (!m)
                        break;
                    if (pos += skipped + 1, "	" == m[0]) {
                        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize, txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                        builder.col += tabWidth
                    } else {
                        var txt = builder.cm.options.specialCharPlaceholder(m[0]);
                        ie && 9 > ie_version ? content.appendChild(elt("span", [txt])) : content.appendChild(txt), builder.col += 1
                    }
                    builder.map.push(builder.pos, builder.pos + 1, txt), builder.pos++
                }
            else {
                builder.col += text.length;
                var content = document.createTextNode(text);
                builder.map.push(builder.pos, builder.pos + text.length, content), ie && 9 > ie_version && (mustWrap = !0), builder.pos += text.length
            }
            if (style || startStyle || endStyle || mustWrap || css) {
                var fullStyle = style || "";
                startStyle && (fullStyle += startStyle), endStyle && (fullStyle += endStyle);
                var token = elt("span", [content], fullStyle, css);
                return title && (token.title = title), builder.content.appendChild(token)
            }
            builder.content.appendChild(content)
        }
    }
    function buildTokenSplitSpaces(inner) {
        function split(old) {
            for (var out = " ", i = 0; i < old.length - 2; ++i)
                out += i % 2 ? " " : "\xa0";
            return out += " "
        }
        return function (builder, text, style, startStyle, endStyle, title) {
            inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
        }
    }
    function buildTokenBadBidi(inner, order) {
        return function (builder, text, style, startStyle, endStyle, title) {
            style = style ? style + " cm-force-border" : "cm-force-border";
            for (var start = builder.pos, end = start + text.length; ; ) {
                for (var i = 0; i < order.length; i++) {
                    var part = order[i];
                    if (part.to > start && part.from <= start)
                        break
                }
                if (part.to >= end)
                    return inner(builder, text, style, startStyle, endStyle, title);
                inner(builder, text.slice(0, part.to - start), style, startStyle, null, title), startStyle = null, text = text.slice(part.to - start), start = part.to
            }
        }
    }
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        widget && (builder.map.push(builder.pos, builder.pos + size, widget), builder.content.appendChild(widget)), builder.pos += size
    }
    function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans, allText = line.text, at = 0;
        if (spans)
            for (var style, css, spanStyle, spanEndStyle, spanStartStyle, title, collapsed, len = allText.length, pos = 0, i = 1, text = "", nextChange = 0; ; ) {
                if (nextChange == pos) {
                    spanStyle = spanEndStyle = spanStartStyle = title = css = "", collapsed = null, nextChange = 1 / 0;
                    for (var foundBookmarks = [], j = 0; j < spans.length; ++j) {
                        var sp = spans[j], m = sp.marker;
                        sp.from <= pos && (null == sp.to || sp.to > pos) ? (null != sp.to && nextChange > sp.to && (nextChange = sp.to, spanEndStyle = ""), m.className && (spanStyle += " " + m.className), m.css && (css = m.css), m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle), m.endStyle && sp.to == nextChange && (spanEndStyle += " " + m.endStyle), m.title && !title && (title = m.title), m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0) && (collapsed = sp)) : sp.from > pos && nextChange > sp.from && (nextChange = sp.from), "bookmark" == m.type && sp.from == pos && m.widgetNode && foundBookmarks.push(m)
                    }
                    if (collapsed && (collapsed.from || 0) == pos && (buildCollapsedSpan(builder, (null == collapsed.to ? len + 1 : collapsed.to) - pos, collapsed.marker, null == collapsed.from), null == collapsed.to))
                        return;
                    if (!collapsed && foundBookmarks.length)
                        for (var j = 0; j < foundBookmarks.length; ++j)
                            buildCollapsedSpan(builder, 0, foundBookmarks[j])
                }
                if (pos >= len)
                    break;
                for (var upto = Math.min(len, nextChange); ; ) {
                    if (text) {
                        var end = pos + text.length;
                        if (!collapsed) {
                            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css)
                        }
                        if (end >= upto) {
                            text = text.slice(upto - pos), pos = upto;
                            break
                        }
                        pos = end, spanStartStyle = ""
                    }
                    text = allText.slice(at, at = styles[i++]), style = interpretTokenStyle(styles[i++], builder.cm.options)
                }
            }
        else
            for (var i = 1; i < styles.length; i += 2)
                builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder.cm.options))
    }
    function isWholeLineUpdate(doc, change) {
        return 0 == change.from.ch && 0 == change.to.ch && "" == lst(change.text) && (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
    }
    function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
            return markedSpans ? markedSpans[n] : null
        }
        function update(line, text, spans) {
            updateLine(line, text, spans, estimateHeight), signalLater(line, "change", line, change)
        }
        var from = change.from, to = change.to, text = change.text, firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line), lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
        if (isWholeLineUpdate(doc, change)) {
            for (var i = 0, added = []; i < text.length - 1; ++i)
                added.push(new Line(text[i], spansFor(i), estimateHeight));
            update(lastLine, lastLine.text, lastSpans), nlines && doc.remove(from.line, nlines), added.length && doc.insert(from.line, added)
        } else if (firstLine == lastLine)
            if (1 == text.length)
                update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            else {
                for (var added = [], i = 1; i < text.length - 1; ++i)
                    added.push(new Line(text[i], spansFor(i), estimateHeight));
                added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight)), update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), doc.insert(from.line + 1, added)
            }
        else if (1 == text.length)
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0)), doc.remove(from.line + 1, nlines);
        else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            for (var i = 1, added = []; i < text.length - 1; ++i)
                added.push(new Line(text[i], spansFor(i), estimateHeight));
            nlines > 1 && doc.remove(from.line + 1, nlines - 1), doc.insert(from.line + 1, added)
        }
        signalLater(doc, "change", doc, change)
    }
    function LeafChunk(lines) {
        this.lines = lines, this.parent = null;
        for (var i = 0, height = 0; i < lines.length; ++i)
            lines[i].parent = this, height += lines[i].height;
        this.height = height
    }
    function BranchChunk(children) {
        this.children = children;
        for (var size = 0, height = 0, i = 0; i < children.length; ++i) {
            var ch = children[i];
            size += ch.chunkSize(), height += ch.height, ch.parent = this
        }
        this.size = size, this.height = height, this.parent = null
    }
    function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
            if (doc.linked)
                for (var i = 0; i < doc.linked.length; ++i) {
                    var rel = doc.linked[i];
                    if (rel.doc != skip) {
                        var shared = sharedHist && rel.sharedHist;
                        (!sharedHistOnly || shared) && (f(rel.doc, shared), propagate(rel.doc, doc, shared))
                    }
                }
        }
        propagate(doc, null, !0)
    }
    function attachDoc(cm, doc) {
        if (doc.cm)
            throw new Error("This document is already in use.");
        cm.doc = doc, doc.cm = cm, estimateLineHeights(cm), loadMode(cm), cm.options.lineWrapping || findMaxLine(cm), cm.options.mode = doc.modeOption, regChange(cm)
    }
    function getLine(doc, n) {
        if (n -= doc.first, 0 > n || n >= doc.size)
            throw new Error("There is no line " + (n + doc.first) + " in the document.");
        for (var chunk = doc; !chunk.lines; )
            for (var i = 0; ; ++i) {
                var child = chunk.children[i], sz = child.chunkSize();
                if (sz > n) {
                    chunk = child;
                    break
                }
                n -= sz
            }
        return chunk.lines[n]
    }
    function getBetween(doc, start, end) {
        var out = [], n = start.line;
        return doc.iter(start.line, end.line + 1, function (line) {
            var text = line.text;
            n == end.line && (text = text.slice(0, end.ch)), n == start.line && (text = text.slice(start.ch)), out.push(text), ++n
        }), out
    }
    function getLines(doc, from, to) {
        var out = [];
        return doc.iter(from, to, function (line) {
            out.push(line.text)
        }), out
    }
    function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff)
            for (var n = line; n; n = n.parent)
                n.height += diff
    }
    function lineNo(line) {
        if (null == line.parent)
            return null;
        for (var cur = line.parent, no = indexOf(cur.lines, line), chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent)
            for (var i = 0; chunk.children[i] != cur; ++i)
                no += chunk.children[i].chunkSize();
        return no + cur.first
    }
    function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer:do {
            for (var i = 0; i < chunk.children.length; ++i) {
                var child = chunk.children[i], ch = child.height;
                if (ch > h) {
                    chunk = child;
                    continue outer
                }
                h -= ch, n += child.chunkSize()
            }
            return n
        } while (!chunk.lines);
        for (var i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i], lh = line.height;
            if (lh > h)
                break;
            h -= lh
        }
        return n + i
    }
    function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        for (var h = 0, chunk = lineObj.parent, i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i];
            if (line == lineObj)
                break;
            h += line.height
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent)
            for (var i = 0; i < p.children.length; ++i) {
                var cur = p.children[i];
                if (cur == chunk)
                    break;
                h += cur.height
            }
        return h
    }
    function getOrder(line) {
        var order = line.order;
        return null == order && (order = line.order = bidiOrdering(line.text)), order
    }
    function History(startGen) {
        this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = startGen || 1
    }
    function historyChangeFromChange(doc, change) {
        var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
        return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), linkedDocs(doc, function (doc) {
            attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)
        }, !0), histChange
    }
    function clearSelectionEvents(array) {
        for (; array.length; ) {
            var last = lst(array);
            if (!last.ranges)
                break;
            array.pop()
        }
    }
    function lastChangeEvent(hist, force) {
        return force ? (clearSelectionEvents(hist.done), lst(hist.done)) : hist.done.length && !lst(hist.done).ranges ? lst(hist.done) : hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges ? (hist.done.pop(), lst(hist.done)) : void 0
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var cur, time = +new Date;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || "*" == change.origin.charAt(0))) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            var last = lst(cur.changes);
            0 == cmp(change.from, change.to) && 0 == cmp(change.from, last.to) ? last.to = changeEnd(change) : cur.changes.push(historyChangeFromChange(doc, change))
        } else {
            var before = lst(hist.done);
            for (before && before.ranges || pushSelectionToHistory(doc.sel, hist.done), cur = {changes:[historyChangeFromChange(doc, change)], generation:hist.generation}, hist.done.push(cur); hist.done.length > hist.undoDepth; )
                hist.done.shift(), hist.done[0].ranges || hist.done.shift()
        }
        hist.done.push(selAfter), hist.generation = ++hist.maxGeneration, hist.lastModTime = hist.lastSelTime = time, hist.lastOp = hist.lastSelOp = opId, hist.lastOrigin = hist.lastSelOrigin = change.origin, last || signal(doc, "historyAdded")
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return"*" == ch || "+" == ch && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
    }
    function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history, origin = options && options.origin;
        opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)) ? hist.done[hist.done.length - 1] = sel : pushSelectionToHistory(sel, hist.done), hist.lastSelTime = +new Date, hist.lastSelOrigin = origin, hist.lastSelOp = opId, options && options.clearRedo !== !1 && clearSelectionEvents(hist.undone)
    }
    function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        top && top.ranges && top.equals(sel) || dest.push(sel)
    }
    function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id], n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
            line.markedSpans && ((existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans), ++n
        })
    }
    function removeClearedSpans(spans) {
        if (!spans)
            return null;
        for (var out, i = 0; i < spans.length; ++i)
            spans[i].marker.explicitlyCleared ? out || (out = spans.slice(0, i)) : out && out.push(spans[i]);
        return out ? out.length ? out : null : spans
    }
    function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found)
            return null;
        for (var i = 0, nw = []; i < change.text.length; ++i)
            nw.push(removeClearedSpans(found[i]));
        return nw
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
        for (var i = 0, copy = []; i < events.length; ++i) {
            var event = events[i];
            if (event.ranges)
                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            else {
                var changes = event.changes, newChanges = [];
                copy.push({changes: newChanges});
                for (var j = 0; j < changes.length; ++j) {
                    var m, change = changes[j];
                    if (newChanges.push({from: change.from, to: change.to, text: change.text}), newGroup)
                        for (var prop in change)
                            (m = prop.match(/^spans_(\d+)$/)) && indexOf(newGroup, Number(m[1])) > -1 && (lst(newChanges)[prop] = change[prop], delete change[prop])
                }
            }
        }
        return copy
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
        to < pos.line ? pos.line += diff : from < pos.line && (pos.line = from, pos.ch = 0)
    }
    function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
            var sub = array[i], ok = !0;
            if (sub.ranges) {
                sub.copied || (sub = array[i] = sub.deepCopy(), sub.copied = !0);
                for (var j = 0; j < sub.ranges.length; j++)
                    rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff), rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)
            } else {
                for (var j = 0; j < sub.changes.length; ++j) {
                    var cur = sub.changes[j];
                    if (to < cur.from.line)
                        cur.from = Pos(cur.from.line + diff, cur.from.ch), cur.to = Pos(cur.to.line + diff, cur.to.ch);
                    else if (from <= cur.to.line) {
                        ok = !1;
                        break
                    }
                }
                ok || (array.splice(0, i + 1), i = 0)
            }
        }
    }
    function rebaseHist(hist, change) {
        var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff), rebaseHistArray(hist.undone, from, to, diff)
    }
    function e_defaultPrevented(e) {
        return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
    }
    function e_target(e) {
        return e.target || e.srcElement
    }
    function e_button(e) {
        var b = e.which;
        return null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2)), mac && e.ctrlKey && 1 == b && (b = 3), b
    }
    function signalLater(emitter, type) {
        function bnd(f) {
            return function () {
                f.apply(null, args)
            }
        }
        var arr = emitter._handlers && emitter._handlers[type];
        if (arr) {
            var list, args = Array.prototype.slice.call(arguments, 2);
            operationGroup ? list = operationGroup.delayedCallbacks : orphanDelayedCallbacks ? list = orphanDelayedCallbacks : (list = orphanDelayedCallbacks = [], setTimeout(fireOrphanDelayed, 0));
            for (var i = 0; i < arr.length; ++i)
                list.push(bnd(arr[i]))
        }
    }
    function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i)
            delayed[i]()
    }
    function signalDOMEvent(cm, e, override) {
        return"string" == typeof e && (e = {type: e, preventDefault: function () {
                this.defaultPrevented = !0
            }}), signal(cm, override || e.type, cm, e), e_defaultPrevented(e) || e.codemirrorIgnore
    }
    function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (arr)
            for (var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []), i = 0; i < arr.length; ++i)
                -1 == indexOf(set, arr[i]) && set.push(arr[i])
    }
    function hasHandler(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        return arr && arr.length > 0
    }
    function eventMixin(ctor) {
        ctor.prototype.on = function (type, f) {
            on(this, type, f)
        }, ctor.prototype.off = function (type, f) {
            off(this, type, f)
        }
    }
    function Delayed() {
        this.id = null
    }
    function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0; ; ) {
            var nextTab = string.indexOf("	", pos);
            -1 == nextTab && (nextTab = string.length);
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal)
                return pos + Math.min(skipped, goal - col);
            if (col += nextTab - pos, col += tabSize - col % tabSize, pos = nextTab + 1, col >= goal)
                return pos
        }
    }
    function spaceStr(n) {
        for (; spaceStrs.length <= n; )
            spaceStrs.push(lst(spaceStrs) + " ");
        return spaceStrs[n]
    }
    function lst(arr) {
        return arr[arr.length - 1]
    }
    function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i)
            if (array[i] == elt)
                return i;
        return-1
    }
    function map(array, f) {
        for (var out = [], i = 0; i < array.length; i++)
            out[i] = f(array[i], i);
        return out
    }
    function createObj(base, props) {
        var inst;
        if (Object.create)
            inst = Object.create(base);
        else {
            var ctor = function () {
            };
            ctor.prototype = base, inst = new ctor
        }
        return props && copyObj(props, inst), inst
    }
    function copyObj(obj, target, overwrite) {
        target || (target = {});
        for (var prop in obj)
            !obj.hasOwnProperty(prop) || overwrite === !1 && target.hasOwnProperty(prop) || (target[prop] = obj[prop]);
        return target
    }
    function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return f.apply(null, args)
        }
    }
    function isWordChar(ch, helper) {
        return helper ? helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch) ? !0 : helper.test(ch) : isWordCharBasic(ch)
    }
    function isEmpty(obj) {
        for (var n in obj)
            if (obj.hasOwnProperty(n) && obj[n])
                return!1;
        return!0
    }
    function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch)
    }
    function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className && (e.className = className), style && (e.style.cssText = style), "string" == typeof content)
            e.appendChild(document.createTextNode(content));
        else if (content)
            for (var i = 0; i < content.length; ++i)
                e.appendChild(content[i]);
        return e
    }
    function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count)
            e.removeChild(e.firstChild);
        return e
    }
    function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e)
    }
    function contains(parent, child) {
        if (parent.contains)
            return parent.contains(child);
        for (; child = child.parentNode; )
            if (child == parent)
                return!0
    }
    function activeElt() {
        return document.activeElement
    }
    function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*")
    }
    function joinClasses(a, b) {
        for (var as = a.split(" "), i = 0; i < as.length; i++)
            as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
        return b
    }
    function forEachCodeMirror(f) {
        if (document.body.getElementsByClassName)
            for (var byClass = document.body.getElementsByClassName("CodeMirror"), i = 0; i < byClass.length; i++) {
                var cm = byClass[i].CodeMirror;
                cm && f(cm)
            }
    }
    function ensureGlobalHandlers() {
        globalsRegistered || (registerGlobalHandlers(), globalsRegistered = !0)
    }
    function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function () {
            null == resizeTimer && (resizeTimer = setTimeout(function () {
                resizeTimer = null, forEachCodeMirror(onResize)
            }, 100))
        }), on(window, "blur", function () {
            forEachCodeMirror(onBlur)
        })
    }
    function zeroWidthElement(measure) {
        if (null == zwspSupported) {
            var test = elt("span", "\u200b");
            removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")])), 0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && 8 > ie_version))
        }
        return zwspSupported ? elt("span", "\u200b") : elt("span", "\xa0", null, "display: inline-block; width: 1px; margin-right: -1px")
    }
    function hasBadBidiRects(measure) {
        if (null != badBidiRects)
            return badBidiRects;
        var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA")), r0 = range(txt, 0, 1).getBoundingClientRect();
        if (!r0 || r0.left == r0.right)
            return!1;
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        return badBidiRects = r1.right - r0.right < 3
    }
    function hasBadZoomedRects(measure) {
        if (null != badZoomedRects)
            return badZoomedRects;
        var node = removeChildrenAndAdd(measure, elt("span", "x")), normal = node.getBoundingClientRect(), fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
    }
    function iterateBidiSections(order, from, to, f) {
        if (!order)
            return f(from, to, "ltr");
        for (var found = !1, i = 0; i < order.length; ++i) {
            var part = order[i];
            (part.from < to && part.to > from || from == to && part.to == from) && (f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr"), found = !0)
        }
        found || f(from, to, "ltr")
    }
    function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from
    }
    function bidiRight(part) {
        return part.level % 2 ? part.from : part.to
    }
    function lineLeft(line) {
        var order = getOrder(line);
        return order ? bidiLeft(order[0]) : 0
    }
    function lineRight(line) {
        var order = getOrder(line);
        return order ? bidiRight(lst(order)) : line.text.length
    }
    function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN), visual = visualLine(line);
        visual != line && (lineN = lineNo(visual));
        var order = getOrder(visual), ch = order ? order[0].level % 2 ? lineRight(visual) : lineLeft(visual) : 0;
        return Pos(lineN, ch)
    }
    function lineEnd(cm, lineN) {
        for (var merged, line = getLine(cm.doc, lineN); merged = collapsedSpanAtEnd(line); )
            line = merged.find(1, !0).line, lineN = null;
        var order = getOrder(line), ch = order ? order[0].level % 2 ? lineLeft(line) : lineRight(line) : line.text.length;
        return Pos(null == lineN ? lineNo(line) : lineN, ch)
    }
    function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line), line = getLine(cm.doc, start.line), order = getOrder(line);
        if (!order || 0 == order[0].level) {
            var firstNonWS = Math.max(0, line.text.search(/\S/)), inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start.line, inWS ? 0 : firstNonWS)
        }
        return start
    }
    function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        return a == linedir ? !0 : b == linedir ? !1 : b > a
    }
    function getBidiPartAt(order, pos) {
        bidiOther = null;
        for (var found, i = 0; i < order.length; ++i) {
            var cur = order[i];
            if (cur.from < pos && cur.to > pos)
                return i;
            if (cur.from == pos || cur.to == pos) {
                if (null != found)
                    return compareBidiLevel(order, cur.level, order[found].level) ? (cur.from != cur.to && (bidiOther = found), i) : (cur.from != cur.to && (bidiOther = i), found);
                found = i
            }
        }
        return found
    }
    function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit)
            return pos + dir;
        do
            pos += dir;
        while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
        return pos
    }
    function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi)
            return moveLogically(line, start, dir, byUnit);
        for (var pos = getBidiPartAt(bidi, start), part = bidi[pos], target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit); ; ) {
            if (target > part.from && target < part.to)
                return target;
            if (target == part.from || target == part.to)
                return getBidiPartAt(bidi, target) == pos ? target : (part = bidi[pos += dir], dir > 0 == part.level % 2 ? part.to : part.from);
            if (part = bidi[pos += dir], !part)
                return null;
            target = dir > 0 == part.level % 2 ? moveInLine(line, part.to, -1, byUnit) : moveInLine(line, part.from, 1, byUnit)
        }
    }
    function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit)
            for (; target > 0 && isExtendingChar(line.text.charAt(target)); )
                target += dir;
        return 0 > target || target > line.text.length ? null : target
    }
    var gecko = /gecko\/\d/i.test(navigator.userAgent), ie_upto10 = /MSIE \d/.test(navigator.userAgent), ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), ie = ie_upto10 || ie_11up, ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]), webkit = /WebKit\//.test(navigator.userAgent), qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent), chrome = /Chrome\//.test(navigator.userAgent), presto = /Opera\//.test(navigator.userAgent), safari = /Apple Computer/.test(navigator.vendor), khtml = /KHTML\//.test(navigator.userAgent), mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent), phantom = /PhantomJS/.test(navigator.userAgent), ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent), mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent), mac = ios || /Mac/.test(navigator.platform), windows = /win/i.test(navigator.platform), presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
    presto_version && (presto_version = Number(presto_version[1])), presto_version && presto_version >= 15 && (presto = !1, webkit = !0);
    var flipCtrlCmd = mac && (qtwebkit || presto && (null == presto_version || 12.11 > presto_version)), captureRightClick = gecko || ie && ie_version >= 9, sawReadOnlySpans = !1, sawCollapsedSpans = !1;
    NativeScrollbars.prototype = copyObj({update: function (measure) {
            var needsH = measure.scrollWidth > measure.clientWidth + 1, needsV = measure.scrollHeight > measure.clientHeight + 1, sWidth = measure.nativeBarWidth;
            if (needsV) {
                this.vert.style.display = "block", this.vert.style.bottom = needsH ? sWidth + "px" : "0";
                var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
                this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px"
            } else
                this.vert.style.display = "", this.vert.firstChild.style.height = "0";
            if (needsH) {
                this.horiz.style.display = "block", this.horiz.style.right = needsV ? sWidth + "px" : "0", this.horiz.style.left = measure.barLeft + "px";
                var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
                this.horiz.firstChild.style.width = measure.scrollWidth - measure.clientWidth + totalWidth + "px"
            } else
                this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
            return!this.checkedOverlay && measure.clientHeight > 0 && (0 == sWidth && this.overlayHack(), this.checkedOverlay = !0), {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
        }, setScrollLeft: function (pos) {
            this.horiz.scrollLeft != pos && (this.horiz.scrollLeft = pos)
        }, setScrollTop: function (pos) {
            this.vert.scrollTop != pos && (this.vert.scrollTop = pos)
        }, overlayHack: function () {
            var w = mac && !mac_geMountainLion ? "12px" : "18px";
            this.horiz.style.minHeight = this.vert.style.minWidth = w;
            var self = this, barMouseDown = function (e) {
                e_target(e) != self.vert && e_target(e) != self.horiz && operation(self.cm, onMouseDown)(e)
            };
            on(this.vert, "mousedown", barMouseDown), on(this.horiz, "mousedown", barMouseDown)
        }, clear: function () {
            var parent = this.horiz.parentNode;
            parent.removeChild(this.horiz), parent.removeChild(this.vert)
        }}, NativeScrollbars.prototype), NullScrollbars.prototype = copyObj({update: function () {
            return{bottom: 0, right: 0}
        }, setScrollLeft: function () {
        }, setScrollTop: function () {
        }, clear: function () {
        }}, NullScrollbars.prototype), CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};
    var Pos = CodeMirror.Pos = function (line, ch) {
        return this instanceof Pos ? (this.line = line, void(this.ch = ch)) : new Pos(line, ch)
    }, cmp = CodeMirror.cmpPos = function (a, b) {
        return a.line - b.line || a.ch - b.ch
    };
    Selection.prototype = {primary: function () {
            return this.ranges[this.primIndex]
        }, equals: function (other) {
            if (other == this)
                return!0;
            if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length)
                return!1;
            for (var i = 0; i < this.ranges.length; i++) {
                var here = this.ranges[i], there = other.ranges[i];
                if (0 != cmp(here.anchor, there.anchor) || 0 != cmp(here.head, there.head))
                    return!1
            }
            return!0
        }, deepCopy: function () {
            for (var out = [], i = 0; i < this.ranges.length; i++)
                out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
            return new Selection(out, this.primIndex)
        }, somethingSelected: function () {
            for (var i = 0; i < this.ranges.length; i++)
                if (!this.ranges[i].empty())
                    return!0;
            return!1
        }, contains: function (pos, end) {
            end || (end = pos);
            for (var i = 0; i < this.ranges.length; i++) {
                var range = this.ranges[i];
                if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
                    return i
            }
            return-1
        }}, Range.prototype = {from: function () {
            return minPos(this.anchor, this.head)
        }, to: function () {
            return maxPos(this.anchor, this.head)
        }, empty: function () {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
        }};
    var measureText, lastClick, lastDoubleClick, nullRect = {left: 0, right: 0, top: 0, bottom: 0}, operationGroup = null, nextOpId = 0, lastCopied = null, lastDrop = 0, wheelSamples = 0, wheelPixelsPerUnit = null;
    ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);
    var wheelEventDelta = function (e) {
        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        return null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail), null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta), {x: dx, y: dy}
    };
    CodeMirror.wheelEventPixels = function (e) {
        var delta = wheelEventDelta(e);
        return delta.x *= wheelPixelsPerUnit, delta.y *= wheelPixelsPerUnit, delta
    };
    var stopSeq = new Delayed, lastStoppedKey = null, changeEnd = CodeMirror.changeEnd = function (change) {
        return change.text ? Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0)) : change.to
    };
    CodeMirror.prototype = {constructor: CodeMirror, focus: function () {
            window.focus(), focusInput(this), fastPoll(this)
        }, setOption: function (option, value) {
            var options = this.options, old = options[option];
            (options[option] != value || "mode" == option) && (options[option] = value, optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old))
        }, getOption: function (option) {
            return this.options[option]
        }, getDoc: function () {
            return this.doc
        }, addKeyMap: function (map, bottom) {
            this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map))
        }, removeKeyMap: function (map) {
            for (var maps = this.state.keyMaps, i = 0; i < maps.length; ++i)
                if (maps[i] == map || maps[i].name == map)
                    return maps.splice(i, 1), !0
        }, addOverlay: methodOp(function (spec, options) {
            var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
            if (mode.startState)
                throw new Error("Overlays may not be stateful.");
            this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque}), this.state.modeGen++, regChange(this)
        }), removeOverlay: methodOp(function (spec) {
            for (var overlays = this.state.overlays, i = 0; i < overlays.length; ++i) {
                var cur = overlays[i].modeSpec;
                if (cur == spec || "string" == typeof spec && cur.name == spec)
                    return overlays.splice(i, 1), this.state.modeGen++, void regChange(this)
            }
        }), indentLine: methodOp(function (n, dir, aggressive) {
            "string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract"), isLine(this.doc, n) && indentLine(this, n, dir, aggressive)
        }), indentSelection: methodOp(function (how) {
            for (var ranges = this.doc.sel.ranges, end = -1, i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (range.empty())
                    range.head.line > end && (indentLine(this, range.head.line, how, !0), end = range.head.line, i == this.doc.sel.primIndex && ensureCursorVisible(this));
                else {
                    var from = range.from(), to = range.to(), start = Math.max(end, from.line);
                    end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                    for (var j = start; end > j; ++j)
                        indentLine(this, j, how);
                    var newRanges = this.doc.sel.ranges;
                    0 == from.ch && ranges.length == newRanges.length && newRanges[i].from().ch > 0 && replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll)
                }
            }
        }), getTokenAt: function (pos, precise) {
            return takeToken(this, pos, precise)
        }, getLineTokens: function (line, precise) {
            return takeToken(this, Pos(line), precise, !0)
        }, getTokenTypeAt: function (pos) {
            pos = clipPos(this.doc, pos);
            var type, styles = getLineStyles(this, getLine(this.doc, pos.line)), before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
            if (0 == ch)
                type = styles[2];
            else
                for (; ; ) {
                    var mid = before + after >> 1;
                    if ((mid ? styles[2 * mid - 1] : 0) >= ch)
                        after = mid;
                    else {
                        if (!(styles[2 * mid + 1] < ch)) {
                            type = styles[2 * mid + 2];
                            break
                        }
                        before = mid + 1
                    }
                }
            var cut = type ? type.indexOf("cm-overlay ") : -1;
            return 0 > cut ? type : 0 == cut ? null : type.slice(0, cut - 1)
        }, getModeAt: function (pos) {
            var mode = this.doc.mode;
            return mode.innerMode ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode : mode
        }, getHelper: function (pos, type) {
            return this.getHelpers(pos, type)[0]
        }, getHelpers: function (pos, type) {
            var found = [];
            if (!helpers.hasOwnProperty(type))
                return helpers;
            var help = helpers[type], mode = this.getModeAt(pos);
            if ("string" == typeof mode[type])
                help[mode[type]] && found.push(help[mode[type]]);
            else if (mode[type])
                for (var i = 0; i < mode[type].length; i++) {
                    var val = help[mode[type][i]];
                    val && found.push(val)
                }
            else
                mode.helperType && help[mode.helperType] ? found.push(help[mode.helperType]) : help[mode.name] && found.push(help[mode.name]);
            for (var i = 0; i < help._global.length; i++) {
                var cur = help._global[i];
                cur.pred(mode, this) && -1 == indexOf(found, cur.val) && found.push(cur.val)
            }
            return found
        }, getStateAfter: function (line, precise) {
            var doc = this.doc;
            return line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line), getStateBefore(this, line + 1, precise)
        }, cursorCoords: function (start, mode) {
            var pos, range = this.doc.sel.primary();
            return pos = null == start ? range.head : "object" == typeof start ? clipPos(this.doc, start) : start ? range.from() : range.to(), cursorCoords(this, pos, mode || "page")
        }, charCoords: function (pos, mode) {
            return charCoords(this, clipPos(this.doc, pos), mode || "page")
        }, coordsChar: function (coords, mode) {
            return coords = fromCoordSystem(this, coords, mode || "page"), coordsChar(this, coords.left, coords.top)
        }, lineAtHeight: function (height, mode) {
            return height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top, lineAtHeight(this.doc, height + this.display.viewOffset)
        }, heightAtLine: function (line, mode) {
            var end = !1, last = this.doc.first + this.doc.size - 1;
            line < this.doc.first ? line = this.doc.first : line > last && (line = last, end = !0);
            var lineObj = getLine(this.doc, line);
            return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top + (end ? this.doc.height - heightAtLine(lineObj) : 0)
        }, defaultTextHeight: function () {
            return textHeight(this.display)
        }, defaultCharWidth: function () {
            return charWidth(this.display)
        }, setGutterMarker: methodOp(function (line, gutterID, value) {
            return changeLine(this.doc, line, "gutter", function (line) {
                var markers = line.gutterMarkers || (line.gutterMarkers = {});
                return markers[gutterID] = value, !value && isEmpty(markers) && (line.gutterMarkers = null), !0
            })
        }), clearGutter: methodOp(function (gutterID) {
            var cm = this, doc = cm.doc, i = doc.first;
            doc.iter(function (line) {
                line.gutterMarkers && line.gutterMarkers[gutterID] && (line.gutterMarkers[gutterID] = null, regLineChange(cm, i, "gutter"), isEmpty(line.gutterMarkers) && (line.gutterMarkers = null)), ++i
            })
        }), addLineWidget: methodOp(function (handle, node, options) {
            return addLineWidget(this, handle, node, options)
        }), removeLineWidget: function (widget) {
            widget.clear()
        }, lineInfo: function (line) {
            if ("number" == typeof line) {
                if (!isLine(this.doc, line))
                    return null;
                var n = line;
                if (line = getLine(this.doc, line), !line)
                    return null
            } else {
                var n = lineNo(line);
                if (null == n)
                    return null
            }
            return{line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers, textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass, widgets: line.widgets}
        }, getViewport: function () {
            return{from: this.display.viewFrom, to: this.display.viewTo}
        }, addWidget: function (pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = cursorCoords(this, clipPos(this.doc, pos));
            var top = pos.bottom, left = pos.left;
            if (node.style.position = "absolute", node.setAttribute("cm-ignore-events", "true"), display.sizer.appendChild(node), "over" == vert)
                top = pos.top;
            else if ("above" == vert || "near" == vert) {
                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                ("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom),
                        left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth)
            }
            node.style.top = top + "px", node.style.left = node.style.right = "", "right" == horiz ? (left = display.sizer.clientWidth - node.offsetWidth, node.style.right = "0px") : ("left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2), node.style.left = left + "px"), scroll && scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight)
        }, triggerOnKeyDown: methodOp(onKeyDown), triggerOnKeyPress: methodOp(onKeyPress), triggerOnKeyUp: onKeyUp, execCommand: function (cmd) {
            return commands.hasOwnProperty(cmd) ? commands[cmd](this) : void 0
        }, findPosH: function (from, amount, unit, visually) {
            var dir = 1;
            0 > amount && (dir = -1, amount = -amount);
            for (var i = 0, cur = clipPos(this.doc, from); amount > i && (cur = findPosH(this.doc, cur, dir, unit, visually), !cur.hitSide); ++i)
                ;
            return cur
        }, moveH: methodOp(function (dir, unit) {
            var cm = this;
            cm.extendSelectionsBy(function (range) {
                return cm.display.shift || cm.doc.extend || range.empty() ? findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually) : 0 > dir ? range.from() : range.to()
            }, sel_move)
        }), deleteH: methodOp(function (dir, unit) {
            var sel = this.doc.sel, doc = this.doc;
            sel.somethingSelected() ? doc.replaceSelection("", null, "+delete") : deleteNearSelection(this, function (range) {
                var other = findPosH(doc, range.head, dir, unit, !1);
                return 0 > dir ? {from: other, to: range.head} : {from: range.head, to: other}
            })
        }), findPosV: function (from, amount, unit, goalColumn) {
            var dir = 1, x = goalColumn;
            0 > amount && (dir = -1, amount = -amount);
            for (var i = 0, cur = clipPos(this.doc, from); amount > i; ++i) {
                var coords = cursorCoords(this, cur, "div");
                if (null == x ? x = coords.left : coords.left = x, cur = findPosV(this, coords, dir, unit), cur.hitSide)
                    break
            }
            return cur
        }, moveV: methodOp(function (dir, unit) {
            var cm = this, doc = this.doc, goals = [], collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
            if (doc.extendSelectionsBy(function (range) {
                if (collapse)
                    return 0 > dir ? range.from() : range.to();
                var headPos = cursorCoords(cm, range.head, "div");
                null != range.goalColumn && (headPos.left = range.goalColumn), goals.push(headPos.left);
                var pos = findPosV(cm, headPos, dir, unit);
                return"page" == unit && range == doc.sel.primary() && addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top), pos
            }, sel_move), goals.length)
                for (var i = 0; i < doc.sel.ranges.length; i++)
                    doc.sel.ranges[i].goalColumn = goals[i]
        }), findWordAt: function (pos) {
            var doc = this.doc, line = getLine(doc, pos.line).text, start = pos.ch, end = pos.ch;
            if (line) {
                var helper = this.getHelper(pos, "wordChars");
                (pos.xRel < 0 || end == line.length) && start ? --start : ++end;
                for (var startChar = line.charAt(start), check = isWordChar(startChar, helper) ? function (ch) {
                    return isWordChar(ch, helper)
                } : /\s/.test(startChar) ? function (ch) {
                    return/\s/.test(ch)
                } : function (ch) {
                    return!/\s/.test(ch) && !isWordChar(ch)
                }; start > 0 && check(line.charAt(start - 1)); )
                    --start;
                for (; end < line.length && check(line.charAt(end)); )
                    ++end
            }
            return new Range(Pos(pos.line, start), Pos(pos.line, end))
        }, toggleOverwrite: function (value) {
            (null == value || value != this.state.overwrite) && ((this.state.overwrite = !this.state.overwrite) ? addClass(this.display.cursorDiv, "CodeMirror-overwrite") : rmClass(this.display.cursorDiv, "CodeMirror-overwrite"), signal(this, "overwriteToggle", this, this.state.overwrite))
        }, hasFocus: function () {
            return activeElt() == this.display.input
        }, scrollTo: methodOp(function (x, y) {
            (null != x || null != y) && resolveScrollToPos(this), null != x && (this.curOp.scrollLeft = x), null != y && (this.curOp.scrollTop = y)
        }), getScrollInfo: function () {
            var scroller = this.display.scroller;
            return{left: scroller.scrollLeft, top: scroller.scrollTop, height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight, width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth, clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
        }, scrollIntoView: methodOp(function (range, margin) {
            if (null == range ? (range = {from: this.doc.sel.primary().head, to: null}, null == margin && (margin = this.options.cursorScrollMargin)) : "number" == typeof range ? range = {from: Pos(range, 0), to: null} : null == range.from && (range = {from: range, to: null}), range.to || (range.to = range.from), range.margin = margin || 0, null != range.from.line)
                resolveScrollToPos(this), this.curOp.scrollToPos = range;
            else {
                var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
                this.scrollTo(sPos.scrollLeft, sPos.scrollTop)
            }
        }), setSize: methodOp(function (width, height) {
            function interpret(val) {
                return"number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val
            }
            var cm = this;
            null != width && (cm.display.wrapper.style.width = interpret(width)), null != height && (cm.display.wrapper.style.height = interpret(height)), cm.options.lineWrapping && clearLineMeasurementCache(this);
            var lineNo = cm.display.viewFrom;
            cm.doc.iter(lineNo, cm.display.viewTo, function (line) {
                if (line.widgets)
                    for (var i = 0; i < line.widgets.length; i++)
                        if (line.widgets[i].noHScroll) {
                            regLineChange(cm, lineNo, "widget");
                            break
                        }
                ++lineNo
            }), cm.curOp.forceUpdate = !0, signal(cm, "refresh", this)
        }), operation: function (f) {
            return runInOp(this, f)
        }, refresh: methodOp(function () {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this), this.curOp.forceUpdate = !0, clearCaches(this), this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop), updateGutterSpace(this), (null == oldHeight || Math.abs(oldHeight - textHeight(this.display)) > .5) && estimateLineHeights(this), signal(this, "refresh", this)
        }), swapDoc: methodOp(function (doc) {
            var old = this.doc;
            return old.cm = null, attachDoc(this, doc), clearCaches(this), resetInput(this), this.scrollTo(doc.scrollLeft, doc.scrollTop), this.curOp.forceScroll = !0, signalLater(this, "swapDoc", this, old), old
        }), getInputField: function () {
            return this.display.input
        }, getWrapperElement: function () {
            return this.display.wrapper
        }, getScrollerElement: function () {
            return this.display.scroller
        }, getGutterElement: function () {
            return this.display.gutters
        }}, eventMixin(CodeMirror);
    var defaults = CodeMirror.defaults = {}, optionHandlers = CodeMirror.optionHandlers = {}, Init = CodeMirror.Init = {toString: function () {
            return"CodeMirror.Init"
        }};
    option("value", "", function (cm, val) {
        cm.setValue(val)
    }, !0), option("mode", null, function (cm, val) {
        cm.doc.modeOption = val, loadMode(cm)
    }, !0), option("indentUnit", 2, loadMode, !0), option("indentWithTabs", !1), option("smartIndent", !0), option("tabSize", 4, function (cm) {
        resetModeState(cm), clearCaches(cm), regChange(cm)
    }, !0), option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val) {
        cm.options.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g"), cm.refresh()
    }, !0), option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
        cm.refresh()
    }, !0), option("electricChars", !0), option("rtlMoveVisually", !windows), option("wholeLineUpdateBefore", !0), option("theme", "default", function (cm) {
        themeChanged(cm), guttersChanged(cm)
    }, !0), option("keyMap", "default", function (cm, val, old) {
        var next = getKeyMap(val), prev = old != CodeMirror.Init && getKeyMap(old);
        prev && prev.detach && prev.detach(cm, next), next.attach && next.attach(cm, prev || null)
    }), option("extraKeys", null), option("lineWrapping", !1, wrappingChanged, !0), option("gutters", [], function (cm) {
        setGuttersForLineNumbers(cm.options), guttersChanged(cm)
    }, !0), option("fixedGutter", !0, function (cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0", cm.refresh()
    }, !0), option("coverGutterNextToScrollbar", !1, function (cm) {
        updateScrollbars(cm)
    }, !0), option("scrollbarStyle", "native", function (cm) {
        initScrollbars(cm), updateScrollbars(cm), cm.display.scrollbars.setScrollTop(cm.doc.scrollTop), cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)
    }, !0), option("lineNumbers", !1, function (cm) {
        setGuttersForLineNumbers(cm.options), guttersChanged(cm)
    }, !0), option("firstLineNumber", 1, guttersChanged, !0), option("lineNumberFormatter", function (integer) {
        return integer
    }, guttersChanged, !0), option("showCursorWhenSelecting", !1, updateSelection, !0), option("resetSelectionOnContextMenu", !0), option("readOnly", !1, function (cm, val) {
        "nocursor" == val ? (onBlur(cm), cm.display.input.blur(), cm.display.disabled = !0) : (cm.display.disabled = !1, val || resetInput(cm))
    }), option("disableInput", !1, function (cm, val) {
        val || resetInput(cm)
    }, !0), option("dragDrop", !0), option("cursorBlinkRate", 530), option("cursorScrollMargin", 0), option("cursorHeight", 1, updateSelection, !0), option("singleCursorHeightPerLine", !0, updateSelection, !0), option("workTime", 100), option("workDelay", 100), option("flattenSpans", !0, resetModeState, !0), option("addModeClass", !1, resetModeState, !0), option("pollInterval", 100), option("undoDepth", 200, function (cm, val) {
        cm.doc.history.undoDepth = val
    }), option("historyEventDelay", 1250), option("viewportMargin", 10, function (cm) {
        cm.refresh()
    }, !0), option("maxHighlightLength", 1e4, resetModeState, !0), option("moveInputWithCursor", !0, function (cm, val) {
        val || (cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0)
    }), option("tabindex", null, function (cm, val) {
        cm.display.input.tabIndex = val || ""
    }), option("autofocus", null);
    var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
    CodeMirror.defineMode = function (name, mode) {
        CodeMirror.defaults.mode || "null" == name || (CodeMirror.defaults.mode = name), arguments.length > 2 && (mode.dependencies = Array.prototype.slice.call(arguments, 2)), modes[name] = mode
    }, CodeMirror.defineMIME = function (mime, spec) {
        mimeModes[mime] = spec
    }, CodeMirror.resolveMode = function (spec) {
        if ("string" == typeof spec && mimeModes.hasOwnProperty(spec))
            spec = mimeModes[spec];
        else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            "string" == typeof found && (found = {name: found}), spec = createObj(found, spec), spec.name = found.name
        } else if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec))
            return CodeMirror.resolveMode("application/xml");
        return"string" == typeof spec ? {name: spec} : spec || {name: "null"}
    }, CodeMirror.getMode = function (options, spec) {
        var spec = CodeMirror.resolveMode(spec), mfactory = modes[spec.name];
        if (!mfactory)
            return CodeMirror.getMode(options, "text/plain");
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop in exts)
                exts.hasOwnProperty(prop) && (modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]), modeObj[prop] = exts[prop])
        }
        if (modeObj.name = spec.name, spec.helperType && (modeObj.helperType = spec.helperType), spec.modeProps)
            for (var prop in spec.modeProps)
                modeObj[prop] = spec.modeProps[prop];
        return modeObj
    }, CodeMirror.defineMode("null", function () {
        return{token: function (stream) {
                stream.skipToEnd()
            }}
    }), CodeMirror.defineMIME("text/plain", "null");
    var modeExtensions = CodeMirror.modeExtensions = {};
    CodeMirror.extendMode = function (mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts)
    }, CodeMirror.defineExtension = function (name, func) {
        CodeMirror.prototype[name] = func
    }, CodeMirror.defineDocExtension = function (name, func) {
        Doc.prototype[name] = func
    }, CodeMirror.defineOption = option;
    var initHooks = [];
    CodeMirror.defineInitHook = function (f) {
        initHooks.push(f)
    };
    var helpers = CodeMirror.helpers = {};
    CodeMirror.registerHelper = function (type, name, value) {
        helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {_global: []}), helpers[type][name] = value
    }, CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
        CodeMirror.registerHelper(type, name, value), helpers[type]._global.push({pred: predicate, val: value})
    };
    var copyState = CodeMirror.copyState = function (mode, state) {
        if (state === !0)
            return state;
        if (mode.copyState)
            return mode.copyState(state);
        var nstate = {};
        for (var n in state) {
            var val = state[n];
            val instanceof Array && (val = val.concat([])), nstate[n] = val
        }
        return nstate
    }, startState = CodeMirror.startState = function (mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : !0
    };
    CodeMirror.innerMode = function (mode, state) {
        for (; mode.innerMode; ) {
            var info = mode.innerMode(state);
            if (!info || info.mode == mode)
                break;
            state = info.state, mode = info.mode
        }
        return info || {mode: mode, state: state}
    };
    var commands = CodeMirror.commands = {selectAll: function (cm) {
            cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)
        }, singleSelection: function (cm) {
            cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll)
        }, killLine: function (cm) {
            deleteNearSelection(cm, function (range) {
                if (range.empty()) {
                    var len = getLine(cm.doc, range.head.line).text.length;
                    return range.head.ch == len && range.head.line < cm.lastLine() ? {from: range.head, to: Pos(range.head.line + 1, 0)} : {from: range.head, to: Pos(range.head.line, len)}
                }
                return{from: range.from(), to: range.to()}
            })
        }, deleteLine: function (cm) {
            deleteNearSelection(cm, function (range) {
                return{from: Pos(range.from().line, 0), to: clipPos(cm.doc, Pos(range.to().line + 1, 0))}
            })
        }, delLineLeft: function (cm) {
            deleteNearSelection(cm, function (range) {
                return{from: Pos(range.from().line, 0), to: range.from()}
            })
        }, delWrappedLineLeft: function (cm) {
            deleteNearSelection(cm, function (range) {
                var top = cm.charCoords(range.head, "div").top + 5, leftPos = cm.coordsChar({left: 0, top: top}, "div");
                return{from: leftPos, to: range.from()}
            })
        }, delWrappedLineRight: function (cm) {
            deleteNearSelection(cm, function (range) {
                var top = cm.charCoords(range.head, "div").top + 5, rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
                return{from: range.from(), to: rightPos}
            })
        }, undo: function (cm) {
            cm.undo()
        }, redo: function (cm) {
            cm.redo()
        }, undoSelection: function (cm) {
            cm.undoSelection()
        }, redoSelection: function (cm) {
            cm.redoSelection()
        }, goDocStart: function (cm) {
            cm.extendSelection(Pos(cm.firstLine(), 0))
        }, goDocEnd: function (cm) {
            cm.extendSelection(Pos(cm.lastLine()))
        }, goLineStart: function (cm) {
            cm.extendSelectionsBy(function (range) {
                return lineStart(cm, range.head.line)
            }, {origin: "+move", bias: 1})
        }, goLineStartSmart: function (cm) {
            cm.extendSelectionsBy(function (range) {
                return lineStartSmart(cm, range.head)
            }, {origin: "+move", bias: 1})
        }, goLineEnd: function (cm) {
            cm.extendSelectionsBy(function (range) {
                return lineEnd(cm, range.head.line)
            }, {origin: "+move", bias: -1})
        }, goLineRight: function (cm) {
            cm.extendSelectionsBy(function (range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
            }, sel_move)
        }, goLineLeft: function (cm) {
            cm.extendSelectionsBy(function (range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                return cm.coordsChar({left: 0, top: top}, "div")
            }, sel_move)
        }, goLineLeftSmart: function (cm) {
            cm.extendSelectionsBy(function (range) {
                var top = cm.charCoords(range.head, "div").top + 5, pos = cm.coordsChar({left: 0, top: top}, "div");
                return pos.ch < cm.getLine(pos.line).search(/\S/) ? lineStartSmart(cm, range.head) : pos
            }, sel_move)
        }, goLineUp: function (cm) {
            cm.moveV(-1, "line")
        }, goLineDown: function (cm) {
            cm.moveV(1, "line")
        }, goPageUp: function (cm) {
            cm.moveV(-1, "page")
        }, goPageDown: function (cm) {
            cm.moveV(1, "page")
        }, goCharLeft: function (cm) {
            cm.moveH(-1, "char")
        }, goCharRight: function (cm) {
            cm.moveH(1, "char")
        }, goColumnLeft: function (cm) {
            cm.moveH(-1, "column")
        }, goColumnRight: function (cm) {
            cm.moveH(1, "column")
        }, goWordLeft: function (cm) {
            cm.moveH(-1, "word")
        }, goGroupRight: function (cm) {
            cm.moveH(1, "group")
        }, goGroupLeft: function (cm) {
            cm.moveH(-1, "group")
        }, goWordRight: function (cm) {
            cm.moveH(1, "word")
        }, delCharBefore: function (cm) {
            cm.deleteH(-1, "char")
        }, delCharAfter: function (cm) {
            cm.deleteH(1, "char")
        }, delWordBefore: function (cm) {
            cm.deleteH(-1, "word")
        }, delWordAfter: function (cm) {
            cm.deleteH(1, "word")
        }, delGroupBefore: function (cm) {
            cm.deleteH(-1, "group")
        }, delGroupAfter: function (cm) {
            cm.deleteH(1, "group")
        }, indentAuto: function (cm) {
            cm.indentSelection("smart")
        }, indentMore: function (cm) {
            cm.indentSelection("add")
        }, indentLess: function (cm) {
            cm.indentSelection("subtract")
        }, insertTab: function (cm) {
            cm.replaceSelection("	")
        }, insertSoftTab: function (cm) {
            for (var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize, i = 0; i < ranges.length; i++) {
                var pos = ranges[i].from(), col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                spaces.push(new Array(tabSize - col % tabSize + 1).join(" "))
            }
            cm.replaceSelections(spaces)
        }, defaultTab: function (cm) {
            cm.somethingSelected() ? cm.indentSelection("add") : cm.execCommand("insertTab")
        }, transposeChars: function (cm) {
            runInOp(cm, function () {
                for (var ranges = cm.listSelections(), newSel = [], i = 0; i < ranges.length; i++) {
                    var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
                    if (line)
                        if (cur.ch == line.length && (cur = new Pos(cur.line, cur.ch - 1)), cur.ch > 0)
                            cur = new Pos(cur.line, cur.ch + 1), cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                        else if (cur.line > cm.doc.first) {
                            var prev = getLine(cm.doc, cur.line - 1).text;
                            prev && cm.replaceRange(line.charAt(0) + "\n" + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose")
                        }
                    newSel.push(new Range(cur, cur))
                }
                cm.setSelections(newSel)
            })
        }, newlineAndIndent: function (cm) {
            runInOp(cm, function () {
                for (var len = cm.listSelections().length, i = 0; len > i; i++) {
                    var range = cm.listSelections()[i];
                    cm.replaceRange("\n", range.anchor, range.head, "+input"), cm.indentLine(range.from().line + 1, null, !0), ensureCursorVisible(cm)
                }
            })
        }, toggleOverwrite: function (cm) {
            cm.toggleOverwrite()
        }}, keyMap = CodeMirror.keyMap = {};
    keyMap.basic = {Left: "goCharLeft", Right: "goCharRight", Up: "goLineUp", Down: "goLineDown", End: "goLineEnd", Home: "goLineStartSmart", PageUp: "goPageUp", PageDown: "goPageDown", Delete: "delCharAfter", Backspace: "delCharBefore", "Shift-Backspace": "delCharBefore", Tab: "defaultTab", "Shift-Tab": "indentAuto", Enter: "newlineAndIndent", Insert: "toggleOverwrite", Esc: "singleSelection"}, keyMap.pcDefault = {"Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo", "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown", "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd", "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find", "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll", "Ctrl-[": "indentLess", "Ctrl-]": "indentMore", "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection", fallthrough: "basic"}, keyMap.emacsy = {"Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown", "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"}, keyMap.macDefault = {"Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo", "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft", "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore", "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find", "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll", "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight", "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd", fallthrough: ["basic", "emacsy"]}, keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault, CodeMirror.normalizeKeyMap = function (keymap) {
        var copy = {};
        for (var keyname in keymap)
            if (keymap.hasOwnProperty(keyname)) {
                var value = keymap[keyname];
                if (/^(name|fallthrough|(de|at)tach)$/.test(keyname))
                    continue;
                if ("..." == value) {
                    delete keymap[keyname];
                    continue
                }
                for (var keys = map(keyname.split(" "), normalizeKeyName), i = 0; i < keys.length; i++) {
                    var val, name;
                    i == keys.length - 1 ? (name = keyname, val = value) : (name = keys.slice(0, i + 1).join(" "), val = "...");
                    var prev = copy[name];
                    if (prev) {
                        if (prev != val)
                            throw new Error("Inconsistent bindings for " + name)
                    } else
                        copy[name] = val
                }
                delete keymap[keyname]
            }
        for (var prop in copy)
            keymap[prop] = copy[prop];
        return keymap
    };
    var lookupKey = CodeMirror.lookupKey = function (key, map, handle, context) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key, context) : map[key];
        if (found === !1)
            return"nothing";
        if ("..." === found)
            return"multi";
        if (null != found && handle(found))
            return"handled";
        if (map.fallthrough) {
            if ("[object Array]" != Object.prototype.toString.call(map.fallthrough))
                return lookupKey(key, map.fallthrough, handle, context);
            for (var i = 0; i < map.fallthrough.length; i++) {
                var result = lookupKey(key, map.fallthrough[i], handle, context);
                if (result)
                    return result
            }
        }
    }, isModifierKey = CodeMirror.isModifierKey = function (value) {
        var name = "string" == typeof value ? value : keyNames[value.keyCode];
        return"Ctrl" == name || "Alt" == name || "Shift" == name || "Mod" == name
    }, keyName = CodeMirror.keyName = function (event, noShift) {
        if (presto && 34 == event.keyCode && event["char"])
            return!1;
        var base = keyNames[event.keyCode], name = base;
        return null == name || event.altGraphKey ? !1 : (event.altKey && "Alt" != base && (name = "Alt-" + name), (flipCtrlCmd ? event.metaKey : event.ctrlKey) && "Ctrl" != base && (name = "Ctrl-" + name), (flipCtrlCmd ? event.ctrlKey : event.metaKey) && "Cmd" != base && (name = "Cmd-" + name), !noShift && event.shiftKey && "Shift" != base && (name = "Shift-" + name), name)
    };
    CodeMirror.fromTextArea = function (textarea, options) {
        function save() {
            textarea.value = cm.getValue()
        }
        if (options || (options = {}), options.value = textarea.value, !options.tabindex && textarea.tabindex && (options.tabindex = textarea.tabindex), !options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder), null == options.autofocus) {
            var hasFocus = activeElt();
            options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body
        }
        if (textarea.form && (on(textarea.form, "submit", save), !options.leaveSubmitMethodAlone)) {
            var form = textarea.form, realSubmit = form.submit;
            try {
                var wrappedSubmit = form.submit = function () {
                    save(), form.submit = realSubmit, form.submit(), form.submit = wrappedSubmit
                }
            } catch (e) {
            }
        }
        textarea.style.display = "none";
        var cm = CodeMirror(function (node) {
            textarea.parentNode.insertBefore(node, textarea.nextSibling)
        }, options);
        return cm.save = save, cm.getTextArea = function () {
            return textarea
        }, cm.toTextArea = function () {
            cm.toTextArea = isNaN, save(), textarea.parentNode.removeChild(cm.getWrapperElement()), textarea.style.display = "", textarea.form && (off(textarea.form, "submit", save), "function" == typeof textarea.form.submit && (textarea.form.submit = realSubmit))
        }, cm
    };
    var StringStream = CodeMirror.StringStream = function (string, tabSize) {
        this.pos = this.start = 0, this.string = string, this.tabSize = tabSize || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0
    };
    StringStream.prototype = {eol: function () {
            return this.pos >= this.string.length
        }, sol: function () {
            return this.pos == this.lineStart
        }, peek: function () {
            return this.string.charAt(this.pos) || void 0
        }, next: function () {
            return this.pos < this.string.length ? this.string.charAt(this.pos++) : void 0
        }, eat: function (match) {
            var ch = this.string.charAt(this.pos);
            if ("string" == typeof match)
                var ok = ch == match;
            else
                var ok = ch && (match.test ? match.test(ch) : match(ch));
            return ok ? (++this.pos, ch) : void 0
        }, eatWhile: function (match) {
            for (var start = this.pos; this.eat(match); )
                ;
            return this.pos > start
        }, eatSpace: function () {
            for (var start = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
                ++this.pos;
            return this.pos > start
        }, skipToEnd: function () {
            this.pos = this.string.length
        }, skipTo: function (ch) {
            var found = this.string.indexOf(ch, this.pos);
            return found > -1 ? (this.pos = found, !0) : void 0
        }, backUp: function (n) {
            this.pos -= n
        }, column: function () {
            return this.lastColumnPos < this.start && (this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
        }, indentation: function () {
            return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
        }, match: function (pattern, consume, caseInsensitive) {
            if ("string" != typeof pattern) {
                var match = this.string.slice(this.pos).match(pattern);
                return match && match.index > 0 ? null : (match && consume !== !1 && (this.pos += match[0].length), match)
            }
            var cased = function (str) {
                return caseInsensitive ? str.toLowerCase() : str
            }, substr = this.string.substr(this.pos, pattern.length);
            return cased(substr) == cased(pattern) ? (consume !== !1 && (this.pos += pattern.length), !0) : void 0
        }, current: function () {
            return this.string.slice(this.start, this.pos)
        }, hideFirstChars: function (n, inner) {
            this.lineStart += n;
            try {
                return inner()
            } finally {
                this.lineStart -= n
            }
        }};
    var TextMarker = CodeMirror.TextMarker = function (doc, type) {
        this.lines = [], this.type = type, this.doc = doc
    };
    eventMixin(TextMarker), TextMarker.prototype.clear = function () {
        if (!this.explicitlyCleared) {
            var cm = this.doc.cm, withOp = cm && !cm.curOp;
            if (withOp && startOperation(cm), hasHandler(this, "clear")) {
                var found = this.find();
                found && signalLater(this, "clear", found.from, found.to)
            }
            for (var min = null, max = null, i = 0; i < this.lines.length; ++i) {
                var line = this.lines[i], span = getMarkedSpanFor(line.markedSpans, this);
                cm && !this.collapsed ? regLineChange(cm, lineNo(line), "text") : cm && (null != span.to && (max = lineNo(line)), null != span.from && (min = lineNo(line))), line.markedSpans = removeMarkedSpan(line.markedSpans, span), null == span.from && this.collapsed && !lineIsHidden(this.doc, line) && cm && updateLineHeight(line, textHeight(cm.display))
            }
            if (cm && this.collapsed && !cm.options.lineWrapping)
                for (var i = 0; i < this.lines.length; ++i) {
                    var visual = visualLine(this.lines[i]), len = lineLength(visual);
                    len > cm.display.maxLineLength && (cm.display.maxLine = visual, cm.display.maxLineLength = len, cm.display.maxLineChanged = !0)
                }
            null != min && cm && this.collapsed && regChange(cm, min, max + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, cm && reCheckSelection(cm.doc)), cm && signalLater(cm, "markerCleared", cm, this), withOp && endOperation(cm), this.parent && this.parent.clear()
        }
    }, TextMarker.prototype.find = function (side, lineObj) {
        null == side && "bookmark" == this.type && (side = 1);
        for (var from, to, i = 0; i < this.lines.length; ++i) {
            var line = this.lines[i], span = getMarkedSpanFor(line.markedSpans, this);
            if (null != span.from && (from = Pos(lineObj ? line : lineNo(line), span.from), -1 == side))
                return from;
            if (null != span.to && (to = Pos(lineObj ? line : lineNo(line), span.to), 1 == side))
                return to
        }
        return from && {from: from, to: to}
    }, TextMarker.prototype.changed = function () {
        var pos = this.find(-1, !0), widget = this, cm = this.doc.cm;
        pos && cm && runInOp(cm, function () {
            var line = pos.line, lineN = lineNo(pos.line), view = findViewForLine(cm, lineN);
            if (view && (clearLineMeasurementCacheFor(view), cm.curOp.selectionChanged = cm.curOp.forceUpdate = !0), cm.curOp.updateMaxLine = !0, !lineIsHidden(widget.doc, line) && null != widget.height) {
                var oldHeight = widget.height;
                widget.height = null;
                var dHeight = widgetHeight(widget) - oldHeight;
                dHeight && updateLineHeight(line, line.height + dHeight)
            }
        })
    }, TextMarker.prototype.attachLine = function (line) {
        if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            op.maybeHiddenMarkers && -1 != indexOf(op.maybeHiddenMarkers, this) || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this)
        }
        this.lines.push(line)
    }, TextMarker.prototype.detachLine = function (line) {
        if (this.lines.splice(indexOf(this.lines, line), 1), !this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
        }
    };
    var nextMarkerId = 0, SharedTextMarker = CodeMirror.SharedTextMarker = function (markers, primary) {
        this.markers = markers, this.primary = primary;
        for (var i = 0; i < markers.length; ++i)
            markers[i].parent = this
    };
    eventMixin(SharedTextMarker), SharedTextMarker.prototype.clear = function () {
        if (!this.explicitlyCleared) {
            this.explicitlyCleared = !0;
            for (var i = 0; i < this.markers.length; ++i)
                this.markers[i].clear();
            signalLater(this, "clear")
        }
    }, SharedTextMarker.prototype.find = function (side, lineObj) {
        return this.primary.find(side, lineObj)
    };
    var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
        if (options)
            for (var opt in options)
                options.hasOwnProperty(opt) && (this[opt] = options[opt]);
        this.cm = cm, this.node = node
    };
    eventMixin(LineWidget), LineWidget.prototype.clear = function () {
        var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (null != no && ws) {
            for (var i = 0; i < ws.length; ++i)
                ws[i] == this && ws.splice(i--, 1);
            ws.length || (line.widgets = null);
            var height = widgetHeight(this);
            runInOp(cm, function () {
                adjustScrollWhenAboveVisible(cm, line, -height), regLineChange(cm, no, "widget"), updateLineHeight(line, Math.max(0, line.height - height))
            })
        }
    }, LineWidget.prototype.changed = function () {
        var oldH = this.height, cm = this.cm, line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        diff && runInOp(cm, function () {
            cm.curOp.forceUpdate = !0, adjustScrollWhenAboveVisible(cm, line, diff), updateLineHeight(line, line.height + diff)
        })
    };
    var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
        this.text = text, attachMarkedSpans(this, markedSpans), this.height = estimateHeight ? estimateHeight(this) : 1
    };
    eventMixin(Line), Line.prototype.lineNo = function () {
        return lineNo(this)
    };
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    LeafChunk.prototype = {chunkSize: function () {
            return this.lines.length
        }, removeInner: function (at, n) {
            for (var i = at, e = at + n; e > i; ++i) {
                var line = this.lines[i];
                this.height -= line.height, cleanUpLine(line), signalLater(line, "delete")
            }
            this.lines.splice(at, n)
        }, collapse: function (lines) {
            lines.push.apply(lines, this.lines)
        }, insertInner: function (at, lines, height) {
            this.height += height, this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i = 0; i < lines.length; ++i)
                lines[i].parent = this
        }, iterN: function (at, n, op) {
            for (var e = at + n; e > at; ++at)
                if (op(this.lines[at]))
                    return!0
        }}, BranchChunk.prototype = {chunkSize: function () {
            return this.size
        }, removeInner: function (at, n) {
            this.size -= n;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (sz > at) {
                    var rm = Math.min(n, sz - at), oldHeight = child.height;
                    if (child.removeInner(at, rm), this.height -= oldHeight - child.height, sz == rm && (this.children.splice(i--, 1), child.parent = null), 0 == (n -= rm))
                        break;
                    at = 0
                } else
                    at -= sz
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0]instanceof LeafChunk))) {
                var lines = [];
                this.collapse(lines), this.children = [new LeafChunk(lines)], this.children[0].parent = this
            }
        }, collapse: function (lines) {
            for (var i = 0; i < this.children.length; ++i)
                this.children[i].collapse(lines)
        }, insertInner: function (at, lines, height) {
            this.size += lines.length, this.height += height;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (sz >= at) {
                    if (child.insertInner(at, lines, height), child.lines && child.lines.length > 50) {
                        for (; child.lines.length > 50; ) {
                            var spilled = child.lines.splice(child.lines.length - 25, 25), newleaf = new LeafChunk(spilled);
                            child.height -= newleaf.height, this.children.splice(i + 1, 0, newleaf), newleaf.parent = this
                        }
                        this.maybeSpill()
                    }
                    break
                }
                at -= sz
            }
        }, maybeSpill: function () {
            if (!(this.children.length <= 10)) {
                var me = this;
                do {
                    var spilled = me.children.splice(me.children.length - 5, 5), sibling = new BranchChunk(spilled);
                    if (me.parent) {
                        me.size -= sibling.size, me.height -= sibling.height;
                        var myIndex = indexOf(me.parent.children, me);
                        me.parent.children.splice(myIndex + 1, 0, sibling)
                    } else {
                        var copy = new BranchChunk(me.children);
                        copy.parent = me, me.children = [copy, sibling], me = copy
                    }
                    sibling.parent = me.parent
                } while (me.children.length > 10);
                me.parent.maybeSpill()
            }
        }, iterN: function (at, n, op) {
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (sz > at) {
                    var used = Math.min(n, sz - at);
                    if (child.iterN(at, used, op))
                        return!0;
                    if (0 == (n -= used))
                        break;
                    at = 0
                } else
                    at -= sz
            }
        }};
    var nextDocId = 0, Doc = CodeMirror.Doc = function (text, mode, firstLine) {
        if (!(this instanceof Doc))
            return new Doc(text, mode, firstLine);
        null == firstLine && (firstLine = 0), BranchChunk.call(this, [new LeafChunk([new Line("", null)])]), this.first = firstLine, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start), this.history = new History(null), this.id = ++nextDocId, this.modeOption = mode, "string" == typeof text && (text = splitLines(text)), updateDoc(this, {from: start, to: start, text: text}), setSelection(this, simpleSelection(start), sel_dontScroll)
    };
    Doc.prototype = createObj(BranchChunk.prototype, {constructor: Doc, iter: function (from, to, op) {
            op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from)
        }, insert: function (at, lines) {
            for (var height = 0, i = 0; i < lines.length; ++i)
                height += lines[i].height;
            this.insertInner(at - this.first, lines, height)
        }, remove: function (at, n) {
            this.removeInner(at - this.first, n)
        }, getValue: function (lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            return lineSep === !1 ? lines : lines.join(lineSep || "\n");
        }, setValue: docMethodOp(function (code) {
            var top = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length), text: splitLines(code), origin: "setValue"}, !0), setSelection(this, simpleSelection(top))
        }), replaceRange: function (code, from, to, origin) {
            from = clipPos(this, from), to = to ? clipPos(this, to) : from, replaceRange(this, code, from, to, origin)
        }, getRange: function (from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            return lineSep === !1 ? lines : lines.join(lineSep || "\n")
        }, getLine: function (line) {
            var l = this.getLineHandle(line);
            return l && l.text
        }, getLineHandle: function (line) {
            return isLine(this, line) ? getLine(this, line) : void 0
        }, getLineNumber: function (line) {
            return lineNo(line)
        }, getLineHandleVisualStart: function (line) {
            return"number" == typeof line && (line = getLine(this, line)), visualLine(line)
        }, lineCount: function () {
            return this.size
        }, firstLine: function () {
            return this.first
        }, lastLine: function () {
            return this.first + this.size - 1
        }, clipPos: function (pos) {
            return clipPos(this, pos)
        }, getCursor: function (start) {
            var pos, range = this.sel.primary();
            return pos = null == start || "head" == start ? range.head : "anchor" == start ? range.anchor : "end" == start || "to" == start || start === !1 ? range.to() : range.from()
        }, listSelections: function () {
            return this.sel.ranges
        }, somethingSelected: function () {
            return this.sel.somethingSelected()
        }, setCursor: docMethodOp(function (line, ch, options) {
            setSimpleSelection(this, clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line), null, options)
        }), setSelection: docMethodOp(function (anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)
        }), extendSelection: docMethodOp(function (head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options)
        }), extendSelections: docMethodOp(function (heads, options) {
            extendSelections(this, clipPosArray(this, heads, options))
        }), extendSelectionsBy: docMethodOp(function (f, options) {
            extendSelections(this, map(this.sel.ranges, f), options)
        }), setSelections: docMethodOp(function (ranges, primary, options) {
            if (ranges.length) {
                for (var i = 0, out = []; i < ranges.length; i++)
                    out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head));
                null == primary && (primary = Math.min(ranges.length - 1, this.sel.primIndex)), setSelection(this, normalizeSelection(out, primary), options)
            }
        }), addSelection: docMethodOp(function (anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor))), setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)
        }), getSelection: function (lineSep) {
            for (var lines, ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                lines = lines ? lines.concat(sel) : sel
            }
            return lineSep === !1 ? lines : lines.join(lineSep || "\n")
        }, getSelections: function (lineSep) {
            for (var parts = [], ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                lineSep !== !1 && (sel = sel.join(lineSep || "\n")), parts[i] = sel
            }
            return parts
        }, replaceSelection: function (code, collapse, origin) {
            for (var dup = [], i = 0; i < this.sel.ranges.length; i++)
                dup[i] = code;
            this.replaceSelections(dup, collapse, origin || "+input")
        }, replaceSelections: docMethodOp(function (code, collapse, origin) {
            for (var changes = [], sel = this.sel, i = 0; i < sel.ranges.length; i++) {
                var range = sel.ranges[i];
                changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin}
            }
            for (var newSel = collapse && "end" != collapse && computeReplacedSel(this, changes, collapse), i = changes.length - 1; i >= 0; i--)
                makeChange(this, changes[i]);
            newSel ? setSelectionReplaceHistory(this, newSel) : this.cm && ensureCursorVisible(this.cm)
        }), undo: docMethodOp(function () {
            makeChangeFromHistory(this, "undo")
        }), redo: docMethodOp(function () {
            makeChangeFromHistory(this, "redo")
        }), undoSelection: docMethodOp(function () {
            makeChangeFromHistory(this, "undo", !0)
        }), redoSelection: docMethodOp(function () {
            makeChangeFromHistory(this, "redo", !0)
        }), setExtending: function (val) {
            this.extend = val
        }, getExtending: function () {
            return this.extend
        }, historySize: function () {
            for (var hist = this.history, done = 0, undone = 0, i = 0; i < hist.done.length; i++)
                hist.done[i].ranges || ++done;
            for (var i = 0; i < hist.undone.length; i++)
                hist.undone[i].ranges || ++undone;
            return{undo: done, redo: undone}
        }, clearHistory: function () {
            this.history = new History(this.history.maxGeneration)
        }, markClean: function () {
            this.cleanGeneration = this.changeGeneration(!0)
        }, changeGeneration: function (forceSplit) {
            return forceSplit && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation
        }, isClean: function (gen) {
            return this.history.generation == (gen || this.cleanGeneration)
        }, getHistory: function () {
            return{done: copyHistoryArray(this.history.done), undone: copyHistoryArray(this.history.undone)}
        }, setHistory: function (histData) {
            var hist = this.history = new History(this.history.maxGeneration);
            hist.done = copyHistoryArray(histData.done.slice(0), null, !0), hist.undone = copyHistoryArray(histData.undone.slice(0), null, !0)
        }, addLineClass: docMethodOp(function (handle, where, cls) {
            return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function (line) {
                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
                if (line[prop]) {
                    if (classTest(cls).test(line[prop]))
                        return!1;
                    line[prop] += " " + cls
                } else
                    line[prop] = cls;
                return!0
            })
        }), removeLineClass: docMethodOp(function (handle, where, cls) {
            return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function (line) {
                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass", cur = line[prop];
                if (!cur)
                    return!1;
                if (null == cls)
                    line[prop] = null;
                else {
                    var found = cur.match(classTest(cls));
                    if (!found)
                        return!1;
                    var end = found.index + found[0].length;
                    line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null
                }
                return!0
            })
        }), markText: function (from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, "range")
        }, setBookmark: function (pos, options) {
            var realOpts = {replacedWith: options && (null == options.nodeType ? options.widget : options), insertLeft: options && options.insertLeft, clearWhenEmpty: !1, shared: options && options.shared};
            return pos = clipPos(this, pos), markText(this, pos, pos, realOpts, "bookmark")
        }, findMarksAt: function (pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans)
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    (null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker)
                }
            return markers
        }, findMarks: function (from, to, filter) {
            from = clipPos(this, from), to = clipPos(this, to);
            var found = [], lineNo = from.line;
            return this.iter(from.line, to.line + 1, function (line) {
                var spans = line.markedSpans;
                if (spans)
                    for (var i = 0; i < spans.length; i++) {
                        var span = spans[i];
                        lineNo == from.line && from.ch > span.to || null == span.from && lineNo != from.line || lineNo == to.line && span.from > to.ch || filter && !filter(span.marker) || found.push(span.marker.parent || span.marker)
                    }
                ++lineNo
            }), found
        }, getAllMarks: function () {
            var markers = [];
            return this.iter(function (line) {
                var sps = line.markedSpans;
                if (sps)
                    for (var i = 0; i < sps.length; ++i)
                        null != sps[i].from && markers.push(sps[i].marker)
            }), markers
        }, posFromIndex: function (off) {
            var ch, lineNo = this.first;
            return this.iter(function (line) {
                var sz = line.text.length + 1;
                return sz > off ? (ch = off, !0) : (off -= sz, void++lineNo)
            }), clipPos(this, Pos(lineNo, ch))
        }, indexFromPos: function (coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            return coords.line < this.first || coords.ch < 0 ? 0 : (this.iter(this.first, coords.line, function (line) {
                index += line.text.length + 1
            }), index)
        }, copy: function (copyHistory) {
            var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
            return doc.scrollTop = this.scrollTop, doc.scrollLeft = this.scrollLeft, doc.sel = this.sel, doc.extend = !1, copyHistory && (doc.history.undoDepth = this.history.undoDepth, doc.setHistory(this.getHistory())), doc
        }, linkedDoc: function (options) {
            options || (options = {});
            var from = this.first, to = this.first + this.size;
            null != options.from && options.from > from && (from = options.from), null != options.to && options.to < to && (to = options.to);
            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
            return options.sharedHist && (copy.history = this.history), (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist}), copy.linked = [{doc: this, isParent: !0, sharedHist: options.sharedHist}], copySharedMarkers(copy, findSharedMarkers(this)), copy
        }, unlinkDoc: function (other) {
            if (other instanceof CodeMirror && (other = other.doc), this.linked)
                for (var i = 0; i < this.linked.length; ++i) {
                    var link = this.linked[i];
                    if (link.doc == other) {
                        this.linked.splice(i, 1), other.unlinkDoc(this), detachSharedMarkers(findSharedMarkers(this));
                        break
                    }
                }
            if (other.history == this.history) {
                var splitIds = [other.id];
                linkedDocs(other, function (doc) {
                    splitIds.push(doc.id)
                }, !0), other.history = new History(null), other.history.done = copyHistoryArray(this.history.done, splitIds), other.history.undone = copyHistoryArray(this.history.undone, splitIds)
            }
        }, iterLinkedDocs: function (f) {
            linkedDocs(this, f)
        }, getMode: function () {
            return this.mode
        }, getEditor: function () {
            return this.cm
        }}), Doc.prototype.eachLine = Doc.prototype.iter;
    var dontDelegate = "iter insert remove copy getEditor".split(" ");
    for (var prop in Doc.prototype)
        Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror.prototype[prop] = function (method) {
            return function () {
                return method.apply(this.doc, arguments)
            }
        }(Doc.prototype[prop]));
    eventMixin(Doc);
    var e_preventDefault = CodeMirror.e_preventDefault = function (e) {
        e.preventDefault ? e.preventDefault() : e.returnValue = !1
    }, e_stopPropagation = CodeMirror.e_stopPropagation = function (e) {
        e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
    }, e_stop = CodeMirror.e_stop = function (e) {
        e_preventDefault(e), e_stopPropagation(e)
    }, on = CodeMirror.on = function (emitter, type, f) {
        if (emitter.addEventListener)
            emitter.addEventListener(type, f, !1);
        else if (emitter.attachEvent)
            emitter.attachEvent("on" + type, f);
        else {
            var map = emitter._handlers || (emitter._handlers = {}), arr = map[type] || (map[type] = []);
            arr.push(f)
        }
    }, off = CodeMirror.off = function (emitter, type, f) {
        if (emitter.removeEventListener)
            emitter.removeEventListener(type, f, !1);
        else if (emitter.detachEvent)
            emitter.detachEvent("on" + type, f);
        else {
            var arr = emitter._handlers && emitter._handlers[type];
            if (!arr)
                return;
            for (var i = 0; i < arr.length; ++i)
                if (arr[i] == f) {
                    arr.splice(i, 1);
                    break
                }
        }
    }, signal = CodeMirror.signal = function (emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (arr)
            for (var args = Array.prototype.slice.call(arguments, 2), i = 0; i < arr.length; ++i)
                arr[i].apply(null, args)
    }, orphanDelayedCallbacks = null, scrollerGap = 30, Pass = CodeMirror.Pass = {toString: function () {
            return"CodeMirror.Pass"
        }}, sel_dontScroll = {scroll: !1}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};
    Delayed.prototype.set = function (ms, f) {
        clearTimeout(this.id), this.id = setTimeout(f, ms)
    };
    var countColumn = CodeMirror.countColumn = function (string, end, tabSize, startIndex, startValue) {
        null == end && (end = string.search(/[^\s\u00a0]/), -1 == end && (end = string.length));
        for (var i = startIndex || 0, n = startValue || 0; ; ) {
            var nextTab = string.indexOf("	", i);
            if (0 > nextTab || nextTab >= end)
                return n + (end - i);
            n += nextTab - i, n += tabSize - n % tabSize, i = nextTab + 1
        }
    }, spaceStrs = [""], selectInput = function (node) {
        node.select()
    };
    ios ? selectInput = function (node) {
        node.selectionStart = 0, node.selectionEnd = node.value.length
    } : ie && (selectInput = function (node) {
        try {
            node.select()
        } catch (_e) {
        }
    }), [].indexOf && (indexOf = function (array, elt) {
        return array.indexOf(elt)
    }), [].map && (map = function (array, f) {
        return array.map(f)
    });
    var range, nonASCIISingleCaseWordChar = /[\u00df\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/, isWordCharBasic = CodeMirror.isWordChar = function (ch) {
        return/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
    }, extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    range = document.createRange ? function (node, start, end) {
        var r = document.createRange();
        return r.setEnd(node, end), r.setStart(node, start), r
    } : function (node, start, end) {
        var r = document.body.createTextRange();
        try {
            r.moveToElementText(node.parentNode)
        } catch (e) {
            return r
        }
        return r.collapse(!0), r.moveEnd("character", end), r.moveStart("character", start), r
    }, ie && 11 > ie_version && (activeElt = function () {
        try {
            return document.activeElement
        } catch (e) {
            return document.body
        }
    });
    var zwspSupported, badBidiRects, rmClass = CodeMirror.rmClass = function (node, cls) {
        var current = node.className, match = classTest(cls).exec(current);
        if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : "")
        }
    }, addClass = CodeMirror.addClass = function (node, cls) {
        var current = node.className;
        classTest(cls).test(current) || (node.className += (current ? " " : "") + cls)
    }, globalsRegistered = !1, dragAndDrop = function () {
        if (ie && 9 > ie_version)
            return!1;
        var div = elt("div");
        return"draggable"in div || "dragDrop"in div
    }(), splitLines = CodeMirror.splitLines = 3 != "\n\nb".split(/\n/).length ? function (string) {
        for (var pos = 0, result = [], l = string.length; l >= pos; ) {
            var nl = string.indexOf("\n", pos);
            -1 == nl && (nl = string.length);
            var line = string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl), rt = line.indexOf("\r");
            -1 != rt ? (result.push(line.slice(0, rt)), pos += rt + 1) : (result.push(line), pos = nl + 1)
        }
        return result
    } : function (string) {
        return string.split(/\r\n?|\n/)
    }, hasSelection = window.getSelection ? function (te) {
        try {
            return te.selectionStart != te.selectionEnd
        } catch (e) {
            return!1
        }
    } : function (te) {
        try {
            var range = te.ownerDocument.selection.createRange()
        } catch (e) {
        }
        return range && range.parentElement() == te ? 0 != range.compareEndPoints("StartToEnd", range) : !1
    }, hasCopyEvent = function () {
        var e = elt("div");
        return"oncopy"in e ? !0 : (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy)
    }(), badZoomedRects = null, keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete", 63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
    CodeMirror.keyNames = keyNames, function () {
        for (var i = 0; 10 > i; i++)
            keyNames[i + 48] = keyNames[i + 96] = String(i);
        for (var i = 65; 90 >= i; i++)
            keyNames[i] = String.fromCharCode(i);
        for (var i = 1; 12 >= i; i++)
            keyNames[i + 111] = keyNames[i + 63235] = "F" + i
    }();
    var bidiOther, bidiOrdering = function () {
        function charType(code) {
            return 247 >= code ? lowTypes.charAt(code) : code >= 1424 && 1524 >= code ? "R" : code >= 1536 && 1773 >= code ? arabicTypes.charAt(code - 1536) : code >= 1774 && 2220 >= code ? "r" : code >= 8192 && 8203 >= code ? "w" : 8204 == code ? "b" : "L"
        }
        function BidiSpan(level, from, to) {
            this.level = level, this.from = from, this.to = to
        }
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm", bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/, outerType = "L";
        return function (str) {
            if (!bidiRE.test(str))
                return!1;
            for (var type, len = str.length, types = [], i = 0; len > i; ++i)
                types.push(type = charType(str.charCodeAt(i)));
            for (var i = 0, prev = outerType; len > i; ++i) {
                var type = types[i];
                "m" == type ? types[i] = prev : prev = type
            }
            for (var i = 0, cur = outerType; len > i; ++i) {
                var type = types[i];
                "1" == type && "r" == cur ? types[i] = "n" : isStrong.test(type) && (cur = type, "r" == type && (types[i] = "R"))
            }
            for (var i = 1, prev = types[0]; len - 1 > i; ++i) {
                var type = types[i];
                "+" == type && "1" == prev && "1" == types[i + 1] ? types[i] = "1" : "," != type || prev != types[i + 1] || "1" != prev && "n" != prev || (types[i] = prev), prev = type
            }
            for (var i = 0; len > i; ++i) {
                var type = types[i];
                if ("," == type)
                    types[i] = "N";
                else if ("%" == type) {
                    for (var end = i + 1; len > end && "%" == types[end]; ++end)
                        ;
                    for (var replace = i && "!" == types[i - 1] || len > end && "1" == types[end] ? "1" : "N", j = i; end > j; ++j)
                        types[j] = replace;
                    i = end - 1
                }
            }
            for (var i = 0, cur = outerType; len > i; ++i) {
                var type = types[i];
                "L" == cur && "1" == type ? types[i] = "L" : isStrong.test(type) && (cur = type)
            }
            for (var i = 0; len > i; ++i)
                if (isNeutral.test(types[i])) {
                    for (var end = i + 1; len > end && isNeutral.test(types[end]); ++end)
                        ;
                    for (var before = "L" == (i ? types[i - 1] : outerType), after = "L" == (len > end ? types[end] : outerType), replace = before || after ? "L" : "R", j = i; end > j; ++j)
                        types[j] = replace;
                    i = end - 1
                }
            for (var m, order = [], i = 0; len > i; )
                if (countsAsLeft.test(types[i])) {
                    var start = i;
                    for (++i; len > i && countsAsLeft.test(types[i]); ++i)
                        ;
                    order.push(new BidiSpan(0, start, i))
                } else {
                    var pos = i, at = order.length;
                    for (++i; len > i && "L" != types[i]; ++i)
                        ;
                    for (var j = pos; i > j; )
                        if (countsAsNum.test(types[j])) {
                            j > pos && order.splice(at, 0, new BidiSpan(1, pos, j));
                            var nstart = j;
                            for (++j; i > j && countsAsNum.test(types[j]); ++j)
                                ;
                            order.splice(at, 0, new BidiSpan(2, nstart, j)), pos = j
                        } else
                            ++j;
                    i > pos && order.splice(at, 0, new BidiSpan(1, pos, i))
                }
            return 1 == order[0].level && (m = str.match(/^\s+/)) && (order[0].from = m[0].length, order.unshift(new BidiSpan(0, 0, m[0].length))), 1 == lst(order).level && (m = str.match(/\s+$/)) && (lst(order).to -= m[0].length, order.push(new BidiSpan(0, len - m[0].length, len))), order[0].level != lst(order).level && order.push(new BidiSpan(order[0].level, len, len)), order
        }
    }();
    return CodeMirror.version = "4.11.0", CodeMirror
}), function (mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
}(function (CodeMirror) {
    "use strict";
    function keySet(array) {
        for (var keys = {}, i = 0; i < array.length; ++i)
            keys[array[i]] = !0;
        return keys
    }
    function tokenCComment(stream, state) {
        for (var ch, maybeEnd = !1; null != (ch = stream.next()); ) {
            if (maybeEnd && "/" == ch) {
                state.tokenize = null;
                break
            }
            maybeEnd = "*" == ch
        }
        return["comment", "comment"]
    }
    function tokenSGMLComment(stream, state) {
        return stream.skipTo("-->") ? (stream.match("-->"), state.tokenize = null) : stream.skipToEnd(), ["comment", "comment"]
    }
    CodeMirror.defineMode("css", function (config, parserConfig) {
        function ret(style, tp) {
            return type = tp, style
        }
        function tokenBase(stream, state) {
            var ch = stream.next();
            if (tokenHooks[ch]) {
                var result = tokenHooks[ch](stream, state);
                if (result !== !1)
                    return result
            }
            return"@" == ch ? (stream.eatWhile(/[\w\\\-]/), ret("def", stream.current())) : "=" == ch || ("~" == ch || "|" == ch) && stream.eat("=") ? ret(null, "compare") : '"' == ch || "'" == ch ? (state.tokenize = tokenString(ch), state.tokenize(stream, state)) : "#" == ch ? (stream.eatWhile(/[\w\\\-]/), ret("atom", "hash")) : "!" == ch ? (stream.match(/^\s*\w*/), ret("keyword", "important")) : /\d/.test(ch) || "." == ch && stream.eat(/\d/) ? (stream.eatWhile(/[\w.%]/), ret("number", "unit")) : "-" !== ch ? /[,+>*\/]/.test(ch) ? ret(null, "select-op") : "." == ch && stream.match(/^-?[_a-z][_a-z0-9-]*/i) ? ret("qualifier", "qualifier") : /[:;{}\[\]\(\)]/.test(ch) ? ret(null, ch) : "u" == ch && stream.match("rl(") ? (stream.backUp(1), state.tokenize = tokenParenthesized, ret("property", "word")) : /[\w\\\-]/.test(ch) ? (stream.eatWhile(/[\w\\\-]/), ret("property", "word")) : ret(null, null) : /[\d.]/.test(stream.peek()) ? (stream.eatWhile(/[\w.%]/), ret("number", "unit")) : stream.match(/^\w+-/) ? ret("meta", "meta") : void 0
        }
        function tokenString(quote) {
            return function (stream, state) {
                for (var ch, escaped = !1; null != (ch = stream.next()); ) {
                    if (ch == quote && !escaped) {
                        ")" == quote && stream.backUp(1);
                        break
                    }
                    escaped = !escaped && "\\" == ch
                }
                return(ch == quote || !escaped && ")" != quote) && (state.tokenize = null), ret("string", "string")
            }
        }
        function tokenParenthesized(stream, state) {
            return stream.next(), stream.match(/\s*[\"\')]/, !1) ? state.tokenize = null : state.tokenize = tokenString(")"), ret(null, "(")
        }
        function Context(type, indent, prev) {
            this.type = type, this.indent = indent, this.prev = prev
        }
        function pushContext(state, stream, type) {
            return state.context = new Context(type, stream.indentation() + indentUnit, state.context), type
        }
        function popContext(state) {
            return state.context = state.context.prev, state.context.type
        }
        function pass(type, stream, state) {
            return states[state.context.type](type, stream, state)
        }
        function popAndPass(type, stream, state, n) {
            for (var i = n || 1; i > 0; i--)
                state.context = state.context.prev;
            return pass(type, stream, state)
        }
        function wordAsValue(stream) {
            var word = stream.current().toLowerCase();
            override = valueKeywords.hasOwnProperty(word) ? "atom" : colorKeywords.hasOwnProperty(word) ? "keyword" : "variable"
        }
        parserConfig.propertyKeywords || (parserConfig = CodeMirror.resolveMode("text/css"));
        var type, override, indentUnit = config.indentUnit, tokenHooks = parserConfig.tokenHooks, mediaTypes = parserConfig.mediaTypes || {}, mediaFeatures = parserConfig.mediaFeatures || {}, propertyKeywords = parserConfig.propertyKeywords || {}, nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {}, colorKeywords = parserConfig.colorKeywords || {}, valueKeywords = parserConfig.valueKeywords || {}, fontProperties = parserConfig.fontProperties || {}, allowNested = parserConfig.allowNested, states = {};
        return states.top = function (type, stream, state) {
            if ("{" == type)
                return pushContext(state, stream, "block");
            if ("}" == type && state.context.prev)
                return popContext(state);
            if ("@media" == type)
                return pushContext(state, stream, "media");
            if ("@font-face" == type)
                return"font_face_before";
            if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type))
                return"keyframes";
            if (type && "@" == type.charAt(0))
                return pushContext(state, stream, "at");
            if ("hash" == type)
                override = "builtin";
            else if ("word" == type)
                override = "tag";
            else {
                if ("variable-definition" == type)
                    return"maybeprop";
                if ("interpolation" == type)
                    return pushContext(state, stream, "interpolation");
                if (":" == type)
                    return"pseudo";
                if (allowNested && "(" == type)
                    return pushContext(state, stream, "parens")
            }
            return state.context.type
        }, states.block = function (type, stream, state) {
            if ("word" == type) {
                var word = stream.current().toLowerCase();
                return propertyKeywords.hasOwnProperty(word) ? (override = "property", "maybeprop") : nonStandardPropertyKeywords.hasOwnProperty(word) ? (override = "string-2", "maybeprop") : allowNested ? (override = stream.match(/^\s*:(?:\s|$)/, !1) ? "property" : "tag", "block") : (override += " error", "maybeprop")
            }
            return"meta" == type ? "block" : allowNested || "hash" != type && "qualifier" != type ? states.top(type, stream, state) : (override = "error", "block")
        }, states.maybeprop = function (type, stream, state) {
            return":" == type ? pushContext(state, stream, "prop") : pass(type, stream, state)
        }, states.prop = function (type, stream, state) {
            if (";" == type)
                return popContext(state);
            if ("{" == type && allowNested)
                return pushContext(state, stream, "propBlock");
            if ("}" == type || "{" == type)
                return popAndPass(type, stream, state);
            if ("(" == type)
                return pushContext(state, stream, "parens");
            if ("hash" != type || /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
                if ("word" == type)
                    wordAsValue(stream);
                else if ("interpolation" == type)
                    return pushContext(state, stream, "interpolation")
            } else
                override += " error";
            return"prop"
        }, states.propBlock = function (type, _stream, state) {
            return"}" == type ? popContext(state) : "word" == type ? (override = "property", "maybeprop") : state.context.type
        }, states.parens = function (type, stream, state) {
            return"{" == type || "}" == type ? popAndPass(type, stream, state) : ")" == type ? popContext(state) : "(" == type ? pushContext(state, stream, "parens") : ("word" == type && wordAsValue(stream), "parens")
        }, states.pseudo = function (type, stream, state) {
            return"word" == type ? (override = "variable-3", state.context.type) : pass(type, stream, state)
        }, states.media = function (type, stream, state) {
            if ("(" == type)
                return pushContext(state, stream, "media_parens");
            if ("}" == type)
                return popAndPass(type, stream, state);
            if ("{" == type)
                return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
            if ("word" == type) {
                var word = stream.current().toLowerCase();
                override = "only" == word || "not" == word || "and" == word ? "keyword" : mediaTypes.hasOwnProperty(word) ? "attribute" : mediaFeatures.hasOwnProperty(word) ? "property" : "error"
            }
            return state.context.type
        }, states.media_parens = function (type, stream, state) {
            return")" == type ? popContext(state) : "{" == type || "}" == type ? popAndPass(type, stream, state, 2) : states.media(type, stream, state)
        }, states.font_face_before = function (type, stream, state) {
            return"{" == type ? pushContext(state, stream, "font_face") : pass(type, stream, state)
        }, states.font_face = function (type, stream, state) {
            return"}" == type ? popContext(state) : "word" == type ? (override = fontProperties.hasOwnProperty(stream.current().toLowerCase()) ? "property" : "error", "maybeprop") : "font_face"
        }, states.keyframes = function (type, stream, state) {
            return"word" == type ? (override = "variable", "keyframes") : "{" == type ? pushContext(state, stream, "top") : pass(type, stream, state)
        }, states.at = function (type, stream, state) {
            return";" == type ? popContext(state) : "{" == type || "}" == type ? popAndPass(type, stream, state) : ("word" == type ? override = "tag" : "hash" == type && (override = "builtin"), "at")
        }, states.interpolation = function (type, stream, state) {
            return"}" == type ? popContext(state) : "{" == type || ";" == type ? popAndPass(type, stream, state) : ("variable" != type && (override = "error"), "interpolation")
        }, {startState: function (base) {
                return{tokenize: null, state: "top", context: new Context("top", base || 0, null)}
            }, token: function (stream, state) {
                if (!state.tokenize && stream.eatSpace())
                    return null;
                var style = (state.tokenize || tokenBase)(stream, state);
                return style && "object" == typeof style && (type = style[1], style = style[0]), override = style, state.state = states[state.state](type, stream, state), override
            }, indent: function (state, textAfter) {
                var cx = state.context, ch = textAfter && textAfter.charAt(0), indent = cx.indent;
                return"prop" != cx.type || "}" != ch && ")" != ch || (cx = cx.prev), !cx.prev || ("}" != ch || "block" != cx.type && "top" != cx.type && "interpolation" != cx.type && "font_face" != cx.type) && (")" != ch || "parens" != cx.type && "media_parens" != cx.type) && ("{" != ch || "at" != cx.type && "media" != cx.type) || (indent = cx.indent - indentUnit, cx = cx.prev), indent
            }, electricChars: "}", blockCommentStart: "/*", blockCommentEnd: "*/", fold: "brace"}
    });
    var mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"], mediaTypes = keySet(mediaTypes_), mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid"], mediaFeatures = keySet(mediaFeatures_), propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-position", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"], propertyKeywords = keySet(propertyKeywords_), nonStandardPropertyKeywords_ = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_), colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"], colorKeywords = keySet(colorKeywords_), valueKeywords_ = ["above", "absolute", "activeborder", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "column", "compact", "condensed", "contain", "content", "content-box", "context-menu", "continuous", "copy", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "single", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "x-large", "x-small", "xor", "xx-large", "xx-small"], valueKeywords = keySet(valueKeywords_), fontProperties_ = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"], fontProperties = keySet(fontProperties_), allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
    CodeMirror.registerHelper("hintWords", "css", allWords), CodeMirror.defineMIME("text/css", {mediaTypes: mediaTypes, mediaFeatures: mediaFeatures, propertyKeywords: propertyKeywords, nonStandardPropertyKeywords: nonStandardPropertyKeywords, colorKeywords: colorKeywords, valueKeywords: valueKeywords, fontProperties: fontProperties, tokenHooks: {"<": function (stream, state) {
                return stream.match("!--") ? (state.tokenize = tokenSGMLComment, tokenSGMLComment(stream, state)) : !1
            }, "/": function (stream, state) {
                return stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : !1
            }}, name: "css"}), CodeMirror.defineMIME("text/x-scss", {mediaTypes: mediaTypes, mediaFeatures: mediaFeatures, propertyKeywords: propertyKeywords, nonStandardPropertyKeywords: nonStandardPropertyKeywords, colorKeywords: colorKeywords, valueKeywords: valueKeywords, fontProperties: fontProperties, allowNested: !0, tokenHooks: {"/": function (stream, state) {
                return stream.eat("/") ? (stream.skipToEnd(), ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : ["operator", "operator"]
            }, ":": function (stream) {
                return stream.match(/\s*\{/) ? [null, "{"] : !1
            }, $: function (stream) {
                return stream.match(/^[\w-]+/), stream.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"]
            }, "#": function (stream) {
                return stream.eat("{") ? [null, "interpolation"] : !1
            }}, name: "css", helperType: "scss"}), CodeMirror.defineMIME("text/x-less", {mediaTypes: mediaTypes, mediaFeatures: mediaFeatures, propertyKeywords: propertyKeywords, nonStandardPropertyKeywords: nonStandardPropertyKeywords, colorKeywords: colorKeywords, valueKeywords: valueKeywords, fontProperties: fontProperties, allowNested: !0, tokenHooks: {"/": function (stream, state) {
                return stream.eat("/") ? (stream.skipToEnd(), ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : ["operator", "operator"]
            }, "@": function (stream) {
                return stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, !1) ? !1 : (stream.eatWhile(/[\w\\\-]/), stream.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"])
            }, "&": function () {
                return["atom", "atom"]
            }}, name: "css", helperType: "less"})
}), function (mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
}(function (CodeMirror) {
    function clearPlaceholder(cm) {
        cm.state.placeholder && (cm.state.placeholder.parentNode.removeChild(cm.state.placeholder), cm.state.placeholder = null)
    }
    function setPlaceholder(cm) {
        clearPlaceholder(cm);
        var elt = cm.state.placeholder = document.createElement("pre");
        elt.style.cssText = "height: 0; overflow: visible", elt.className = "CodeMirror-placeholder", elt.appendChild(document.createTextNode(cm.getOption("placeholder"))), cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild)
    }
    function onBlur(cm) {
        isEmpty(cm) && setPlaceholder(cm)
    }
    function onChange(cm) {
        var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);
        wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : ""), empty ? setPlaceholder(cm) : clearPlaceholder(cm)
    }
    function isEmpty(cm) {
        return 1 === cm.lineCount() && "" === cm.getLine(0)
    }
    CodeMirror.defineOption("placeholder", "", function (cm, val, old) {
        var prev = old && old != CodeMirror.Init;
        if (val && !prev)
            cm.on("blur", onBlur), cm.on("change", onChange), onChange(cm);
        else if (!val && prev) {
            cm.off("blur", onBlur), cm.off("change", onChange), clearPlaceholder(cm);
            var wrapper = cm.getWrapperElement();
            wrapper.className = wrapper.className.replace(" CodeMirror-empty", "")
        }
        val && !cm.hasFocus() && onBlur(cm)
    })
}), function (mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
}(function (CodeMirror) {
    "use strict";
    function keySet(array) {
        for (var keys = {}, i = 0; i < array.length; ++i)
            keys[array[i]] = !0;
        return keys
    }
    function tokenCComment(stream, state) {
        for (var ch, maybeEnd = !1; null != (ch = stream.next()); ) {
            if (maybeEnd && "/" == ch) {
                state.tokenize = null;
                break
            }
            maybeEnd = "*" == ch
        }
        return["comment", "comment"]
    }
    function tokenSGMLComment(stream, state) {
        return stream.skipTo("-->") ? (stream.match("-->"), state.tokenize = null) : stream.skipToEnd(), ["comment", "comment"]
    }
    CodeMirror.defineMode("css", function (config, parserConfig) {
        function ret(style, tp) {
            return type = tp, style
        }
        function tokenBase(stream, state) {
            var ch = stream.next();
            if (tokenHooks[ch]) {
                var result = tokenHooks[ch](stream, state);
                if (result !== !1)
                    return result
            }
            return"@" == ch ? (stream.eatWhile(/[\w\\\-]/), ret("def", stream.current())) : "=" == ch || ("~" == ch || "|" == ch) && stream.eat("=") ? ret(null, "compare") : '"' == ch || "'" == ch ? (state.tokenize = tokenString(ch), state.tokenize(stream, state)) : "#" == ch ? (stream.eatWhile(/[\w\\\-]/), ret("atom", "hash")) : "!" == ch ? (stream.match(/^\s*\w*/), ret("keyword", "important")) : /\d/.test(ch) || "." == ch && stream.eat(/\d/) ? (stream.eatWhile(/[\w.%]/), ret("number", "unit")) : "-" !== ch ? /[,+>*\/]/.test(ch) ? ret(null, "select-op") : "." == ch && stream.match(/^-?[_a-z][_a-z0-9-]*/i) ? ret("qualifier", "qualifier") : /[:;{}\[\]\(\)]/.test(ch) ? ret(null, ch) : "u" == ch && stream.match("rl(") ? (stream.backUp(1), state.tokenize = tokenParenthesized, ret("property", "word")) : /[\w\\\-]/.test(ch) ? (stream.eatWhile(/[\w\\\-]/), ret("property", "word")) : ret(null, null) : /[\d.]/.test(stream.peek()) ? (stream.eatWhile(/[\w.%]/), ret("number", "unit")) : stream.match(/^\w+-/) ? ret("meta", "meta") : void 0
        }
        function tokenString(quote) {
            return function (stream, state) {
                for (var ch, escaped = !1; null != (ch = stream.next()); ) {
                    if (ch == quote && !escaped) {
                        ")" == quote && stream.backUp(1);
                        break
                    }
                    escaped = !escaped && "\\" == ch
                }
                return(ch == quote || !escaped && ")" != quote) && (state.tokenize = null), ret("string", "string")
            }
        }
        function tokenParenthesized(stream, state) {
            return stream.next(), stream.match(/\s*[\"\')]/, !1) ? state.tokenize = null : state.tokenize = tokenString(")"), ret(null, "(")
        }
        function Context(type, indent, prev) {
            this.type = type, this.indent = indent, this.prev = prev
        }
        function pushContext(state, stream, type) {
            return state.context = new Context(type, stream.indentation() + indentUnit, state.context), type
        }
        function popContext(state) {
            return state.context = state.context.prev, state.context.type
        }
        function pass(type, stream, state) {
            return states[state.context.type](type, stream, state)
        }
        function popAndPass(type, stream, state, n) {
            for (var i = n || 1; i > 0; i--)
                state.context = state.context.prev;
            return pass(type, stream, state)
        }
        function wordAsValue(stream) {
            var word = stream.current().toLowerCase();
            override = valueKeywords.hasOwnProperty(word) ? "atom" : colorKeywords.hasOwnProperty(word) ? "keyword" : "variable"
        }
        parserConfig.propertyKeywords || (parserConfig = CodeMirror.resolveMode("text/css"));
        var type, override, indentUnit = config.indentUnit, tokenHooks = parserConfig.tokenHooks, mediaTypes = parserConfig.mediaTypes || {}, mediaFeatures = parserConfig.mediaFeatures || {}, propertyKeywords = parserConfig.propertyKeywords || {}, nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {}, colorKeywords = parserConfig.colorKeywords || {}, valueKeywords = parserConfig.valueKeywords || {}, fontProperties = parserConfig.fontProperties || {}, allowNested = parserConfig.allowNested, states = {};
        return states.top = function (type, stream, state) {
            if ("{" == type)
                return pushContext(state, stream, "block");
            if ("}" == type && state.context.prev)
                return popContext(state);
            if ("@media" == type)
                return pushContext(state, stream, "media");
            if ("@font-face" == type)
                return"font_face_before";
            if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type))
                return"keyframes";
            if (type && "@" == type.charAt(0))
                return pushContext(state, stream, "at");
            if ("hash" == type)
                override = "builtin";
            else if ("word" == type)
                override = "tag";
            else {
                if ("variable-definition" == type)
                    return"maybeprop";
                if ("interpolation" == type)
                    return pushContext(state, stream, "interpolation");
                if (":" == type)
                    return"pseudo";
                if (allowNested && "(" == type)
                    return pushContext(state, stream, "parens")
            }
            return state.context.type
        }, states.block = function (type, stream, state) {
            if ("word" == type) {
                var word = stream.current().toLowerCase();
                return propertyKeywords.hasOwnProperty(word) ? (override = "property", "maybeprop") : nonStandardPropertyKeywords.hasOwnProperty(word) ? (override = "string-2", "maybeprop") : allowNested ? (override = stream.match(/^\s*:(?:\s|$)/, !1) ? "property" : "tag", "block") : (override += " error", "maybeprop")
            }
            return"meta" == type ? "block" : allowNested || "hash" != type && "qualifier" != type ? states.top(type, stream, state) : (override = "error", "block")
        }, states.maybeprop = function (type, stream, state) {
            return":" == type ? pushContext(state, stream, "prop") : pass(type, stream, state)
        }, states.prop = function (type, stream, state) {
            if (";" == type)
                return popContext(state);
            if ("{" == type && allowNested)
                return pushContext(state, stream, "propBlock");
            if ("}" == type || "{" == type)
                return popAndPass(type, stream, state);
            if ("(" == type)
                return pushContext(state, stream, "parens");
            if ("hash" != type || /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
                if ("word" == type)
                    wordAsValue(stream);
                else if ("interpolation" == type)
                    return pushContext(state, stream, "interpolation")
            } else
                override += " error";
            return"prop"
        }, states.propBlock = function (type, _stream, state) {
            return"}" == type ? popContext(state) : "word" == type ? (override = "property", "maybeprop") : state.context.type
        }, states.parens = function (type, stream, state) {
            return"{" == type || "}" == type ? popAndPass(type, stream, state) : ")" == type ? popContext(state) : "(" == type ? pushContext(state, stream, "parens") : ("word" == type && wordAsValue(stream), "parens")
        }, states.pseudo = function (type, stream, state) {
            return"word" == type ? (override = "variable-3", state.context.type) : pass(type, stream, state)
        }, states.media = function (type, stream, state) {
            if ("(" == type)
                return pushContext(state, stream, "media_parens");
            if ("}" == type)
                return popAndPass(type, stream, state);
            if ("{" == type)
                return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
            if ("word" == type) {
                var word = stream.current().toLowerCase();
                override = "only" == word || "not" == word || "and" == word ? "keyword" : mediaTypes.hasOwnProperty(word) ? "attribute" : mediaFeatures.hasOwnProperty(word) ? "property" : "error"
            }
            return state.context.type
        }, states.media_parens = function (type, stream, state) {
            return")" == type ? popContext(state) : "{" == type || "}" == type ? popAndPass(type, stream, state, 2) : states.media(type, stream, state)
        }, states.font_face_before = function (type, stream, state) {
            return"{" == type ? pushContext(state, stream, "font_face") : pass(type, stream, state)
        }, states.font_face = function (type, stream, state) {
            return"}" == type ? popContext(state) : "word" == type ? (override = fontProperties.hasOwnProperty(stream.current().toLowerCase()) ? "property" : "error", "maybeprop") : "font_face"
        }, states.keyframes = function (type, stream, state) {
            return"word" == type ? (override = "variable", "keyframes") : "{" == type ? pushContext(state, stream, "top") : pass(type, stream, state)
        }, states.at = function (type, stream, state) {
            return";" == type ? popContext(state) : "{" == type || "}" == type ? popAndPass(type, stream, state) : ("word" == type ? override = "tag" : "hash" == type && (override = "builtin"), "at")
        }, states.interpolation = function (type, stream, state) {
            return"}" == type ? popContext(state) : "{" == type || ";" == type ? popAndPass(type, stream, state) : ("variable" != type && (override = "error"), "interpolation")
        }, {startState: function (base) {
                return{tokenize: null, state: "top", context: new Context("top", base || 0, null)}
            }, token: function (stream, state) {
                if (!state.tokenize && stream.eatSpace())
                    return null;
                var style = (state.tokenize || tokenBase)(stream, state);
                return style && "object" == typeof style && (type = style[1], style = style[0]), override = style, state.state = states[state.state](type, stream, state), override
            }, indent: function (state, textAfter) {
                var cx = state.context, ch = textAfter && textAfter.charAt(0), indent = cx.indent;
                return"prop" != cx.type || "}" != ch && ")" != ch || (cx = cx.prev), !cx.prev || ("}" != ch || "block" != cx.type && "top" != cx.type && "interpolation" != cx.type && "font_face" != cx.type) && (")" != ch || "parens" != cx.type && "media_parens" != cx.type) && ("{" != ch || "at" != cx.type && "media" != cx.type) || (indent = cx.indent - indentUnit, cx = cx.prev), indent
            }, electricChars: "}", blockCommentStart: "/*", blockCommentEnd: "*/", fold: "brace"}
    });
    var mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"], mediaTypes = keySet(mediaTypes_), mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid"], mediaFeatures = keySet(mediaFeatures_), propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-position", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"], propertyKeywords = keySet(propertyKeywords_), nonStandardPropertyKeywords_ = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_), colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"], colorKeywords = keySet(colorKeywords_), valueKeywords_ = ["above", "absolute", "activeborder", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "column", "compact", "condensed", "contain", "content", "content-box", "context-menu", "continuous", "copy", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "single", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "x-large", "x-small", "xor", "xx-large", "xx-small"], valueKeywords = keySet(valueKeywords_), fontProperties_ = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"], fontProperties = keySet(fontProperties_), allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
    CodeMirror.registerHelper("hintWords", "css", allWords), CodeMirror.defineMIME("text/css", {mediaTypes: mediaTypes, mediaFeatures: mediaFeatures, propertyKeywords: propertyKeywords, nonStandardPropertyKeywords: nonStandardPropertyKeywords, colorKeywords: colorKeywords, valueKeywords: valueKeywords, fontProperties: fontProperties, tokenHooks: {"<": function (stream, state) {
                return stream.match("!--") ? (state.tokenize = tokenSGMLComment, tokenSGMLComment(stream, state)) : !1
            }, "/": function (stream, state) {
                return stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : !1
            }}, name: "css"}), CodeMirror.defineMIME("text/x-scss", {mediaTypes: mediaTypes, mediaFeatures: mediaFeatures, propertyKeywords: propertyKeywords, nonStandardPropertyKeywords: nonStandardPropertyKeywords, colorKeywords: colorKeywords, valueKeywords: valueKeywords, fontProperties: fontProperties, allowNested: !0, tokenHooks: {"/": function (stream, state) {
                return stream.eat("/") ? (stream.skipToEnd(), ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : ["operator", "operator"]
            }, ":": function (stream) {
                return stream.match(/\s*\{/) ? [null, "{"] : !1
            }, $: function (stream) {
                return stream.match(/^[\w-]+/), stream.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"]
            }, "#": function (stream) {
                return stream.eat("{") ? [null, "interpolation"] : !1
            }}, name: "css", helperType: "scss"}), CodeMirror.defineMIME("text/x-less", {mediaTypes: mediaTypes, mediaFeatures: mediaFeatures, propertyKeywords: propertyKeywords, nonStandardPropertyKeywords: nonStandardPropertyKeywords, colorKeywords: colorKeywords, valueKeywords: valueKeywords, fontProperties: fontProperties, allowNested: !0, tokenHooks: {"/": function (stream, state) {
                return stream.eat("/") ? (stream.skipToEnd(), ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : ["operator", "operator"]
            }, "@": function (stream) {
                return stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, !1) ? !1 : (stream.eatWhile(/[\w\\\-]/), stream.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"])
            }, "&": function () {
                return["atom", "atom"]
            }}, name: "css", helperType: "less"})
}), angular.module("ui.codemirror", []).constant("uiCodemirrorConfig", {}).directive("uiCodemirror", uiCodemirrorDirective), uiCodemirrorDirective.$inject = ["$timeout", "uiCodemirrorConfig"], !function () {
    function d3_ascending(a, b) {
        return b > a ? -1 : a > b ? 1 : a >= b ? 0 : NaN
    }
    function d3_number(x) {
        return null === x ? NaN : +x
    }
    function d3_numeric(x) {
        return!isNaN(x)
    }
    function d3_bisector(compare) {
        return{left: function (a, x, lo, hi) {
                for (arguments.length < 3 && (lo = 0), arguments.length < 4 && (hi = a.length); hi > lo; ) {
                    var mid = lo + hi >>> 1;
                    compare(a[mid], x) < 0 ? lo = mid + 1 : hi = mid
                }
                return lo
            }, right: function (a, x, lo, hi) {
                for (arguments.length < 3 && (lo = 0), arguments.length < 4 && (hi = a.length); hi > lo; ) {
                    var mid = lo + hi >>> 1;
                    compare(a[mid], x) > 0 ? hi = mid : lo = mid + 1
                }
                return lo
            }}
    }
    function d3_zipLength(d) {
        return d.length
    }
    function d3_range_integerScale(x) {
        for (var k = 1; x * k % 1; )
            k *= 10;
        return k
    }
    function d3_class(ctor, properties) {
        for (var key in properties)
            Object.defineProperty(ctor.prototype, key, {value: properties[key], enumerable: !1})
    }
    function d3_Map() {
        this._ = Object.create(null)
    }
    function d3_map_escape(key) {
        return(key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key
    }
    function d3_map_unescape(key) {
        return(key += "")[0] === d3_map_zero ? key.slice(1) : key
    }
    function d3_map_has(key) {
        return d3_map_escape(key)in this._
    }
    function d3_map_remove(key) {
        return(key = d3_map_escape(key))in this._ && delete this._[key]
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._)
            keys.push(d3_map_unescape(key));
        return keys
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._)
            ++size;
        return size
    }
    function d3_map_empty() {
        for (var key in this._)
            return!1;
        return!0
    }
    function d3_Set() {
        this._ = Object.create(null)
    }
    function d3_rebind(target, source, method) {
        return function () {
            var value = method.apply(source, arguments);
            return value === source ? target : value
        }
    }
    function d3_vendorSymbol(object, name) {
        if (name in object)
            return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; n > i; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object)
                return prefixName
        }
    }
    function d3_noop() {
    }
    function d3_dispatch() {
    }
    function d3_dispatch_event(dispatch) {
        function event() {
            for (var l, z = listeners, i = -1, n = z.length; ++i < n; )
                (l = z[i].on) && l.apply(this, arguments);
            return dispatch
        }
        var listeners = [], listenerByName = new d3_Map;
        return event.on = function (name, listener) {
            var i, l = listenerByName.get(name);
            return arguments.length < 2 ? l && l.on : (l && (l.on = null, listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1)), listenerByName.remove(name)), listener && listeners.push(listenerByName.set(name, {on: listener})), dispatch)
        }, event
    }
    function d3_eventPreventDefault() {
        d3.event.preventDefault()
    }
    function d3_eventSource() {
        for (var s, e = d3.event; s = e.sourceEvent; )
            e = s;
        return e
    }
    function d3_eventDispatch(target) {
        for (var dispatch = new d3_dispatch, i = 0, n = arguments.length; ++i < n; )
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch.of = function (thiz, argumentz) {
            return function (e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target, d3.event = e1, dispatch[e1.type].apply(thiz, argumentz)
                } finally {
                    d3.event = e0
                }
            }
        }, dispatch
    }
    function d3_selection(groups) {
        return d3_subclass(groups, d3_selectionPrototype), groups
    }
    function d3_selection_selector(selector) {
        return"function" == typeof selector ? selector : function () {
            return d3_select(selector, this)
        }
    }
    function d3_selection_selectorAll(selector) {
        return"function" == typeof selector ? selector : function () {
            return d3_selectAll(selector, this)
        }
    }
    function d3_selection_attr(name, value) {
        function attrNull() {
            this.removeAttribute(name)
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value)
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value)
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            null == x ? this.removeAttribute(name) : this.setAttribute(name, x)
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            null == x ? this.removeAttributeNS(name.space, name.local) : this.setAttributeNS(name.space, name.local, x)
        }
        return name = d3.ns.qualify(name), null == value ? name.local ? attrNullNS : attrNull : "function" == typeof value ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ")
    }
    function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g")
    }
    function d3_selection_classes(name) {
        return(name + "").trim().split(/^|\s+/)
    }
    function d3_selection_classed(name, value) {
        function classedConstant() {
            for (var i = -1; ++i < n; )
                name[i](this, value)
        }
        function classedFunction() {
            for (var i = -1, x = value.apply(this, arguments); ++i < n; )
                name[i](this, x)
        }
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        return"function" == typeof value ? classedFunction : classedConstant
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function (node, value) {
            if (c = node.classList)
                return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            value ? (re.lastIndex = 0, re.test(c) || node.setAttribute("class", d3_collapse(c + " " + name))) : node.setAttribute("class", d3_collapse(c.replace(re, " ")))
        }
    }
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name)
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority)
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            null == x ? this.style.removeProperty(name) : this.style.setProperty(name, x, priority)
        }
        return null == value ? styleNull : "function" == typeof value ? styleFunction : styleConstant
    }
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name]
        }
        function propertyConstant() {
            this[name] = value
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            null == x ? delete this[name] : this[name] = x
        }
        return null == value ? propertyNull : "function" == typeof value ? propertyFunction : propertyConstant
    }
    function d3_selection_creator(name) {
        return"function" == typeof name ? name : (name = d3.ns.qualify(name)).local ? function () {
            return this.ownerDocument.createElementNS(name.space, name.local)
        } : function () {
            return this.ownerDocument.createElementNS(this.namespaceURI, name)
        }
    }
    function d3_selectionRemove() {
        var parent = this.parentNode;
        parent && parent.removeChild(this)
    }
    function d3_selection_dataNode(data) {
        return{__data__: data}
    }
    function d3_selection_filter(selector) {
        return function () {
            return d3_selectMatches(this, selector)
        }
    }
    function d3_selection_sortComparator(comparator) {
        return arguments.length || (comparator = d3_ascending), function (a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b
        }
    }
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; m > j; j++)
            for (var node, group = groups[j], i = 0, n = group.length; n > i; i++)
                (node = group[i]) && callback(node, i, j);
        return groups
    }
    function d3_selection_enter(selection) {
        return d3_subclass(selection, d3_selection_enterPrototype), selection
    }
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function (d, i, j) {
            var node, group = enter[j].update, n = group.length;
            for (j != j0 && (j0 = j, i0 = 0), i >= i0 && (i0 = i + 1); !(node = group[i0]) && ++i0 < n; )
                ;
            return node
        }
    }
    function d3_selection_on(type, listener, capture) {
        function onRemove() {
            var l = this[name];
            l && (this.removeEventListener(type, l, l.$), delete this[name])
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this), this.addEventListener(type, this[name] = l, l.$ = capture), l._ = listener
        }
        function removeAll() {
            var match, re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$");
            for (var name in this)
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$), delete this[name]
                }
        }
        var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
        i > 0 && (type = type.slice(0, i));
        var filter = d3_selection_onFilters.get(type);
        return filter && (type = filter, wrap = d3_selection_onFilter), i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll
    }
    function d3_selection_onListener(listener, argumentz) {
        return function (e) {
            var o = d3.event;
            d3.event = e, argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz)
            } finally {
                d3.event = o
            }
        }
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function (e) {
            var target = this, related = e.relatedTarget;
            related && (related === target || 8 & related.compareDocumentPosition(target)) || l.call(target, e)
        }
    }
    function d3_event_dragSuppress() {
        var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect) {
            var style = d3_documentElement.style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none"
        }
        return function (suppressClick) {
            if (w.on(name, null), d3_event_dragSelect && (style[d3_event_dragSelect] = select), suppressClick) {
                var off = function () {
                    w.on(click, null)
                };
                w.on(click, function () {
                    d3_eventPreventDefault(), off()
                }, !0), setTimeout(off, 0)
            }
        }
    }
    function d3_mousePoint(container, e) {
        e.changedTouches && (e = e.changedTouches[0]);
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (0 > d3_mouse_bug44083 && (d3_window.scrollX || d3_window.scrollY)) {
                svg = d3.select("body").append("svg").style({position: "absolute", top: 0, left: 0, margin: 0, padding: 0, border: "none"}, "important");
                var ctm = svg[0][0].getScreenCTM();
                d3_mouse_bug44083 = !(ctm.f || ctm.e), svg.remove()
            }
            return d3_mouse_bug44083 ? (point.x = e.pageX, point.y = e.pageY) : (point.x = e.clientX, point.y = e.clientY), point = point.matrixTransform(container.getScreenCTM().inverse()), [point.x, point.y]
        }
        var rect = container.getBoundingClientRect();
        return[e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop]
    }
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier
    }
    function d3_behavior_dragTouchSubject() {
        return d3.event.target
    }
    function d3_behavior_dragMouseSubject() {
        return d3_window
    }
    function d3_sgn(x) {
        return x > 0 ? 1 : 0 > x ? -1 : 0
    }
    function d3_cross2d(a, b, c) {
        return(b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])
    }
    function d3_acos(x) {
        return x > 1 ? 0 : -1 > x ? \u03c0 : Math.acos(x)
    }
    function d3_asin(x) {
        return x > 1 ? half\u03c0 : -1 > x ? -half\u03c0 : Math.asin(x)
    }
    function d3_sinh(x) {
        return((x = Math.exp(x)) - 1 / x) / 2
    }
    function d3_cosh(x) {
        return((x = Math.exp(x)) + 1 / x) / 2
    }
    function d3_tanh(x) {
        return((x = Math.exp(2 * x)) - 1) / (x + 1)
    }
    function d3_haversin(x) {
        return(x = Math.sin(x / 2)) * x
    }
    function d3_color() {
    }
    function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? (this.h = +h, this.s = +s, void(this.l = +l)) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l)
    }
    function d3_hsl_rgb(h, s, l) {
        function v(h) {
            return h > 360 ? h -= 360 : 0 > h && (h += 360), 60 > h ? m1 + (m2 - m1) * h / 60 : 180 > h ? m2 : 240 > h ? m1 + (m2 - m1) * (240 - h) / 60 : m1
        }
        function vv(h) {
            return Math.round(255 * v(h))
        }
        var m1, m2;
        return h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h, s = isNaN(s) ? 0 : 0 > s ? 0 : s > 1 ? 1 : s, l = 0 > l ? 0 : l > 1 ? 1 : l, m2 = .5 >= l ? l * (1 + s) : l + s - l * s, m1 = 2 * l - m2, new d3_rgb(vv(h + 120), vv(h), vv(h - 120))
    }
    function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? (this.h = +h, this.c = +c, void(this.l = +l)) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l)
    }
    function d3_hcl_lab(h, c, l) {
        return isNaN(h) && (h = 0), isNaN(c) && (c = 0), new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c)
    }
    function d3_lab(l, a, b) {
        return this instanceof d3_lab ? (this.l = +l, this.a = +a, void(this.b = +b)) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b)
    }
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        return x = d3_lab_xyz(x) * d3_lab_X, y = d3_lab_xyz(y) * d3_lab_Y, z = d3_lab_xyz(z) * d3_lab_Z, new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z))
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l)
    }
    function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037
    }
    function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (.00304 >= r ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055))
    }
    function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? (this.r = ~~r, this.g = ~~g, void(this.b = ~~b)) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b)
    }
    function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, 255 & value)
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + ""
    }
    function d3_rgb_hex(v) {
        return 16 > v ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16)
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var m1, m2, color, r = 0, g = 0, b = 0;
        if (m1 = /([a-z]+)\((.*)\)/i.exec(format))
            switch (m2 = m1[2].split(","), m1[1]) {
                case"hsl":
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                case"rgb":
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]))
            }
        return(color = d3_rgb_names.get(format)) ? rgb(color.r, color.g, color.b) : (null == format || "#" !== format.charAt(0) || isNaN(color = parseInt(format.slice(1), 16)) || (4 === format.length ? (r = (3840 & color) >> 4, r = r >> 4 | r, g = 240 & color, g = g >> 4 | g, b = 15 & color, b = b << 4 | b) : 7 === format.length && (r = (16711680 & color) >> 16, g = (65280 & color) >> 8, b = 255 & color)), rgb(r, g, b))
    }
    function d3_rgb_hsl(r, g, b) {
        var h, s, min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, l = (max + min) / 2;
        return d ? (s = .5 > l ? d / (max + min) : d / (2 - max - min), h = r == max ? (g - b) / d + (b > g ? 6 : 0) : g == max ? (b - r) / d + 2 : (r - g) / d + 4, h *= 60) : (h = NaN, s = l > 0 && 1 > l ? 0 : h), new d3_hsl(h, s, l)
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r), g = d3_rgb_xyz(g), b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z))
    }
    function d3_rgb_xyz(r) {
        return(r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4)
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return"%" === c.charAt(c.length - 1) ? Math.round(2.55 * f) : f
    }
    function d3_functor(v) {
        return"function" == typeof v ? v : function () {
            return v
        }
    }
    function d3_identity(d) {
        return d
    }
    function d3_xhrType(response) {
        return function (url, mimeType, callback) {
            return 2 === arguments.length && "function" == typeof mimeType && (callback = mimeType, mimeType = null), d3_xhr(url, mimeType, response, callback)
        }
    }
    function d3_xhr(url, mimeType, response, callback) {
        function respond() {
            var result, status = request.status;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && 300 > status || 304 === status) {
                try {
                    result = response.call(xhr, request)
                } catch (e) {
                    return void dispatch.error.call(xhr, e)
                }
                dispatch.load.call(xhr, result)
            } else
                dispatch.error.call(xhr, request)
        }
        var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest, responseType = null;
        return!d3_window.XDomainRequest || "withCredentials"in request || !/^(http(s)?:)?\/\//.test(url) || (request = new XDomainRequest), "onload"in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {
            request.readyState > 3 && respond()
        }, request.onprogress = function (event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request)
            } finally {
                d3.event = o
            }
        }, xhr.header = function (name, value) {
            return name = (name + "").toLowerCase(), arguments.length < 2 ? headers[name] : (null == value ? delete headers[name] : headers[name] = value + "", xhr)
        }, xhr.mimeType = function (value) {
            return arguments.length ? (mimeType = null == value ? null : value + "", xhr) : mimeType
        }, xhr.responseType = function (value) {
            return arguments.length ? (responseType = value, xhr) : responseType
        }, xhr.response = function (value) {
            return response = value, xhr
        }, ["get", "post"].forEach(function (method) {
            xhr[method] = function () {
                return xhr.send.apply(xhr, [method].concat(d3_array(arguments)))
            }
        }), xhr.send = function (method, data, callback) {
            if (2 === arguments.length && "function" == typeof data && (callback = data, data = null), request.open(method, url, !0), null == mimeType || "accept"in headers || (headers.accept = mimeType + ",*/*"), request.setRequestHeader)
                for (var name in headers)
                    request.setRequestHeader(name, headers[name]);
            return null != mimeType && request.overrideMimeType && request.overrideMimeType(mimeType), null != responseType && (request.responseType = responseType), null != callback && xhr.on("error", callback).on("load", function (request) {
                callback(null, request)
            }), dispatch.beforesend.call(xhr, request), request.send(null == data ? null : data), xhr
        }, xhr.abort = function () {
            return request.abort(), xhr
        }, d3.rebind(xhr, dispatch, "on"), null == callback ? xhr : xhr.get(d3_xhr_fixCallback(callback))
    }
    function d3_xhr_fixCallback(callback) {
        return 1 === callback.length ? function (error, request) {
            callback(null == error ? request : null)
        } : callback
    }
    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && "text" !== type ? request.response : request.responseText
    }
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        delay > 24 ? (isFinite(delay) && (clearTimeout(d3_timer_timeout), d3_timer_timeout = setTimeout(d3_timer_step, delay)), d3_timer_interval = 0) : (d3_timer_interval = 1, d3_timer_frame(d3_timer_step))
    }
    function d3_timer_mark() {
        var now = Date.now();
        for (d3_timer_active = d3_timer_queueHead; d3_timer_active; )
            now >= d3_timer_active.t && (d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t)), d3_timer_active = d3_timer_active.n;
        return now
    }
    function d3_timer_sweep() {
        for (var t0, t1 = d3_timer_queueHead, time = 1 / 0; t1; )
            t1.f ? t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n : (t1.t < time && (time = t1.t), t1 = (t0 = t1).n);
        return d3_timer_queueTail = t0, time
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1)
    }
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, 3 * abs(8 - i));
        return{scale: i > 8 ? function (d) {
                return d / k
            } : function (d) {
                return d * k
            }, symbol: d}
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function (value, width) {
            for (var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0; i > 0 && g > 0 && (length + g + 1 > width && (g = Math.max(1, width - length)), t.push(value.substring(i -= g, i + g)), !((length += g + 1) > width)); )
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
            return t.reverse().join(locale_thousands)
        } : d3_identity;
        return function (specifier) {
            var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = !1, exponent = !0;
            switch (precision && (precision = +precision.substring(1)), (zfill || "0" === fill && "=" === align) && (zfill = fill = "0", align = "="), type) {
                case"n":
                    comma = !0, type = "g";
                    break;
                case"%":
                    scale = 100, suffix = "%", type = "f";
                    break;
                case"p":
                    scale = 100, suffix = "%", type = "r";
                    break;
                case"b":
                case"o":
                case"x":
                case"X":
                    "#" === symbol && (prefix = "0" + type.toLowerCase());
                case"c":
                    exponent = !1;
                case"d":
                    integer = !0, precision = 0;
                    break;
                case"s":
                    scale = -1, type = "r"
            }
            "$" === symbol && (prefix = locale_currency[0], suffix = locale_currency[1]), "r" != type || precision || (type = "g"), null != precision && ("g" == type ? precision = Math.max(1, Math.min(21, precision)) : ("e" == type || "f" == type) && (precision = Math.max(0, Math.min(20, precision)))), type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function (value) {
                var fullSuffix = suffix;
                if (integer && value % 1)
                    return"";
                var negative = 0 > value || 0 === value && 0 > 1 / value ? (value = -value, "-") : "-" === sign ? "" : sign;
                if (0 > scale) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value), fullSuffix = unit.symbol + suffix
                } else
                    value *= scale;
                value = type(value, precision);
                var before, after, i = value.lastIndexOf(".");
                if (0 > i) {
                    var j = exponent ? value.lastIndexOf("e") : -1;
                    0 > j ? (before = value, after = "") : (before = value.substring(0, j), after = value.substring(j))
                } else
                    before = value.substring(0, i), after = locale_decimal + value.substring(i + 1);
                !zfill && comma && (before = formatGroup(before, 1 / 0));
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = width > length ? new Array(length = width - length + 1).join(fill) : "";
                return zcomma && (before = formatGroup(padding + before, padding.length ? width - after.length : 1 / 0)), negative += prefix, value = before + after, ("<" === align ? negative + value + padding : ">" === align ? padding + negative + value : "^" === align ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix
            }
        }
    }
    function d3_format_typeDefault(x) {
        return x + ""
    }
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0])
    }
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return d1 - date > date - d0 ? d0 : d1
        }
        function ceil(date) {
            return step(date = local(new d3_date(date - 1)), 1), date
        }
        function offset(date, k) {
            return step(date = new d3_date(+date), k), date
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1)
                for (; t1 > time; )
                    number(time) % dt || times.push(new Date(+time)), step(time, 1);
            else
                for (; t1 > time; )
                    times.push(new Date(+time)), step(time, 1);
            return times
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc;
                return utc._ = t0, range(utc, t1, dt)
            } finally {
                d3_date = Date
            }
        }
        local.floor = local, local.round = round, local.ceil = ceil, local.offset = offset, local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        return utc.floor = utc, utc.round = d3_time_interval_utc(round), utc.ceil = d3_time_interval_utc(ceil), utc.offset = d3_time_interval_utc(offset), utc.range = range_utc, local
    }
    function d3_time_interval_utc(method) {
        return function (date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc;
                return utc._ = date, method(utc, k)._
            } finally {
                d3_date = Date
            }
        }
    }
    function d3_locale_timeFormat(locale) {
        function d3_time_format(template) {
            function format(date) {
                for (var c, p, f, string = [], i = -1, j = 0; ++i < n; )
                    37 === template.charCodeAt(i) && (string.push(template.slice(j, i)), null != (p = d3_time_formatPads[c = template.charAt(++i)]) && (c = template.charAt(++i)), (f = d3_time_formats[c]) && (c = f(date, null == p ? "e" === c ? " " : "0" : p)), string.push(c), j = i + 1);
                return string.push(template.slice(j, i)), string.join("")
            }
            var n = template.length;
            return format.parse = function (string) {
                var d = {y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null}, i = d3_time_parse(d, template, string, 0);
                if (i != string.length)
                    return null;
                "p"in d && (d.H = d.H % 12 + 12 * d.p);
                var localZ = null != d.Z && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date);
                return"j"in d ? date.setFullYear(d.y, 0, d.j) : "w"in d && ("W"in d || "U"in d) ? (date.setFullYear(d.y, 0, 1), date.setFullYear(d.y, 0, "W"in d ? (d.w + 6) % 7 + 7 * d.W - (date.getDay() + 5) % 7 : d.w + 7 * d.U - (date.getDay() + 6) % 7)) : date.setFullYear(d.y, d.m, d.d), date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L), localZ ? date._ : date
            }, format.toString = function () {
                return template
            }, format
        }
        function d3_time_parse(date, template, string, j) {
            for (var c, p, t, i = 0, n = template.length, m = string.length; n > i; ) {
                if (j >= m)
                    return-1;
                if (c = template.charCodeAt(i++), 37 === c) {
                    if (t = template.charAt(i++), p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t], !p || (j = p(date, string, j)) < 0)
                        return-1
                } else if (c != string.charCodeAt(j++))
                    return-1
            }
            return j
        }
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i)
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i)
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i)
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
            return null == n ? -1 : (date.p = n, i)
        }
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        d3_time_format.utc = function (template) {
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date;
                    return utc._ = date, local(utc)
                } finally {
                    d3_date = Date
                }
            }
            var local = d3_time_format(template);
            return format.parse = function (string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._
                } finally {
                    d3_date = Date
                }
            }, format.toString = local.toString, format
        }, d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function (p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i)
        });
        var d3_time_formats = {a: function (d) {
                return locale_shortDays[d.getDay()]
            }, A: function (d) {
                return locale_days[d.getDay()]
            }, b: function (d) {
                return locale_shortMonths[d.getMonth()]
            }, B: function (d) {
                return locale_months[d.getMonth()]
            }, c: d3_time_format(locale_dateTime), d: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2)
            }, e: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2)
            }, H: function (d, p) {
                return d3_time_formatPad(d.getHours(), p, 2)
            }, I: function (d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2)
            }, j: function (d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3)
            }, L: function (d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3)
            }, m: function (d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2)
            }, M: function (d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2)
            }, p: function (d) {
                return locale_periods[+(d.getHours() >= 12)]
            }, S: function (d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2)
            }, U: function (d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2)
            }, w: function (d) {
                return d.getDay()
            }, W: function (d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2)
            }, x: d3_time_format(locale_date), X: d3_time_format(locale_time), y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2)
            }, Y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 1e4, p, 4)
            }, Z: d3_time_zone, "%": function () {
                return"%"
            }}, d3_time_parsers = {a: d3_time_parseWeekdayAbbrev, A: d3_time_parseWeekday, b: d3_time_parseMonthAbbrev, B: d3_time_parseMonth, c: d3_time_parseLocaleFull, d: d3_time_parseDay, e: d3_time_parseDay, H: d3_time_parseHour24, I: d3_time_parseHour24, j: d3_time_parseDayOfYear, L: d3_time_parseMilliseconds, m: d3_time_parseMonthNumber, M: d3_time_parseMinutes, p: d3_time_parseAmPm, S: d3_time_parseSeconds, U: d3_time_parseWeekNumberSunday, w: d3_time_parseWeekdayNumber, W: d3_time_parseWeekNumberMonday, x: d3_time_parseLocaleDate, X: d3_time_parseLocaleTime, y: d3_time_parseYear, Y: d3_time_parseFullYear, Z: d3_time_parseZone, "%": d3_time_parseLiteralPercent};
        return d3_time_format
    }
    function d3_time_formatPad(value, fill, width) {
        var sign = 0 > value ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
        return sign + (width > length ? new Array(width - length + 1).join(fill) + string : string)
    }
    function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i")
    }
    function d3_time_formatLookup(names) {
        for (var map = new d3_Map, i = -1, n = names.length; ++i < n; )
            map.set(names[i].toLowerCase(), i);
        return map
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1
    }
    function d3_time_parseZone(date, string, i) {
        return/^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3)
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2)
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1
    }
    function d3_time_formatMulti(formats) {
        for (var n = formats.length, i = -1; ++i < n; )
            formats[i][0] = this(formats[i][0]);
        return function (date) {
            for (var i = 0, f = formats[i]; !f[1](date); )
                f = formats[++i];
            return f[0](date)
        }
    }
    function d3_adder() {
    }
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b, bv = x - a, av = x - bv;
        o.t = a - av + (b - bv)
    }
    function d3_geo_streamGeometry(geometry, listener) {
        geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type) && d3_geo_streamGeometryType[geometry.type](geometry, listener)
    }
    function d3_geo_streamLine(coordinates, listener, closed) {
        var coordinate, i = -1, n = coordinates.length - closed;
        for (listener.lineStart(); ++i < n; )
            coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd()
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        for (listener.polygonStart(); ++i < n; )
            d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd()
    }
    function d3_geo_areaRingStart() {
        function nextPoint(\u03bb, \u03c6) {
            \u03bb *= d3_radians, \u03c6 = \u03c6 * d3_radians / 2 + \u03c0 / 4;
            var d\u03bb = \u03bb - \u03bb0, sd\u03bb = d\u03bb >= 0 ? 1 : -1, ad\u03bb = sd\u03bb * d\u03bb, cos\u03c6 = Math.cos(\u03c6), sin\u03c6 = Math.sin(\u03c6), k = sin\u03c60 * sin\u03c6, u = cos\u03c60 * cos\u03c6 + k * Math.cos(ad\u03bb), v = k * sd\u03bb * Math.sin(ad\u03bb);
            d3_geo_areaRingSum.add(Math.atan2(v, u)), \u03bb0 = \u03bb, cos\u03c60 = cos\u03c6, sin\u03c60 = sin\u03c6
        }
        var \u03bb00, \u03c600, \u03bb0, cos\u03c60, sin\u03c60;
        d3_geo_area.point = function (\u03bb, \u03c6) {
            d3_geo_area.point = nextPoint, \u03bb0 = (\u03bb00 = \u03bb) * d3_radians, cos\u03c60 = Math.cos(\u03c6 = (\u03c600 = \u03c6) * d3_radians / 2 + \u03c0 / 4), sin\u03c60 = Math.sin(\u03c6)
        }, d3_geo_area.lineEnd = function () {
            nextPoint(\u03bb00, \u03c600)
        }
    }
    function d3_geo_cartesian(spherical) {
        var \u03bb = spherical[0], \u03c6 = spherical[1], cos\u03c6 = Math.cos(\u03c6);
        return[cos\u03c6 * Math.cos(\u03bb), cos\u03c6 * Math.sin(\u03bb), Math.sin(\u03c6)]
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
    }
    function d3_geo_cartesianCross(a, b) {
        return[a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0], a[1] += b[1], a[2] += b[2]
    }
    function d3_geo_cartesianScale(vector, k) {
        return[vector[0] * k, vector[1] * k, vector[2] * k]
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l, d[1] /= l, d[2] /= l
    }
    function d3_geo_spherical(cartesian) {
        return[Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])]
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < \u03b5 && abs(a[1] - b[1]) < \u03b5
    }
    function d3_geo_centroidPoint(\u03bb, \u03c6) {
        \u03bb *= d3_radians;
        var cos\u03c6 = Math.cos(\u03c6 *= d3_radians);
        d3_geo_centroidPointXYZ(cos\u03c6 * Math.cos(\u03bb), cos\u03c6 * Math.sin(\u03bb), Math.sin(\u03c6))
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0, d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0, d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0, d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0
    }
    function d3_geo_centroidLineStart() {
        function nextPoint(\u03bb, \u03c6) {
            \u03bb *= d3_radians;
            var cos\u03c6 = Math.cos(\u03c6 *= d3_radians), x = cos\u03c6 * Math.cos(\u03bb), y = cos\u03c6 * Math.sin(\u03bb), z = Math.sin(\u03c6), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w, d3_geo_centroidX1 += w * (x0 + (x0 = x)), d3_geo_centroidY1 += w * (y0 + (y0 = y)), d3_geo_centroidZ1 += w * (z0 + (z0 = z)), d3_geo_centroidPointXYZ(x0, y0, z0)
        }
        var x0, y0, z0;
        d3_geo_centroid.point = function (\u03bb, \u03c6) {
            \u03bb *= d3_radians;
            var cos\u03c6 = Math.cos(\u03c6 *= d3_radians);
            x0 = cos\u03c6 * Math.cos(\u03bb), y0 = cos\u03c6 * Math.sin(\u03bb), z0 = Math.sin(\u03c6), d3_geo_centroid.point = nextPoint, d3_geo_centroidPointXYZ(x0, y0, z0)
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint
    }
    function d3_geo_centroidRingStart() {
        function nextPoint(\u03bb, \u03c6) {
            \u03bb *= d3_radians;
            var cos\u03c6 = Math.cos(\u03c6 *= d3_radians), x = cos\u03c6 * Math.cos(\u03bb), y = cos\u03c6 * Math.sin(\u03bb), z = Math.sin(\u03c6), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx, d3_geo_centroidY2 += v * cy, d3_geo_centroidZ2 += v * cz, d3_geo_centroidW1 += w, d3_geo_centroidX1 += w * (x0 + (x0 = x)), d3_geo_centroidY1 += w * (y0 + (y0 = y)), d3_geo_centroidZ1 += w * (z0 + (z0 = z)), d3_geo_centroidPointXYZ(x0, y0, z0)
        }
        var \u03bb00, \u03c600, x0, y0, z0;
        d3_geo_centroid.point = function (\u03bb, \u03c6) {
            \u03bb00 = \u03bb, \u03c600 = \u03c6, d3_geo_centroid.point = nextPoint, \u03bb *= d3_radians;
            var cos\u03c6 = Math.cos(\u03c6 *= d3_radians);
            x0 = cos\u03c6 * Math.cos(\u03bb), y0 = cos\u03c6 * Math.sin(\u03bb), z0 = Math.sin(\u03c6), d3_geo_centroidPointXYZ(x0, y0, z0)
        }, d3_geo_centroid.lineEnd = function () {
            nextPoint(\u03bb00, \u03c600), d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd, d3_geo_centroid.point = d3_geo_centroidPoint
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1])
        }
        return a.invert && b.invert && (compose.invert = function (x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1])
        }), compose
    }
    function d3_true() {
        return!0
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [], clip = [];
        if (segments.forEach(function (segment) {
            if (!((n = segment.length - 1) <= 0)) {
                var n, p0 = segment[0], p1 = segment[n];
                if (d3_geo_sphericalEqual(p0, p1)) {
                    listener.lineStart();
                    for (var i = 0; n > i; ++i)
                        listener.point((p0 = segment[i])[0], p0[1]);
                    return void listener.lineEnd()
                }
                var a = new d3_geo_clipPolygonIntersection(p0, segment, null, !0), b = new d3_geo_clipPolygonIntersection(p0, null, a, !1);
                a.o = b, subject.push(a), clip.push(b), a = new d3_geo_clipPolygonIntersection(p1, segment, null, !1),
                        b = new d3_geo_clipPolygonIntersection(p1, null, a, !0), a.o = b, subject.push(a), clip.push(b)
            }
        }), clip.sort(compare), d3_geo_clipPolygonLinkCircular(subject), d3_geo_clipPolygonLinkCircular(clip), subject.length) {
            for (var i = 0, entry = clipStartInside, n = clip.length; n > i; ++i)
                clip[i].e = entry = !entry;
            for (var points, point, start = subject[0]; ; ) {
                for (var current = start, isSubject = !0; current.v; )
                    if ((current = current.n) === start)
                        return;
                points = current.z, listener.lineStart();
                do {
                    if (current.v = current.o.v = !0, current.e) {
                        if (isSubject)
                            for (var i = 0, n = points.length; n > i; ++i)
                                listener.point((point = points[i])[0], point[1]);
                        else
                            interpolate(current.x, current.n.x, 1, listener);
                        current = current.n
                    } else {
                        if (isSubject) {
                            points = current.p.z;
                            for (var i = points.length - 1; i >= 0; --i)
                                listener.point((point = points[i])[0], point[1])
                        } else
                            interpolate(current.x, current.p.x, -1, listener);
                        current = current.p
                    }
                    current = current.o, points = current.z, isSubject = !isSubject
                } while (!current.v);
                listener.lineEnd()
            }
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (n = array.length) {
            for (var n, b, i = 0, a = array[0]; ++i < n; )
                a.n = b = array[i], b.p = a, a = b;
            a.n = b = array[0], b.p = a
        }
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point, this.z = points, this.o = other, this.e = entry, this.v = !1, this.n = this.p = null
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function (rotate, listener) {
            function point(\u03bb, \u03c6) {
                var point = rotate(\u03bb, \u03c6);
                pointVisible(\u03bb = point[0], \u03c6 = point[1]) && listener.point(\u03bb, \u03c6)
            }
            function pointLine(\u03bb, \u03c6) {
                var point = rotate(\u03bb, \u03c6);
                line.point(point[0], point[1])
            }
            function lineStart() {
                clip.point = pointLine, line.lineStart()
            }
            function lineEnd() {
                clip.point = point, line.lineEnd()
            }
            function pointRing(\u03bb, \u03c6) {
                ring.push([\u03bb, \u03c6]);
                var point = rotate(\u03bb, \u03c6);
                ringListener.point(point[0], point[1])
            }
            function ringStart() {
                ringListener.lineStart(), ring = []
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]), ringListener.lineEnd();
                var segment, clean = ringListener.clean(), ringSegments = buffer.buffer(), n = ringSegments.length;
                if (ring.pop(), polygon.push(ring), ring = null, n)
                    if (1 & clean) {
                        segment = ringSegments[0];
                        var point, n = segment.length - 1, i = -1;
                        if (n > 0) {
                            for (polygonStarted || (listener.polygonStart(), polygonStarted = !0), listener.lineStart(); ++i < n; )
                                listener.point((point = segment[i])[0], point[1]);
                            listener.lineEnd()
                        }
                    } else
                        n > 1 && 2 & clean && ringSegments.push(ringSegments.pop().concat(ringSegments.shift())), segments.push(ringSegments.filter(d3_geo_clipSegmentLength1))
            }
            var segments, polygon, ring, line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]), clip = {point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function () {
                    clip.point = pointRing, clip.lineStart = ringStart, clip.lineEnd = ringEnd, segments = [], polygon = []
                }, polygonEnd: function () {
                    clip.point = point, clip.lineStart = lineStart, clip.lineEnd = lineEnd, segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    segments.length ? (polygonStarted || (listener.polygonStart(), polygonStarted = !0), d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener)) : clipStartInside && (polygonStarted || (listener.polygonStart(), polygonStarted = !0), listener.lineStart(), interpolate(null, null, 1, listener), listener.lineEnd()), polygonStarted && (listener.polygonEnd(), polygonStarted = !1), segments = polygon = null
                }, sphere: function () {
                    listener.polygonStart(), listener.lineStart(), interpolate(null, null, 1, listener), listener.lineEnd(), listener.polygonEnd()
                }}, buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = !1;
            return clip
        }
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1
    }
    function d3_geo_clipBufferListener() {
        var line, lines = [];
        return{lineStart: function () {
                lines.push(line = [])
            }, point: function (\u03bb, \u03c6) {
                line.push([\u03bb, \u03c6])
            }, lineEnd: d3_noop, buffer: function () {
                var buffer = lines;
                return lines = [], line = null, buffer
            }, rejoin: function () {
                lines.length > 1 && lines.push(lines.pop().concat(lines.shift()))
            }}
    }
    function d3_geo_clipSort(a, b) {
        return((a = a.x)[0] < 0 ? a[1] - half\u03c0 - \u03b5 : half\u03c0 - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half\u03c0 - \u03b5 : half\u03c0 - b[1])
    }
    function d3_geo_clipAntimeridianLine(listener) {
        var clean, \u03bb0 = NaN, \u03c60 = NaN, s\u03bb0 = NaN;
        return{lineStart: function () {
                listener.lineStart(), clean = 1
            }, point: function (\u03bb1, \u03c61) {
                var s\u03bb1 = \u03bb1 > 0 ? \u03c0 : -\u03c0, d\u03bb = abs(\u03bb1 - \u03bb0);
                abs(d\u03bb - \u03c0) < \u03b5 ? (listener.point(\u03bb0, \u03c60 = (\u03c60 + \u03c61) / 2 > 0 ? half\u03c0 : -half\u03c0), listener.point(s\u03bb0, \u03c60), listener.lineEnd(), listener.lineStart(), listener.point(s\u03bb1, \u03c60), listener.point(\u03bb1, \u03c60), clean = 0) : s\u03bb0 !== s\u03bb1 && d\u03bb >= \u03c0 && (abs(\u03bb0 - s\u03bb0) < \u03b5 && (\u03bb0 -= s\u03bb0 * \u03b5), abs(\u03bb1 - s\u03bb1) < \u03b5 && (\u03bb1 -= s\u03bb1 * \u03b5), \u03c60 = d3_geo_clipAntimeridianIntersect(\u03bb0, \u03c60, \u03bb1, \u03c61), listener.point(s\u03bb0, \u03c60), listener.lineEnd(), listener.lineStart(), listener.point(s\u03bb1, \u03c60), clean = 0), listener.point(\u03bb0 = \u03bb1, \u03c60 = \u03c61), s\u03bb0 = s\u03bb1
            }, lineEnd: function () {
                listener.lineEnd(), \u03bb0 = \u03c60 = NaN
            }, clean: function () {
                return 2 - clean
            }}
    }
    function d3_geo_clipAntimeridianIntersect(\u03bb0, \u03c60, \u03bb1, \u03c61) {
        var cos\u03c60, cos\u03c61, sin\u03bb0_\u03bb1 = Math.sin(\u03bb0 - \u03bb1);
        return abs(sin\u03bb0_\u03bb1) > \u03b5 ? Math.atan((Math.sin(\u03c60) * (cos\u03c61 = Math.cos(\u03c61)) * Math.sin(\u03bb1) - Math.sin(\u03c61) * (cos\u03c60 = Math.cos(\u03c60)) * Math.sin(\u03bb0)) / (cos\u03c60 * cos\u03c61 * sin\u03bb0_\u03bb1)) : (\u03c60 + \u03c61) / 2
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var \u03c6;
        if (null == from)
            \u03c6 = direction * half\u03c0, listener.point(-\u03c0, \u03c6), listener.point(0, \u03c6), listener.point(\u03c0, \u03c6), listener.point(\u03c0, 0), listener.point(\u03c0, -\u03c6), listener.point(0, -\u03c6), listener.point(-\u03c0, -\u03c6), listener.point(-\u03c0, 0), listener.point(-\u03c0, \u03c6);
        else if (abs(from[0] - to[0]) > \u03b5) {
            var s = from[0] < to[0] ? \u03c0 : -\u03c0;
            \u03c6 = direction * s / 2, listener.point(-s, \u03c6), listener.point(0, \u03c6), listener.point(s, \u03c6)
        } else
            listener.point(to[0], to[1])
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0], parallel = point[1], meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0], polarAngle = 0, winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; n > i; ++i) {
            var ring = polygon[i], m = ring.length;
            if (m)
                for (var point0 = ring[0], \u03bb0 = point0[0], \u03c60 = point0[1] / 2 + \u03c0 / 4, sin\u03c60 = Math.sin(\u03c60), cos\u03c60 = Math.cos(\u03c60), j = 1; ; ) {
                    j === m && (j = 0), point = ring[j];
                    var \u03bb = point[0], \u03c6 = point[1] / 2 + \u03c0 / 4, sin\u03c6 = Math.sin(\u03c6), cos\u03c6 = Math.cos(\u03c6), d\u03bb = \u03bb - \u03bb0, sd\u03bb = d\u03bb >= 0 ? 1 : -1, ad\u03bb = sd\u03bb * d\u03bb, antimeridian = ad\u03bb > \u03c0, k = sin\u03c60 * sin\u03c6;
                    if (d3_geo_areaRingSum.add(Math.atan2(k * sd\u03bb * Math.sin(ad\u03bb), cos\u03c60 * cos\u03c6 + k * Math.cos(ad\u03bb))), polarAngle += antimeridian ? d\u03bb + sd\u03bb * \u03c4 : d\u03bb, antimeridian ^ \u03bb0 >= meridian ^ \u03bb >= meridian) {
                        var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                        d3_geo_cartesianNormalize(arc);
                        var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                        d3_geo_cartesianNormalize(intersection);
                        var \u03c6arc = (antimeridian ^ d\u03bb >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                        (parallel > \u03c6arc || parallel === \u03c6arc && (arc[0] || arc[1])) && (winding += antimeridian ^ d\u03bb >= 0 ? 1 : -1)
                    }
                    if (!j++)
                        break;
                    \u03bb0 = \u03bb, sin\u03c60 = sin\u03c6, cos\u03c60 = cos\u03c6, point0 = point
                }
        }
        return(-\u03b5 > polarAngle || \u03b5 > polarAngle && 0 > d3_geo_areaRingSum) ^ 1 & winding
    }
    function d3_geo_clipCircle(radius) {
        function visible(\u03bb, \u03c6) {
            return Math.cos(\u03bb) * Math.cos(\u03c6) > cr
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return{lineStart: function () {
                    v00 = v0 = !1, clean = 1
                }, point: function (\u03bb, \u03c6) {
                    var point2, point1 = [\u03bb, \u03c6], v = visible(\u03bb, \u03c6), c = smallRadius ? v ? 0 : code(\u03bb, \u03c6) : v ? code(\u03bb + (0 > \u03bb ? \u03c0 : -\u03c0), \u03c6) : 0;
                    if (!point0 && (v00 = v0 = v) && listener.lineStart(), v !== v0 && (point2 = intersect(point0, point1), (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) && (point1[0] += \u03b5, point1[1] += \u03b5, v = visible(point1[0], point1[1]))), v !== v0)
                        clean = 0, v ? (listener.lineStart(), point2 = intersect(point1, point0), listener.point(point2[0], point2[1])) : (point2 = intersect(point0, point1), listener.point(point2[0], point2[1]), listener.lineEnd()), point0 = point2;
                    else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        c & c0 || !(t = intersect(point1, point0, !0)) || (clean = 0, smallRadius ? (listener.lineStart(), listener.point(t[0][0], t[0][1]), listener.point(t[1][0], t[1][1]), listener.lineEnd()) : (listener.point(t[1][0], t[1][1]), listener.lineEnd(), listener.lineStart(), listener.point(t[0][0], t[0][1])))
                    }
                    !v || point0 && d3_geo_sphericalEqual(point0, point1) || listener.point(point1[0], point1[1]), point0 = point1, v0 = v, c0 = c
                }, lineEnd: function () {
                    v0 && listener.lineEnd(), point0 = null
                }, clean: function () {
                    return clean | (v00 && v0) << 1
                }}
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b), n1 = [1, 0, 0], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant)
                return!two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (!(0 > t2)) {
                var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
                if (d3_geo_cartesianAdd(q, A), q = d3_geo_spherical(q), !two)
                    return q;
                var z, \u03bb0 = a[0], \u03bb1 = b[0], \u03c60 = a[1], \u03c61 = b[1];
                \u03bb0 > \u03bb1 && (z = \u03bb0, \u03bb0 = \u03bb1, \u03bb1 = z);
                var \u03b4\u03bb = \u03bb1 - \u03bb0, polar = abs(\u03b4\u03bb - \u03c0) < \u03b5, meridian = polar || \u03b5 > \u03b4\u03bb;
                if (!polar && \u03c60 > \u03c61 && (z = \u03c60, \u03c60 = \u03c61, \u03c61 = z), meridian ? polar ? \u03c60 + \u03c61 > 0 ^ q[1] < (abs(q[0] - \u03bb0) < \u03b5 ? \u03c60 : \u03c61) : \u03c60 <= q[1] && q[1] <= \u03c61 : \u03b4\u03bb > \u03c0 ^ (\u03bb0 <= q[0] && q[0] <= \u03bb1)) {
                    var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                    return d3_geo_cartesianAdd(q1, A), [q, d3_geo_spherical(q1)]
                }
            }
        }
        function code(\u03bb, \u03c6) {
            var r = smallRadius ? radius : \u03c0 - radius, code = 0;
            return-r > \u03bb ? code |= 1 : \u03bb > r && (code |= 2), -r > \u03c6 ? code |= 4 : \u03c6 > r && (code |= 8), code
        }
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > \u03b5, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-\u03c0, radius - \u03c0])
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function (line) {
            var r, a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay;
            if (r = x0 - ax, dx || !(r > 0)) {
                if (r /= dx, 0 > dx) {
                    if (t0 > r)
                        return;
                    t1 > r && (t1 = r)
                } else if (dx > 0) {
                    if (r > t1)
                        return;
                    r > t0 && (t0 = r)
                }
                if (r = x1 - ax, dx || !(0 > r)) {
                    if (r /= dx, 0 > dx) {
                        if (r > t1)
                            return;
                        r > t0 && (t0 = r)
                    } else if (dx > 0) {
                        if (t0 > r)
                            return;
                        t1 > r && (t1 = r)
                    }
                    if (r = y0 - ay, dy || !(r > 0)) {
                        if (r /= dy, 0 > dy) {
                            if (t0 > r)
                                return;
                            t1 > r && (t1 = r)
                        } else if (dy > 0) {
                            if (r > t1)
                                return;
                            r > t0 && (t0 = r)
                        }
                        if (r = y1 - ay, dy || !(0 > r)) {
                            if (r /= dy, 0 > dy) {
                                if (r > t1)
                                    return;
                                r > t0 && (t0 = r)
                            } else if (dy > 0) {
                                if (t0 > r)
                                    return;
                                t1 > r && (t1 = r)
                            }
                            return t0 > 0 && (line.a = {x: ax + t0 * dx, y: ay + t0 * dy}), 1 > t1 && (line.b = {x: ax + t1 * dx, y: ay + t1 * dy}), line
                        }
                    }
                }
            }
        }
    }
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        function corner(p, direction) {
            return abs(p[0] - x0) < \u03b5 ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < \u03b5 ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < \u03b5 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x)
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : 0 === ca ? b[1] - a[1] : 1 === ca ? a[0] - b[0] : 2 === ca ? a[1] - b[1] : b[0] - a[0]
        }
        return function (listener) {
            function insidePolygon(p) {
                for (var wn = 0, n = polygon.length, y = p[1], i = 0; n > i; ++i)
                    for (var b, j = 1, v = polygon[i], m = v.length, a = v[0]; m > j; ++j)
                        b = v[j], a[1] <= y ? b[1] > y && d3_cross2d(a, b, p) > 0 && ++wn : b[1] <= y && d3_cross2d(a, b, p) < 0 && --wn, a = b;
                return 0 !== wn
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (null == from || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do
                        listener.point(0 === a || 3 === a ? x0 : x1, a > 1 ? y1 : y0);
                    while ((a = (a + direction + 4) % 4) !== a1)
                } else
                    listener.point(to[0], to[1])
            }
            function pointVisible(x, y) {
                return x >= x0 && x1 >= x && y >= y0 && y1 >= y
            }
            function point(x, y) {
                pointVisible(x, y) && listener.point(x, y)
            }
            function lineStart() {
                clip.point = linePoint, polygon && polygon.push(ring = []), first = !0, v_ = !1, x_ = y_ = NaN
            }
            function lineEnd() {
                segments && (linePoint(x__, y__), v__ && v_ && bufferListener.rejoin(), segments.push(bufferListener.buffer())), clip.point = point, v_ && listener.lineEnd()
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x)), y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon && ring.push([x, y]), first)
                    x__ = x, y__ = y, v__ = v, first = !1, v && (listener.lineStart(), listener.point(x, y));
                else if (v && v_)
                    listener.point(x, y);
                else {
                    var l = {a: {x: x_, y: y_}, b: {x: x, y: y}};
                    clipLine(l) ? (v_ || (listener.lineStart(), listener.point(l.a.x, l.a.y)), listener.point(l.b.x, l.b.y), v || listener.lineEnd(), clean = !1) : v && (listener.lineStart(), listener.point(x, y), clean = !1)
                }
                x_ = x, y_ = y, v_ = v
            }
            var segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean, listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), clip = {point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function () {
                    listener = bufferListener, segments = [], polygon = [], clean = !0
                }, polygonEnd: function () {
                    listener = listener_, segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([x0, y1]), inside = clean && clipStartInside, visible = segments.length;
                    (inside || visible) && (listener.polygonStart(), inside && (listener.lineStart(), interpolate(null, null, 1, listener), listener.lineEnd()), visible && d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener), listener.polygonEnd()), segments = polygon = ring = null
                }};
            return clip
        }
    }
    function d3_geo_conic(projectAt) {
        var \u03c60 = 0, \u03c61 = \u03c0 / 3, m = d3_geo_projectionMutator(projectAt), p = m(\u03c60, \u03c61);
        return p.parallels = function (_) {
            return arguments.length ? m(\u03c60 = _[0] * \u03c0 / 180, \u03c61 = _[1] * \u03c0 / 180) : [\u03c60 / \u03c0 * 180, \u03c61 / \u03c0 * 180]
        }, p
    }
    function d3_geo_conicEqualArea(\u03c60, \u03c61) {
        function forward(\u03bb, \u03c6) {
            var \u03c1 = Math.sqrt(C - 2 * n * Math.sin(\u03c6)) / n;
            return[\u03c1 * Math.sin(\u03bb *= n), \u03c10 - \u03c1 * Math.cos(\u03bb)]
        }
        var sin\u03c60 = Math.sin(\u03c60), n = (sin\u03c60 + Math.sin(\u03c61)) / 2, C = 1 + sin\u03c60 * (2 * n - sin\u03c60), \u03c10 = Math.sqrt(C) / n;
        return forward.invert = function (x, y) {
            var \u03c10_y = \u03c10 - y;
            return[Math.atan2(x, \u03c10_y) / n, d3_asin((C - (x * x + \u03c10_y * \u03c10_y) * n * n) / (2 * n))]
        }, forward
    }
    function d3_geo_pathAreaRingStart() {
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y, x0 = x, y0 = y
        }
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function (x, y) {
            d3_geo_pathArea.point = nextPoint, x00 = x0 = x, y00 = y0 = y
        }, d3_geo_pathArea.lineEnd = function () {
            nextPoint(x00, y00)
        }
    }
    function d3_geo_pathBoundsPoint(x, y) {
        d3_geo_pathBoundsX0 > x && (d3_geo_pathBoundsX0 = x), x > d3_geo_pathBoundsX1 && (d3_geo_pathBoundsX1 = x), d3_geo_pathBoundsY0 > y && (d3_geo_pathBoundsY0 = y), y > d3_geo_pathBoundsY1 && (d3_geo_pathBoundsY1 = y)
    }
    function d3_geo_pathBuffer() {
        function point(x, y) {
            buffer.push("M", x, ",", y, pointCircle)
        }
        function pointLineStart(x, y) {
            buffer.push("M", x, ",", y), stream.point = pointLine
        }
        function pointLine(x, y) {
            buffer.push("L", x, ",", y)
        }
        function lineEnd() {
            stream.point = point
        }
        function lineEndPolygon() {
            buffer.push("Z")
        }
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [], stream = {point: point, lineStart: function () {
                stream.point = pointLineStart
            }, lineEnd: lineEnd, polygonStart: function () {
                stream.lineEnd = lineEndPolygon
            }, polygonEnd: function () {
                stream.lineEnd = lineEnd, stream.point = point
            }, pointRadius: function (_) {
                return pointCircle = d3_geo_pathBufferCircle(_), stream
            }, result: function () {
                if (buffer.length) {
                    var result = buffer.join("");
                    return buffer = [], result
                }
            }};
        return stream
    }
    function d3_geo_pathBufferCircle(radius) {
        return"m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z"
    }
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x, d3_geo_centroidY0 += y, ++d3_geo_centroidZ0
    }
    function d3_geo_pathCentroidLineStart() {
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2, d3_geo_centroidY1 += z * (y0 + y) / 2, d3_geo_centroidZ1 += z, d3_geo_pathCentroidPoint(x0 = x, y0 = y)
        }
        var x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint, d3_geo_pathCentroidPoint(x0 = x, y0 = y)
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint
    }
    function d3_geo_pathCentroidRingStart() {
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2, d3_geo_centroidY1 += z * (y0 + y) / 2, d3_geo_centroidZ1 += z, z = y0 * x - x0 * y, d3_geo_centroidX2 += z * (x0 + x), d3_geo_centroidY2 += z * (y0 + y), d3_geo_centroidZ2 += 3 * z, d3_geo_pathCentroidPoint(x0 = x, y0 = y)
        }
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint, d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y)
        }, d3_geo_pathCentroid.lineEnd = function () {
            nextPoint(x00, y00)
        }
    }
    function d3_geo_pathContext(context) {
        function point(x, y) {
            context.moveTo(x + pointRadius, y), context.arc(x, y, pointRadius, 0, \u03c4)
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y), stream.point = pointLine
        }
        function pointLine(x, y) {
            context.lineTo(x, y)
        }
        function lineEnd() {
            stream.point = point
        }
        function lineEndPolygon() {
            context.closePath()
        }
        var pointRadius = 4.5, stream = {point: point, lineStart: function () {
                stream.point = pointLineStart
            }, lineEnd: lineEnd, polygonStart: function () {
                stream.lineEnd = lineEndPolygon
            }, polygonEnd: function () {
                stream.lineEnd = lineEnd, stream.point = point
            }, pointRadius: function (_) {
                return pointRadius = _, stream
            }, result: d3_noop};
        return stream
    }
    function d3_geo_resample(project) {
        function resample(stream) {
            return(maxDepth ? resampleRecursive : resampleNone)(stream)
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function (x, y) {
                x = project(x, y), stream.point(x[0], x[1])
            })
        }
        function resampleRecursive(stream) {
            function point(x, y) {
                x = project(x, y), stream.point(x[0], x[1])
            }
            function lineStart() {
                x0 = NaN, resample.point = linePoint, stream.lineStart()
            }
            function linePoint(\u03bb, \u03c6) {
                var c = d3_geo_cartesian([\u03bb, \u03c6]), p = project(\u03bb, \u03c6);
                resampleLineTo(x0, y0, \u03bb0, a0, b0, c0, x0 = p[0], y0 = p[1], \u03bb0 = \u03bb, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream), stream.point(x0, y0)
            }
            function lineEnd() {
                resample.point = point, stream.lineEnd()
            }
            function ringStart() {
                lineStart(), resample.point = ringPoint, resample.lineEnd = ringEnd
            }
            function ringPoint(\u03bb, \u03c6) {
                linePoint(\u03bb00 = \u03bb, \u03c600 = \u03c6), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0, resample.point = linePoint
            }
            function ringEnd() {
                resampleLineTo(x0, y0, \u03bb0, a0, b0, c0, x00, y00, \u03bb00, a00, b00, c00, maxDepth, stream), resample.lineEnd = lineEnd, lineEnd()
            }
            var \u03bb00, \u03c600, x00, y00, a00, b00, c00, \u03bb0, x0, y0, a0, b0, c0, resample = {point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function () {
                    stream.polygonStart(), resample.lineStart = ringStart
                }, polygonEnd: function () {
                    stream.polygonEnd(), resample.lineStart = lineStart
                }};
            return resample
        }
        function resampleLineTo(x0, y0, \u03bb0, a0, b0, c0, x1, y1, \u03bb1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * \u03b42 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), \u03c62 = Math.asin(c /= m), \u03bb2 = abs(abs(c) - 1) < \u03b5 || abs(\u03bb0 - \u03bb1) < \u03b5 ? (\u03bb0 + \u03bb1) / 2 : Math.atan2(b, a), p = project(\u03bb2, \u03c62), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                (dz * dz / d2 > \u03b42 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || cosMinDistance > a0 * a1 + b0 * b1 + c0 * c1) && (resampleLineTo(x0, y0, \u03bb0, a0, b0, c0, x2, y2, \u03bb2, a /= m, b /= m, c, depth, stream), stream.point(x2, y2), resampleLineTo(x2, y2, \u03bb2, a, b, c, x1, y1, \u03bb1, a1, b1, c1, depth, stream))
            }
        }
        var \u03b42 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
        return resample.precision = function (_) {
            return arguments.length ? (maxDepth = (\u03b42 = _ * _) > 0 && 16, resample) : Math.sqrt(\u03b42)
        }, resample
    }
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function (x, y) {
            return project([x * d3_degrees, y * d3_degrees])
        });
        return function (stream) {
            return d3_geo_projectionRadians(resample(stream))
        }
    }
    function d3_geo_transform(stream) {
        this.stream = stream
    }
    function d3_geo_transformPoint(stream, point) {
        return{point: point, sphere: function () {
                stream.sphere()
            }, lineStart: function () {
                stream.lineStart()
            }, lineEnd: function () {
                stream.lineEnd()
            }, polygonStart: function () {
                stream.polygonStart()
            }, polygonEnd: function () {
                stream.polygonEnd()
            }}
    }
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function () {
            return project
        })()
    }
    function d3_geo_projectionMutator(projectAt) {
        function projection(point) {
            return point = projectRotate(point[0] * d3_radians, point[1] * d3_radians), [point[0] * k + \u03b4x, \u03b4y - point[1] * k]
        }
        function invert(point) {
            return point = projectRotate.invert((point[0] - \u03b4x) / k, (\u03b4y - point[1]) / k), point && [point[0] * d3_degrees, point[1] * d3_degrees]
        }
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(\u03b4\u03bb, \u03b4\u03c6, \u03b4\u03b3), project);
            var center = project(\u03bb, \u03c6);
            return \u03b4x = x - center[0] * k, \u03b4y = y + center[1] * k, invalidate()
        }
        function invalidate() {
            return stream && (stream.valid = !1, stream = null), projection
        }
        var project, rotate, projectRotate, \u03b4x, \u03b4y, stream, projectResample = d3_geo_resample(function (x, y) {
            return x = project(x, y), [x[0] * k + \u03b4x, \u03b4y - x[1] * k]
        }), k = 150, x = 480, y = 250, \u03bb = 0, \u03c6 = 0, \u03b4\u03bb = 0, \u03b4\u03c6 = 0, \u03b4\u03b3 = 0, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null;
        return projection.stream = function (output) {
            return stream && (stream.valid = !1), stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output)))), stream.valid = !0, stream
        }, projection.clipAngle = function (_) {
            return arguments.length ? (preclip = null == _ ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians), invalidate()) : clipAngle
        }, projection.clipExtent = function (_) {
            return arguments.length ? (clipExtent = _, postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity, invalidate()) : clipExtent
        }, projection.scale = function (_) {
            return arguments.length ? (k = +_, reset()) : k
        }, projection.translate = function (_) {
            return arguments.length ? (x = +_[0], y = +_[1], reset()) : [x, y]
        }, projection.center = function (_) {
            return arguments.length ? (\u03bb = _[0] % 360 * d3_radians, \u03c6 = _[1] % 360 * d3_radians, reset()) : [\u03bb * d3_degrees, \u03c6 * d3_degrees]
        }, projection.rotate = function (_) {
            return arguments.length ? (\u03b4\u03bb = _[0] % 360 * d3_radians, \u03b4\u03c6 = _[1] % 360 * d3_radians, \u03b4\u03b3 = _.length > 2 ? _[2] % 360 * d3_radians : 0, reset()) : [\u03b4\u03bb * d3_degrees, \u03b4\u03c6 * d3_degrees, \u03b4\u03b3 * d3_degrees]
        }, d3.rebind(projection, projectResample, "precision"), function () {
            return project = projectAt.apply(this, arguments), projection.invert = project.invert && invert, reset()
        }
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function (x, y) {
            stream.point(x * d3_radians, y * d3_radians)
        })
    }
    function d3_geo_equirectangular(\u03bb, \u03c6) {
        return[\u03bb, \u03c6]
    }
    function d3_geo_identityRotation(\u03bb, \u03c6) {
        return[\u03bb > \u03c0 ? \u03bb - \u03c4 : -\u03c0 > \u03bb ? \u03bb + \u03c4 : \u03bb, \u03c6]
    }
    function d3_geo_rotation(\u03b4\u03bb, \u03b4\u03c6, \u03b4\u03b3) {
        return \u03b4\u03bb ? \u03b4\u03c6 || \u03b4\u03b3 ? d3_geo_compose(d3_geo_rotation\u03bb(\u03b4\u03bb), d3_geo_rotation\u03c6\u03b3(\u03b4\u03c6, \u03b4\u03b3)) : d3_geo_rotation\u03bb(\u03b4\u03bb) : \u03b4\u03c6 || \u03b4\u03b3 ? d3_geo_rotation\u03c6\u03b3(\u03b4\u03c6, \u03b4\u03b3) : d3_geo_identityRotation
    }
    function d3_geo_forwardRotation\u03bb(\u03b4\u03bb) {
        return function (\u03bb, \u03c6) {
            return \u03bb += \u03b4\u03bb, [\u03bb > \u03c0 ? \u03bb - \u03c4 : -\u03c0 > \u03bb ? \u03bb + \u03c4 : \u03bb, \u03c6]
        }
    }
    function d3_geo_rotation\u03bb(\u03b4\u03bb) {
        var rotation = d3_geo_forwardRotation\u03bb(\u03b4\u03bb);
        return rotation.invert = d3_geo_forwardRotation\u03bb(-\u03b4\u03bb), rotation
    }
    function d3_geo_rotation\u03c6\u03b3(\u03b4\u03c6, \u03b4\u03b3) {
        function rotation(\u03bb, \u03c6) {
            var cos\u03c6 = Math.cos(\u03c6), x = Math.cos(\u03bb) * cos\u03c6, y = Math.sin(\u03bb) * cos\u03c6, z = Math.sin(\u03c6), k = z * cos\u03b4\u03c6 + x * sin\u03b4\u03c6;
            return[Math.atan2(y * cos\u03b4\u03b3 - k * sin\u03b4\u03b3, x * cos\u03b4\u03c6 - z * sin\u03b4\u03c6), d3_asin(k * cos\u03b4\u03b3 + y * sin\u03b4\u03b3)]
        }
        var cos\u03b4\u03c6 = Math.cos(\u03b4\u03c6), sin\u03b4\u03c6 = Math.sin(\u03b4\u03c6), cos\u03b4\u03b3 = Math.cos(\u03b4\u03b3), sin\u03b4\u03b3 = Math.sin(\u03b4\u03b3);
        return rotation.invert = function (\u03bb, \u03c6) {
            var cos\u03c6 = Math.cos(\u03c6), x = Math.cos(\u03bb) * cos\u03c6, y = Math.sin(\u03bb) * cos\u03c6, z = Math.sin(\u03c6), k = z * cos\u03b4\u03b3 - y * sin\u03b4\u03b3;
            return[Math.atan2(y * cos\u03b4\u03b3 + z * sin\u03b4\u03b3, x * cos\u03b4\u03c6 + k * sin\u03b4\u03c6), d3_asin(k * cos\u03b4\u03c6 - x * sin\u03b4\u03c6)]
        }, rotation
    }
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function (from, to, direction, listener) {
            var step = direction * precision;
            null != from ? (from = d3_geo_circleAngle(cr, from), to = d3_geo_circleAngle(cr, to), (direction > 0 ? to > from : from > to) && (from += direction * \u03c4)) : (from = radius + direction * \u03c4, to = radius - .5 * step);
            for (var point, t = from; direction > 0?t > to:to > t; t -= step)
                listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1])
        }
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr, d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - \u03b5) % (2 * Math.PI)
    }
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - \u03b5, dy).concat(y1);
        return function (x) {
            return y.map(function (y) {
                return[x, y]
            })
        }
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - \u03b5, dx).concat(x1);
        return function (y) {
            return x.map(function (x) {
                return[x, y]
            })
        }
    }
    function d3_source(d) {
        return d.source
    }
    function d3_target(d) {
        return d.target
    }
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d), interpolate = d ? function (t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return[Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees]
        } : function () {
            return[x0 * d3_degrees, y0 * d3_degrees]
        };
        return interpolate.distance = d, interpolate
    }
    function d3_geo_lengthLineStart() {
        function nextPoint(\u03bb, \u03c6) {
            var sin\u03c6 = Math.sin(\u03c6 *= d3_radians), cos\u03c6 = Math.cos(\u03c6), t = abs((\u03bb *= d3_radians) - \u03bb0), cos\u0394\u03bb = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos\u03c6 * Math.sin(t)) * t + (t = cos\u03c60 * sin\u03c6 - sin\u03c60 * cos\u03c6 * cos\u0394\u03bb) * t), sin\u03c60 * sin\u03c6 + cos\u03c60 * cos\u03c6 * cos\u0394\u03bb), \u03bb0 = \u03bb, sin\u03c60 = sin\u03c6, cos\u03c60 = cos\u03c6
        }
        var \u03bb0, sin\u03c60, cos\u03c60;
        d3_geo_length.point = function (\u03bb, \u03c6) {
            \u03bb0 = \u03bb * d3_radians, sin\u03c60 = Math.sin(\u03c6 *= d3_radians), cos\u03c60 = Math.cos(\u03c6), d3_geo_length.point = nextPoint
        }, d3_geo_length.lineEnd = function () {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(\u03bb, \u03c6) {
            var cos\u03bb = Math.cos(\u03bb), cos\u03c6 = Math.cos(\u03c6), k = scale(cos\u03bb * cos\u03c6);
            return[k * cos\u03c6 * Math.sin(\u03bb), k * Math.sin(\u03c6)]
        }
        return azimuthal.invert = function (x, y) {
            var \u03c1 = Math.sqrt(x * x + y * y), c = angle(\u03c1), sinc = Math.sin(c), cosc = Math.cos(c);
            return[Math.atan2(x * sinc, \u03c1 * cosc), Math.asin(\u03c1 && y * sinc / \u03c1)]
        }, azimuthal
    }
    function d3_geo_conicConformal(\u03c60, \u03c61) {
        function forward(\u03bb, \u03c6) {
            F > 0 ? -half\u03c0 + \u03b5 > \u03c6 && (\u03c6 = -half\u03c0 + \u03b5) : \u03c6 > half\u03c0 - \u03b5 && (\u03c6 = half\u03c0 - \u03b5);
            var \u03c1 = F / Math.pow(t(\u03c6), n);
            return[\u03c1 * Math.sin(n * \u03bb), F - \u03c1 * Math.cos(n * \u03bb)]
        }
        var cos\u03c60 = Math.cos(\u03c60), t = function (\u03c6) {
            return Math.tan(\u03c0 / 4 + \u03c6 / 2)
        }, n = \u03c60 === \u03c61 ? Math.sin(\u03c60) : Math.log(cos\u03c60 / Math.cos(\u03c61)) / Math.log(t(\u03c61) / t(\u03c60)), F = cos\u03c60 * Math.pow(t(\u03c60), n) / n;
        return n ? (forward.invert = function (x, y) {
            var \u03c10_y = F - y, \u03c1 = d3_sgn(n) * Math.sqrt(x * x + \u03c10_y * \u03c10_y);
            return[Math.atan2(x, \u03c10_y) / n, 2 * Math.atan(Math.pow(F / \u03c1, 1 / n)) - half\u03c0]
        }, forward) : d3_geo_mercator
    }
    function d3_geo_conicEquidistant(\u03c60, \u03c61) {
        function forward(\u03bb, \u03c6) {
            var \u03c1 = G - \u03c6;
            return[\u03c1 * Math.sin(n * \u03bb), G - \u03c1 * Math.cos(n * \u03bb)]
        }
        var cos\u03c60 = Math.cos(\u03c60), n = \u03c60 === \u03c61 ? Math.sin(\u03c60) : (cos\u03c60 - Math.cos(\u03c61)) / (\u03c61 - \u03c60), G = cos\u03c60 / n + \u03c60;
        return abs(n) < \u03b5 ? d3_geo_equirectangular : (forward.invert = function (x, y) {
            var \u03c10_y = G - y;
            return[Math.atan2(x, \u03c10_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + \u03c10_y * \u03c10_y)]
        }, forward)
    }
    function d3_geo_mercator(\u03bb, \u03c6) {
        return[\u03bb, Math.log(Math.tan(\u03c0 / 4 + \u03c6 / 2))]
    }
    function d3_geo_mercatorProjection(project) {
        var clipAuto, m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent;
        return m.scale = function () {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v
        }, m.translate = function () {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v
        }, m.clipExtent = function (_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = null == _) {
                    var k = \u03c0 * scale(), t = translate();
                    clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]])
                }
            } else
                clipAuto && (v = null);
            return v
        }, m.clipExtent(null)
    }
    function d3_geo_transverseMercator(\u03bb, \u03c6) {
        return[Math.log(Math.tan(\u03c0 / 4 + \u03c6 / 2)), -\u03bb]
    }
    function d3_geom_pointX(d) {
        return d[0]
    }
    function d3_geom_pointY(d) {
        return d[1]
    }
    function d3_geom_hullUpper(points) {
        for (var n = points.length, hull = [0, 1], hs = 2, i = 2; n > i; i++) {
            for (; hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0; )
                --hs;
            hull[hs++] = i
        }
        return hull.slice(0, hs)
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1]
    }
    function d3_geom_polygonInside(p, a, b) {
        return(b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0])
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return[x1 + ua * x21, y1 + ua * y21]
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0], b = coordinates[coordinates.length - 1];
        return!(a[0] - b[0] || a[1] - b[1])
    }
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this), this.edge = this.site = this.circle = null
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach;
        return beach.site = site, beach
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach), d3_geom_voronoiBeaches.remove(beach), d3_geom_voronoiBeachPool.push(beach), d3_geom_voronoiRedBlackNode(beach)
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {x: x, y: y}, previous = beach.P, next = beach.N, disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        for (var lArc = previous; lArc.circle && abs(x - lArc.circle.x) < \u03b5 && abs(y - lArc.circle.cy) < \u03b5; )
            previous = lArc.P, disappearing.unshift(lArc), d3_geom_voronoiDetachBeach(lArc), lArc = previous;
        disappearing.unshift(lArc), d3_geom_voronoiDetachCircle(lArc);
        for (var rArc = next; rArc.circle && abs(x - rArc.circle.x) < \u03b5 && abs(y - rArc.circle.cy) < \u03b5; )
            next = rArc.N, disappearing.push(rArc), d3_geom_voronoiDetachBeach(rArc), rArc = next;
        disappearing.push(rArc), d3_geom_voronoiDetachCircle(rArc);
        var iArc, nArcs = disappearing.length;
        for (iArc = 1; nArcs > iArc; ++iArc)
            rArc = disappearing[iArc], lArc = disappearing[iArc - 1], d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        lArc = disappearing[0], rArc = disappearing[nArcs - 1], rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex), d3_geom_voronoiAttachCircle(lArc), d3_geom_voronoiAttachCircle(rArc)
    }
    function d3_geom_voronoiAddBeach(site) {
        for (var lArc, rArc, dxl, dxr, x = site.x, directrix = site.y, node = d3_geom_voronoiBeaches._; node; )
            if (dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x, dxl > \u03b5)
                node = node.L;
            else {
                if (dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix), !(dxr > \u03b5)) {
                    dxl > -\u03b5 ? (lArc = node.P, rArc = node) : dxr > -\u03b5 ? (lArc = node, rArc = node.N) : lArc = rArc = node;
                    break
                }
                if (!node.R) {
                    lArc = node;
                    break
                }
                node = node.R
            }
        var newArc = d3_geom_voronoiCreateBeach(site);
        if (d3_geom_voronoiBeaches.insert(lArc, newArc), lArc || rArc) {
            if (lArc === rArc)
                return d3_geom_voronoiDetachCircle(lArc),
                        rArc = d3_geom_voronoiCreateBeach(lArc.site), d3_geom_voronoiBeaches.insert(newArc, rArc), newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site), d3_geom_voronoiAttachCircle(lArc), void d3_geom_voronoiAttachCircle(rArc);
            if (!rArc)
                return void(newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site));
            d3_geom_voronoiDetachCircle(lArc), d3_geom_voronoiDetachCircle(rArc);
            var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {x: (cy * hb - by * hc) / d + ax, y: (bx * hc - cx * hb) / d + ay};
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex), newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex), rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex), d3_geom_voronoiAttachCircle(lArc), d3_geom_voronoiAttachCircle(rArc)
        }
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
        if (!pby2)
            return rfocx;
        var lArc = arc.P;
        if (!lArc)
            return-(1 / 0);
        site = lArc.site;
        var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
        if (!plby2)
            return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        return aby2 ? (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx : (rfocx + lfocx) / 2
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
            return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : 1 / 0
    }
    function d3_geom_voronoiCell(site) {
        this.site = site, this.edges = []
    }
    function d3_geom_voronoiCloseCells(extent) {
        for (var x2, y2, x3, y3, cell, iHalfEdge, halfEdges, nHalfEdges, start, end, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], cells = d3_geom_voronoiCells, iCell = cells.length; iCell--; )
            if (cell = cells[iCell], cell && cell.prepare())
                for (halfEdges = cell.edges, nHalfEdges = halfEdges.length, iHalfEdge = 0; nHalfEdges > iHalfEdge; )
                    end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y, start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y, (abs(x3 - x2) > \u03b5 || abs(y3 - y2) > \u03b5) && (halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < \u03b5 && y1 - y3 > \u03b5 ? {x: x0, y: abs(x2 - x0) < \u03b5 ? y2 : y1} : abs(y3 - y1) < \u03b5 && x1 - x3 > \u03b5 ? {x: abs(y2 - y1) < \u03b5 ? x2 : x1, y: y1} : abs(x3 - x1) < \u03b5 && y3 - y0 > \u03b5 ? {x: x1, y: abs(x2 - x1) < \u03b5 ? y2 : y0} : abs(y3 - y0) < \u03b5 && x3 - x0 > \u03b5 ? {x: abs(y2 - y0) < \u03b5 ? x2 : x0, y: y0} : null), cell.site, null)), ++nHalfEdges)
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this), this.x = this.y = this.arc = this.site = this.cy = null
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (lArc && rArc) {
            var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
            if (lSite !== rSite) {
                var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by, d = 2 * (ax * cy - ay * cx);
                if (!(d >= -\u03b52)) {
                    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by, circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle;
                    circle.arc = arc, circle.site = cSite, circle.x = x + bx, circle.y = cy + Math.sqrt(x * x + y * y), circle.cy = cy, arc.circle = circle;
                    for (var before = null, node = d3_geom_voronoiCircles._; node; )
                        if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                            if (!node.L) {
                                before = node.P;
                                break
                            }
                            node = node.L
                        } else {
                            if (!node.R) {
                                before = node;
                                break
                            }
                            node = node.R
                        }
                    d3_geom_voronoiCircles.insert(before, circle), before || (d3_geom_voronoiFirstCircle = circle)
                }
            }
        }
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        circle && (circle.P || (d3_geom_voronoiFirstCircle = circle.N), d3_geom_voronoiCircles.remove(circle), d3_geom_voronoiCirclePool.push(circle), d3_geom_voronoiRedBlackNode(circle), arc.circle = null)
    }
    function d3_geom_voronoiClipEdges(extent) {
        for (var e, edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length; i--; )
            e = edges[i], (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < \u03b5 && abs(e.a.y - e.b.y) < \u03b5) && (e.a = e.b = null, edges.splice(i, 1))
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
            return!0;
        var fm, fb, va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2;
        if (ry === ly) {
            if (x0 > fx || fx >= x1)
                return;
            if (lx > rx) {
                if (va) {
                    if (va.y >= y1)
                        return
                } else
                    va = {x: fx, y: y0};
                vb = {x: fx, y: y1}
            } else {
                if (va) {
                    if (va.y < y0)
                        return
                } else
                    va = {x: fx, y: y1};
                vb = {x: fx, y: y0}
            }
        } else if (fm = (lx - rx) / (ry - ly), fb = fy - fm * fx, -1 > fm || fm > 1)
            if (lx > rx) {
                if (va) {
                    if (va.y >= y1)
                        return
                } else
                    va = {x: (y0 - fb) / fm, y: y0};
                vb = {x: (y1 - fb) / fm, y: y1}
            } else {
                if (va) {
                    if (va.y < y0)
                        return
                } else
                    va = {x: (y1 - fb) / fm, y: y1};
                vb = {x: (y0 - fb) / fm, y: y0}
            }
        else if (ry > ly) {
            if (va) {
                if (va.x >= x1)
                    return
            } else
                va = {x: x0, y: fm * x0 + fb};
            vb = {x: x1, y: fm * x1 + fb}
        } else {
            if (va) {
                if (va.x < x0)
                    return
            } else
                va = {x: x1, y: fm * x1 + fb};
            vb = {x: x0, y: fm * x0 + fb}
        }
        return edge.a = va, edge.b = vb, !0
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite, this.r = rSite, this.a = this.b = null
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        return d3_geom_voronoiEdges.push(edge), va && d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va), vb && d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb), d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite)), d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite)), edge
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        return edge.a = va, edge.b = vb, d3_geom_voronoiEdges.push(edge), edge
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        edge.a || edge.b ? edge.l === rSite ? edge.b = vertex : edge.a = vertex : (edge.a = vertex, edge.l = lSite, edge.r = rSite)
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a, vb = edge.b;
        this.edge = edge, this.site = lSite, this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y)
    }
    function d3_geom_voronoiRedBlackTree() {
        this._ = null
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null
    }
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        parent ? parent.L === p ? parent.L = q : parent.R = q : tree._ = q, q.U = parent, p.U = q, p.R = q.L, p.R && (p.R.U = p), q.L = p
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        parent ? parent.L === p ? parent.L = q : parent.R = q : tree._ = q, q.U = parent, p.U = q, p.L = q.R, p.L && (p.L.U = p), q.R = p
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        for (; node.L; )
            node = node.L;
        return node
    }
    function d3_geom_voronoi(sites, bbox) {
        var x0, y0, circle, site = sites.sort(d3_geom_voronoiVertexOrder).pop();
        for (d3_geom_voronoiEdges = [], d3_geom_voronoiCells = new Array(sites.length), d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree, d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree; ; )
            if (circle = d3_geom_voronoiFirstCircle, site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x))
                (site.x !== x0 || site.y !== y0) && (d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site), d3_geom_voronoiAddBeach(site), x0 = site.x, y0 = site.y), site = sites.pop();
            else {
                if (!circle)
                    break;
                d3_geom_voronoiRemoveBeach(circle.arc)
            }
        bbox && (d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox));
        var diagram = {cells: d3_geom_voronoiCells, edges: d3_geom_voronoiEdges};
        return d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null, diagram
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x
    }
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return(a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y)
    }
    function d3_geom_quadtreeCompatX(d) {
        return d.x
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y
    }
    function d3_geom_quadtreeNode() {
        return{leaf: !0, nodes: [], point: null, x: null, y: null}
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = .5 * (x1 + x2), sy = .5 * (y1 + y2), children = node.nodes;
            children[0] && d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy), children[1] && d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy), children[2] && d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2), children[3] && d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2)
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var closestPoint, minDistance2 = 1 / 0;
        return function find(node, x1, y1, x2, y2) {
            if (!(x1 > x3 || y1 > y3 || x0 > x2 || y0 > y2)) {
                if (point = node.point) {
                    var point, dx = x - point[0], dy = y - point[1], distance2 = dx * dx + dy * dy;
                    if (minDistance2 > distance2) {
                        var distance = Math.sqrt(minDistance2 = distance2);
                        x0 = x - distance, y0 = y - distance, x3 = x + distance, y3 = y + distance, closestPoint = point
                    }
                }
                for (var children = node.nodes, xm = .5 * (x1 + x2), ym = .5 * (y1 + y2), right = x >= xm, below = y >= ym, i = below << 1 | right, j = i + 4; j > i; ++i)
                    if (node = children[3 & i])
                        switch (3 & i) {
                            case 0:
                                find(node, x1, y1, xm, ym);
                                break;
                            case 1:
                                find(node, xm, y1, x2, ym);
                                break;
                            case 2:
                                find(node, x1, ym, xm, y2);
                                break;
                            case 3:
                                find(node, xm, ym, x2, y2)
                            }
            }
        }(root, x0, y0, x3, y3), closestPoint
    }
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a), b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function (t) {
            return"#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t))
        }
    }
    function d3_interpolateObject(a, b) {
        var k, i = {}, c = {};
        for (k in a)
            k in b ? i[k] = d3_interpolate(a[k], b[k]) : c[k] = a[k];
        for (k in b)
            k in a || (c[k] = b[k]);
        return function (t) {
            for (k in i)
                c[k] = i[k](t);
            return c
        }
    }
    function d3_interpolateNumber(a, b) {
        return a = +a, b = +b, function (t) {
            return a * (1 - t) + b * t
        }
    }
    function d3_interpolateString(a, b) {
        var am, bm, bs, bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, i = -1, s = [], q = [];
        for (a += "", b += ""; (am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b)); )
            (bs = bm.index) > bi && (bs = b.slice(bi, bs), s[i] ? s[i] += bs : s[++i] = bs), (am = am[0]) === (bm = bm[0]) ? s[i] ? s[i] += bm : s[++i] = bm : (s[++i] = null, q.push({i: i, x: d3_interpolateNumber(am, bm)})), bi = d3_interpolate_numberB.lastIndex;
        return bi < b.length && (bs = b.slice(bi), s[i] ? s[i] += bs : s[++i] = bs), s.length < 2 ? q[0] ? (b = q[0].x, function (t) {
            return b(t) + ""
        }) : function () {
            return b
        } : (b = q.length, function (t) {
            for (var o, i = 0; b > i; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join("")
        })
    }
    function d3_interpolate(a, b) {
        for (var f, i = d3.interpolators.length; --i >= 0 && !(f = d3.interpolators[i](a, b)); )
            ;
        return f
    }
    function d3_interpolateArray(a, b) {
        var i, x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length);
        for (i = 0; n0 > i; ++i)
            x.push(d3_interpolate(a[i], b[i]));
        for (; na > i; ++i)
            c[i] = a[i];
        for (; nb > i; ++i)
            c[i] = b[i];
        return function (t) {
            for (i = 0; n0 > i; ++i)
                c[i] = x[i](t);
            return c
        }
    }
    function d3_ease_clamp(f) {
        return function (t) {
            return 0 >= t ? 0 : t >= 1 ? 1 : f(t)
        }
    }
    function d3_ease_reverse(f) {
        return function (t) {
            return 1 - f(1 - t)
        }
    }
    function d3_ease_reflect(f) {
        return function (t) {
            return.5 * (.5 > t ? f(2 * t) : 2 - f(2 - 2 * t))
        }
    }
    function d3_ease_quad(t) {
        return t * t
    }
    function d3_ease_cubic(t) {
        return t * t * t
    }
    function d3_ease_cubicInOut(t) {
        if (0 >= t)
            return 0;
        if (t >= 1)
            return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (.5 > t ? t3 : 3 * (t - t2) + t3 - .75)
    }
    function d3_ease_poly(e) {
        return function (t) {
            return Math.pow(t, e)
        }
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * half\u03c0)
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1))
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t)
    }
    function d3_ease_elastic(a, p) {
        var s;
        return arguments.length < 2 && (p = .45), arguments.length ? s = p / \u03c4 * Math.asin(1 / a) : (a = 1, s = p / 4), function (t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * \u03c4 / p)
        }
    }
    function d3_ease_back(s) {
        return s || (s = 1.70158), function (t) {
            return t * t * ((s + 1) * t - s)
        }
    }
    function d3_ease_bounce(t) {
        return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
    }
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a), b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        return isNaN(bc) && (bc = 0, ac = isNaN(ac) ? b.c : ac), isNaN(bh) ? (bh = 0, ah = isNaN(ah) ? b.h : ah) : bh > 180 ? bh -= 360 : -180 > bh && (bh += 360), function (t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + ""
        }
    }
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a), b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        return isNaN(bs) && (bs = 0, as = isNaN(as) ? b.s : as), isNaN(bh) ? (bh = 0, ah = isNaN(ah) ? b.h : ah) : bh > 180 ? bh -= 360 : -180 > bh && (bh += 360), function (t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + ""
        }
    }
    function d3_interpolateLab(a, b) {
        a = d3.lab(a), b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function (t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + ""
        }
    }
    function d3_interpolateRound(a, b) {
        return b -= a, function (t) {
            return Math.round(a + b * t)
        }
    }
    function d3_transform(m) {
        var r0 = [m.a, m.b], r1 = [m.c, m.d], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        r0[0] * r1[1] < r1[0] * r0[1] && (r0[0] *= -1, r0[1] *= -1, kx *= -1, kz *= -1), this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees, this.translate = [m.e, m.f], this.scale = [kx, ky], this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0
    }
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1]
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        return k && (a[0] /= k, a[1] /= k), k
    }
    function d3_transformCombine(a, b, k) {
        return a[0] += k * b[0], a[1] += k * b[1], a
    }
    function d3_interpolateTransform(a, b) {
        var n, s = [], q = [], A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
        return ta[0] != tb[0] || ta[1] != tb[1] ? (s.push("translate(", null, ",", null, ")"), q.push({i: 1, x: d3_interpolateNumber(ta[0], tb[0])}, {i: 3, x: d3_interpolateNumber(ta[1], tb[1])})) : tb[0] || tb[1] ? s.push("translate(" + tb + ")") : s.push(""), ra != rb ? (ra - rb > 180 ? rb += 360 : rb - ra > 180 && (ra += 360), q.push({i: s.push(s.pop() + "rotate(", null, ")") - 2, x: d3_interpolateNumber(ra, rb)})) : rb && s.push(s.pop() + "rotate(" + rb + ")"), wa != wb ? q.push({i: s.push(s.pop() + "skewX(", null, ")") - 2, x: d3_interpolateNumber(wa, wb)}) : wb && s.push(s.pop() + "skewX(" + wb + ")"), ka[0] != kb[0] || ka[1] != kb[1] ? (n = s.push(s.pop() + "scale(", null, ",", null, ")"), q.push({i: n - 4, x: d3_interpolateNumber(ka[0], kb[0])}, {i: n - 2, x: d3_interpolateNumber(ka[1], kb[1])})) : (1 != kb[0] || 1 != kb[1]) && s.push(s.pop() + "scale(" + kb + ")"), n = q.length, function (t) {
            for (var o, i = -1; ++i < n; )
                s[(o = q[i]).i] = o.x(t);
            return s.join("")
        }
    }
    function d3_uninterpolateNumber(a, b) {
        return b = (b -= a = +a) || 1 / b, function (x) {
            return(x - a) / b
        }
    }
    function d3_uninterpolateClamp(a, b) {
        return b = (b -= a = +a) || 1 / b, function (x) {
            return Math.max(0, Math.min(1, (x - a) / b))
        }
    }
    function d3_layout_bundlePath(link) {
        for (var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [start]; start !== lca; )
            start = start.parent, points.push(start);
        for (var k = points.length; end !== lca; )
            points.splice(k, 0, end), end = end.parent;
        return points
    }
    function d3_layout_bundleAncestors(node) {
        for (var ancestors = [], parent = node.parent; null != parent; )
            ancestors.push(node), node = parent, parent = parent.parent;
        return ancestors.push(node), ancestors
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
            return a;
        for (var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null; aNode === bNode; )
            sharedNode = aNode, aNode = aNodes.pop(), bNode = bNodes.pop();
        return sharedNode
    }
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= -7
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4, d.px = d.x, d.py = d.y
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= -5
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        if (quad.charge = 0, !quad.leaf)
            for (var c, nodes = quad.nodes, n = nodes.length, i = -1; ++i < n; )
                c = nodes[i], null != c && (d3_layout_forceAccumulate(c, alpha, charges), quad.charge += c.charge, cx += c.charge * c.cx, cy += c.charge * c.cy);
        if (quad.point) {
            quad.leaf || (quad.point.x += Math.random() - .5, quad.point.y += Math.random() - .5);
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k, cx += k * quad.point.x, cy += k * quad.point.y
        }
        quad.cx = cx / quad.charge, quad.cy = cy / quad.charge
    }
    function d3_layout_hierarchyRebind(object, hierarchy) {
        return d3.rebind(object, hierarchy, "sort", "children", "value"), object.nodes = object, object.links = d3_layout_hierarchyLinks, object
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        for (var nodes = [node]; null != (node = nodes.pop()); )
            if (callback(node), (children = node.children) && (n = children.length))
                for (var n, children; --n >= 0; )
                    nodes.push(children[n])
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        for (var nodes = [node], nodes2 = []; null != (node = nodes.pop()); )
            if (nodes2.push(node), (children = node.children) && (n = children.length))
                for (var n, children, i = -1; ++i < n; )
                    nodes.push(children[i]);
        for (; null != (node = nodes2.pop()); )
            callback(node)
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children
    }
    function d3_layout_hierarchyValue(d) {
        return d.value
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function (parent) {
            return(parent.children || []).map(function (child) {
                return{source: parent, target: child}
            })
        }))
    }
    function d3_layout_stackX(d) {
        return d.x
    }
    function d3_layout_stackY(d) {
        return d.y
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0, d.y = y
    }
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length)
    }
    function d3_layout_stackOffsetZero(data) {
        for (var j = -1, m = data[0].length, y0 = []; ++j < m; )
            y0[j] = 0;
        return y0
    }
    function d3_layout_stackMaxIndex(array) {
        for (var k, i = 1, j = 0, v = array[0][1], n = array.length; n > i; ++i)
            (k = array[i][1]) > v && (j = i, v = k);
        return j
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0)
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1]
    }
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1))
    }
    function d3_layout_histogramBinFixed(range, n) {
        for (var x = -1, b = +range[0], m = (range[1] - b) / n, f = []; ++x <= n; )
            f[x] = m * x + b;
        return f
    }
    function d3_layout_histogramRange(values) {
        return[d3.min(values), d3.max(values)]
    }
    function d3_layout_packSort(a, b) {
        return a.value - b.value
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b, b._pack_prev = a, b._pack_next = c, c._pack_prev = b
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b, b._pack_prev = a
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return.999 * dr * dr > dx * dx + dy * dy
    }
    function d3_layout_packSiblings(node) {
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin), xMax = Math.max(node.x + node.r, xMax), yMin = Math.min(node.y - node.r, yMin), yMax = Math.max(node.y + node.r, yMax)
        }
        if ((nodes = node.children) && (n = nodes.length)) {
            var nodes, a, b, c, i, j, k, n, xMin = 1 / 0, xMax = -(1 / 0), yMin = 1 / 0, yMax = -(1 / 0);
            if (nodes.forEach(d3_layout_packLink), a = nodes[0], a.x = -a.r, a.y = 0, bound(a), n > 1 && (b = nodes[1], b.x = b.r, b.y = 0, bound(b), n > 2))
                for (c = nodes[2], d3_layout_packPlace(a, b, c), bound(c), d3_layout_packInsert(a, c), a._pack_prev = c, d3_layout_packInsert(c, b), b = a._pack_next, i = 3; n > i; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next, s1++)
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break
                        }
                    if (1 == isect)
                        for (k = a._pack_prev; k !== j._pack_prev && !d3_layout_packIntersects(k, c); k = k._pack_prev, s2++)
                            ;
                    isect ? (s2 > s1 || s1 == s2 && b.r < a.r ? d3_layout_packSplice(a, b = j) : d3_layout_packSplice(a = k, b), i--) : (d3_layout_packInsert(a, c), b = c, bound(c))
                }
            var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
            for (i = 0; n > i; i++)
                c = nodes[i], c.x -= cx, c.y -= cy, cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
            node.r = cr, nodes.forEach(d3_layout_packUnlink)
        }
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next, delete node._pack_prev
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        if (node.x = x += k * node.x, node.y = y += k * node.y, node.r *= k, children)
            for (var i = -1, n = children.length; ++i < n; )
                d3_layout_packTransform(children[i], x, y, k)
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da, db *= db;
            var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy, c.y = a.y + x * dy - y * dx
        } else
            c.x = a.x + db, c.y = a.y
    }
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t
    }
    function d3_layout_treeRight(v) {
        var n, children = v.children;
        return(n = children.length) ? children[n - 1] : v.t
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change, wp.s += shift, wm.c += change, wp.z += shift, wp.m += shift
    }
    function d3_layout_treeShift(v) {
        for (var w, shift = 0, change = 0, children = v.children, i = children.length; --i >= 0; )
            w = children[i], w.z += shift, w.m += shift, shift += w.s + (change += w.c)
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor
    }
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function (child) {
            return child.y
        })
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function (x, child) {
            return x + child.x
        }, 0) / children.length
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node
    }
    function d3_layout_clusterRight(node) {
        var n, children = node.children;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node
    }
    function d3_layout_treemapPadNull(node) {
        return{x: node.x, y: node.y, dx: node.dx, dy: node.dy}
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        return 0 > dx && (x += dx / 2, dx = 0), 0 > dy && (y += dy / 2, dy = 0), {x: x, y: y, dx: dx, dy: dy}
    }
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return stop > start ? [start, stop] : [stop, start]
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range())
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function (x) {
            return i(u(x))
        }
    }
    function d3_scale_nice(domain, nice) {
        var dx, i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1];
        return x0 > x1 && (dx = i0, i0 = i1, i1 = dx, dx = x0, x0 = x1, x1 = dx), domain[i0] = nice.floor(x0), domain[i1] = nice.ceil(x1), domain
    }
    function d3_scale_niceStep(step) {
        return step ? {floor: function (x) {
                return Math.floor(x / step) * step
            }, ceil: function (x) {
                return Math.ceil(x / step) * step
            }} : d3_scale_niceIdentity
    }
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        for (domain[k] < domain[0] && (domain = domain.slice().reverse(), range = range.slice().reverse()); ++j <= k; )
            u.push(uninterpolate(domain[j - 1], domain[j])), i.push(interpolate(range[j - 1], range[j]));
        return function (x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x))
        }
    }
    function d3_scale_linear(domain, range, interpolate, clamp) {
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            return output = linear(domain, range, uninterpolate, interpolate), input = linear(range, domain, uninterpolate, d3_interpolate), scale
        }
        function scale(x) {
            return output(x)
        }
        var output, input;
        return scale.invert = function (y) {
            return input(y)
        }, scale.domain = function (x) {
            return arguments.length ? (domain = x.map(Number), rescale()) : domain
        }, scale.range = function (x) {
            return arguments.length ? (range = x, rescale()) : range
        }, scale.rangeRound = function (x) {
            return scale.range(x).interpolate(d3_interpolateRound)
        }, scale.clamp = function (x) {
            return arguments.length ? (clamp = x, rescale()) : clamp
        }, scale.interpolate = function (x) {
            return arguments.length ? (interpolate = x, rescale()) : interpolate
        }, scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m)
        }, scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format)
        }, scale.nice = function (m) {
            return d3_scale_linearNice(domain, m), rescale()
        }, scale.copy = function () {
            return d3_scale_linear(domain, range, interpolate, clamp)
        }, rescale()
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp")
    }
    function d3_scale_linearNice(domain, m) {
        return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]))
    }
    function d3_scale_linearTickRange(domain, m) {
        null == m && (m = 10);
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        return.15 >= err ? step *= 10 : .35 >= err ? step *= 5 : .75 >= err && (step *= 2), extent[0] = Math.ceil(extent[0] / step) * step, extent[1] = Math.floor(extent[1] / step) * step + .5 * step, extent[2] = step, extent
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m))
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            if (match.shift(), "s" === match[8]) {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                return match[7] || (match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]))), match[8] = "f", format = d3.format(match.join("")), function (d) {
                    return format(prefix.scale(d)) + prefix.symbol
                }
            }
            match[7] || (match[7] = "." + d3_scale_linearFormatPrecision(match[8], range)), format = match.join("")
        } else
            format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        return d3.format(format)
    }
    function d3_scale_linearPrecision(value) {
        return-Math.floor(Math.log(value) / Math.LN10 + .01)
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +("e" !== type) : p - 2 * ("%" === type)
    }
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return(positive ? Math.log(0 > x ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base)
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x)
        }
        function scale(x) {
            return linear(log(x))
        }
        return scale.invert = function (x) {
            return pow(linear.invert(x))
        }, scale.domain = function (x) {
            return arguments.length ? (positive = x[0] >= 0, linear.domain((domain = x.map(Number)).map(log)), scale) : domain
        }, scale.base = function (_) {
            return arguments.length ? (base = +_, linear.domain(domain.map(log)), scale) : base
        }, scale.nice = function () {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            return linear.domain(niced), domain = niced.map(pow), scale
        }, scale.ticks = function () {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for (; j > i; i++)
                        for (var k = 1; n > k; k++)
                            ticks.push(pow(i) * k);
                    ticks.push(pow(i))
                } else
                    for (ticks.push(pow(i)); i++ < j; )
                        for (var k = n - 1; k > 0; k--)
                            ticks.push(pow(i) * k);
                for (i = 0; ticks[i] < u; i++)
                    ;
                for (j = ticks.length; ticks[j - 1] > v; j--)
                    ;
                ticks = ticks.slice(i, j)
            }
            return ticks
        }, scale.tickFormat = function (n, format) {
            if (!arguments.length)
                return d3_scale_logFormat;
            arguments.length < 2 ? format = d3_scale_logFormat : "function" != typeof format && (format = d3.format(format));
            var e, k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor);
            return function (d) {
                return d / pow(f(log(d) + e)) <= k ? format(d) : ""
            }
        }, scale.copy = function () {
            return d3_scale_log(linear.copy(), base, positive, domain)
        }, d3_scale_linearRebind(scale, linear)
    }
    function d3_scale_pow(linear, exponent, domain) {
        function scale(x) {
            return linear(powp(x))
        }
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        return scale.invert = function (x) {
            return powb(linear.invert(x))
        }, scale.domain = function (x) {
            return arguments.length ? (linear.domain((domain = x.map(Number)).map(powp)), scale) : domain
        }, scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m)
        }, scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format)
        }, scale.nice = function (m) {
            return scale.domain(d3_scale_linearNice(domain, m))
        }, scale.exponent = function (x) {
            return arguments.length ? (powp = d3_scale_powPow(exponent = x), powb = d3_scale_powPow(1 / exponent), linear.domain(domain.map(powp)), scale) : exponent
        }, scale.copy = function () {
            return d3_scale_pow(linear.copy(), exponent, domain)
        }, d3_scale_linearRebind(scale, linear)
    }
    function d3_scale_powPow(e) {
        return function (x) {
            return 0 > x ? -Math.pow(-x, e) : Math.pow(x, e)
        }
    }
    function d3_scale_ordinal(domain, ranger) {
        function scale(x) {
            return range[((index.get(x) || ("range" === ranger.t ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length]
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function (i) {
                return start + step * i
            })
        }
        var index, range, rangeBand;
        return scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = [], index = new d3_Map;
            for (var xi, i = -1, n = x.length; ++i < n; )
                index.has(xi = x[i]) || index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a)
        }, scale.range = function (x) {
            return arguments.length ? (range = x, rangeBand = 0, ranger = {t: "range", a: arguments}, scale) : range
        }, scale.rangePoints = function (x, padding) {
            arguments.length < 2 && (padding = 0);
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
            return range = steps(start + step * padding / 2, step), rangeBand = 0, ranger = {t: "rangePoints", a: arguments}, scale
        }, scale.rangeRoundPoints = function (x, padding) {
            arguments.length < 2 && (padding = 0);
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
            return range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step), rangeBand = 0, ranger = {t: "rangeRoundPoints", a: arguments}, scale
        }, scale.rangeBands = function (x, padding, outerPadding) {
            arguments.length < 2 && (padding = 0), arguments.length < 3 && (outerPadding = padding);
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            return range = steps(start + step * outerPadding, step), reverse && range.reverse(), rangeBand = step * (1 - padding), ranger = {t: "rangeBands", a: arguments}, scale
        }, scale.rangeRoundBands = function (x, padding, outerPadding) {
            arguments.length < 2 && (padding = 0), arguments.length < 3 && (outerPadding = padding);
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            return range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step), reverse && range.reverse(), rangeBand = Math.round(step * (1 - padding)), ranger = {t: "rangeRoundBands", a: arguments}, scale
        }, scale.rangeBand = function () {
            return rangeBand
        }, scale.rangeExtent = function () {
            return d3_scaleExtent(ranger.a[0])
        }, scale.copy = function () {
            return d3_scale_ordinal(domain, ranger)
        }, scale.domain(domain)
    }
    function d3_scale_quantile(domain, range) {
        function rescale() {
            var k = 0, q = range.length;
            for (thresholds = []; ++k < q; )
                thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale
        }
        function scale(x) {
            return isNaN(x = +x) ? void 0 : range[d3.bisect(thresholds, x)]
        }
        var thresholds;
        return scale.domain = function (x) {
            return arguments.length ? (domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending), rescale()) : domain
        }, scale.range = function (x) {
            return arguments.length ? (range = x, rescale()) : range
        }, scale.quantiles = function () {
            return thresholds
        }, scale.invertExtent = function (y) {
            return y = range.indexOf(y), 0 > y ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]]
        }, scale.copy = function () {
            return d3_scale_quantile(domain, range)
        }, rescale()
    }
    function d3_scale_quantize(x0, x1, range) {
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))]
        }
        function rescale() {
            return kx = range.length / (x1 - x0), i = range.length - 1, scale
        }
        var kx, i;
        return scale.domain = function (x) {
            return arguments.length ? (x0 = +x[0], x1 = +x[x.length - 1], rescale()) : [x0, x1]
        }, scale.range = function (x) {
            return arguments.length ? (range = x, rescale()) : range
        }, scale.invertExtent = function (y) {
            return y = range.indexOf(y), y = 0 > y ? NaN : y / kx + x0, [y, y + 1 / kx]
        }, scale.copy = function () {
            return d3_scale_quantize(x0, x1, range)
        }, rescale()
    }
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            return x >= x ? range[d3.bisect(domain, x)] : void 0
        }
        return scale.domain = function (_) {
            return arguments.length ? (domain = _, scale) : domain
        }, scale.range = function (_) {
            return arguments.length ? (range = _, scale) : range
        }, scale.invertExtent = function (y) {
            return y = range.indexOf(y), [domain[y - 1], domain[y]]
        }, scale.copy = function () {
            return d3_scale_threshold(domain, range)
        }, scale
    }
    function d3_scale_identity(domain) {
        function identity(x) {
            return+x
        }
        return identity.invert = identity, identity.domain = identity.range = function (x) {
            return arguments.length ? (domain = x.map(identity), identity) : domain
        }, identity.ticks = function (m) {
            return d3_scale_linearTicks(domain, m)
        }, identity.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format)
        }, identity.copy = function () {
            return d3_scale_identity(domain)
        }, identity
    }
    function d3_zero() {
        return 0
    }
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return(x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (0 > dy ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]]
    }
    function d3_svg_line(projection) {
        function line(data) {
            function segment() {
                segments.push("M", interpolate(projection(points), tension))
            }
            for (var d, segments = [], points = [], i = -1, n = data.length, fx = d3_functor(x), fy = d3_functor(y); ++i < n; )
                defined.call(this, d = data[i], i) ? points.push([+fx.call(this, d, i), +fy.call(this, d, i)]) : points.length && (segment(), points = []);
            return points.length && segment(), segments.length ? segments.join("") : null
        }
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
        return line.x = function (_) {
            return arguments.length ? (x = _, line) : x
        }, line.y = function (_) {
            return arguments.length ? (y = _, line) : y
        }, line.defined = function (_) {
            return arguments.length ? (defined = _, line) : defined
        }, line.interpolate = function (_) {
            return arguments.length ? (interpolateKey = "function" == typeof _ ? interpolate = _ : (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key, line) : interpolateKey
        }, line.tension = function (_) {
            return arguments.length ? (tension = _, line) : tension
        }, line
    }
    function d3_svg_lineLinear(points) {
        return points.join("L")
    }
    function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z"
    }
    function d3_svg_lineStep(points) {
        for (var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]]; ++i < n; )
            path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        return n > 1 && path.push("H", p[0]), path.join("")
    }
    function d3_svg_lineStepBefore(points) {
        for (var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]]; ++i < n; )
            path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("")
    }
    function d3_svg_lineStepAfter(points) {
        for (var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]]; ++i < n; )
            path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("")
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension))
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension))
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension))
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2)
            return d3_svg_lineLinear(points);
        var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad && (path += "Q" + (p[0] - 2 * t0[0] / 3) + "," + (p[1] - 2 * t0[1] / 3) + "," + p[0] + "," + p[1], p0 = points[1], pi = 2), tangents.length > 1) {
            t = tangents[1], p = points[pi], pi++, path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++)
                p = points[pi], t = tangents[i], path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1]
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + 2 * t[0] / 3) + "," + (p[1] + 2 * t[1] / 3) + "," + lp[0] + "," + lp[1]
        }
        return path
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        for (var p0, tangents = [], a = (1 - tension) / 2, p1 = points[0], p2 = points[1], i = 1, n = points.length; ++i < n; )
            p0 = p1, p1 = p2, p2 = points[i], tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
        return tangents
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3)
            return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [x0, x0, x0, (pi = points[1])[0]], py = [y0, y0, y0, pi[1]], path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        for (points.push(points[n - 1]); ++i <= n; )
            pi = points[i], px.shift(), px.push(pi[0]), py.shift(), py.push(pi[1]), d3_svg_lineBasisBezier(path, px, py);
        return points.pop(), path.push("L", pi), path.join("")
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
            return d3_svg_lineLinear(points);
        for (var pi, path = [], i = -1, n = points.length, px = [0], py = [0]; ++i < 3; )
            pi = points[i], px.push(pi[0]), py.push(pi[1]);
        for (path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)), --i; ++i < n; )
            pi = points[i], px.shift(), px.push(pi[0]), py.shift(), py.push(pi[1]), d3_svg_lineBasisBezier(path, px, py);
        return path.join("")
    }
    function d3_svg_lineBasisClosed(points) {
        for (var path, pi, i = -1, n = points.length, m = n + 4, px = [], py = []; ++i < 4; )
            pi = points[i % n], px.push(pi[0]), py.push(pi[1]);
        for (path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)], --i; ++i < m; )
            pi = points[i % n], px.shift(), px.push(pi[0]), py.shift(), py.push(pi[1]), d3_svg_lineBasisBezier(path, px, py);
        return path.join("")
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n)
            for (var p, t, x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1; ++i <= n; )
                p = points[i], t = i / n, p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx), p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
        return d3_svg_lineBasis(points)
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
    }
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y))
    }
    function d3_svg_lineSlope(p0, p1) {
        return(p1[1] - p0[1]) / (p1[0] - p0[0])
    }
    function d3_svg_lineFiniteDifferences(points) {
        for (var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1); ++i < j; )
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        return m[i] = d, m
    }
    function d3_svg_lineMonotoneTangents(points) {
        for (var d, a, b, s, tangents = [], m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1; ++i < j; )
            d = d3_svg_lineSlope(points[i], points[i + 1]), abs(d) < \u03b5 ? m[i] = m[i + 1] = 0 : (a = m[i] / d, b = m[i + 1] / d, s = a * a + b * b, s > 9 && (s = 3 * d / Math.sqrt(s), m[i] = s * a, m[i + 1] = s * b));
        for (i = - 1; ++i <= j; )
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i])), tangents.push([s || 0, m[i] * s || 0]);
        return tangents
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points))
    }
    function d3_svg_lineRadial(points) {
        for (var point, r, a, i = -1, n = points.length; ++i < n; )
            point = points[i], r = point[0], a = point[1] - half\u03c0, point[0] = r * Math.cos(a), point[1] = r * Math.sin(a);
        return points
    }
    function d3_svg_area(projection) {
        function area(data) {
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z")
            }
            for (var d, x, y, segments = [], points0 = [], points1 = [], i = -1, n = data.length, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function () {
                return x
            } : d3_functor(x1), fy1 = y0 === y1 ? function () {
                return y
            } : d3_functor(y1); ++i < n; )
                defined.call(this, d = data[i], i) ? (points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]), points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)])) : points0.length && (segment(), points0 = [], points1 = []);
            return points0.length && segment(), segments.length ? segments.join("") : null
        }
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
        return area.x = function (_) {
            return arguments.length ? (x0 = x1 = _, area) : x1
        }, area.x0 = function (_) {
            return arguments.length ? (x0 = _, area) : x0
        }, area.x1 = function (_) {
            return arguments.length ? (x1 = _, area) : x1
        }, area.y = function (_) {
            return arguments.length ? (y0 = y1 = _, area) : y1
        }, area.y0 = function (_) {
            return arguments.length ? (y0 = _, area) : y0
        }, area.y1 = function (_) {
            return arguments.length ? (y1 = _, area) : y1
        }, area.defined = function (_) {
            return arguments.length ? (defined = _, area) : defined
        }, area.interpolate = function (_) {
            return arguments.length ? (interpolateKey = "function" == typeof _ ? interpolate = _ : (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key, interpolateReverse = interpolate.reverse || interpolate, L = interpolate.closed ? "M" : "L", area) : interpolateKey
        }, area.tension = function (_) {
            return arguments.length ? (tension = _, area) : tension
        }, area
    }
    function d3_svg_chordRadius(d) {
        return d.radius
    }
    function d3_svg_diagonalProjection(d) {
        return[d.x, d.y]
    }
    function d3_svg_diagonalRadialProjection(projection) {
        return function () {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - half\u03c0;
            return[r * Math.cos(a), r * Math.sin(a)]
        }
    }
    function d3_svg_symbolSize() {
        return 64
    }
    function d3_svg_symbolType() {
        return"circle"
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / \u03c0);
        return"M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z"
    }
    function d3_selection_interruptNS(ns) {
        return function () {
            var lock, active;
            (lock = this[ns]) && (active = lock[lock.active]) && (--lock.count ? delete lock[lock.active] : delete this[ns], lock.active += .5, active.event && active.event.interrupt.call(this, this.__data__, active.index))
        }
    }
    function d3_transition(groups, ns, id) {
        return d3_subclass(groups, d3_transitionPrototype), groups.namespace = ns, groups.id = id, groups
    }
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id, ns = groups.namespace;
        return d3_selection_each(groups, "function" == typeof value ? function (node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)))
        } : (value = tween(value), function (node) {
            node[ns][id].tween.set(name, value)
        }))
    }
    function d3_transition_text(b) {
        return null == b && (b = ""), function () {
            this.textContent = b
        }
    }
    function d3_transitionNamespace(name) {
        return null == name ? "__transition__" : "__transition_" + name + "__"
    }
    function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {active: 0, count: 0}), transition = lock[id];
        if (!transition) {
            var time = inherit.time;
            transition = lock[id] = {tween: new d3_Map, time: time, delay: inherit.delay, duration: inherit.duration, ease: inherit.ease, index: i}, inherit = null, ++lock.count, d3.timer(function (elapsed) {
                function start(elapsed) {
                    if (lock.active > id)
                        return stop();
                    var active = lock[lock.active];
                    active && (--lock.count, delete lock[lock.active], active.event && active.event.interrupt.call(node, node.__data__, active.index)), lock.active = id, transition.event && transition.event.start.call(node, node.__data__, i), transition.tween.forEach(function (key, value) {
                        (value = value.call(node, node.__data__, i)) && tweened.push(value)
                    }), ease = transition.ease, duration = transition.duration, d3.timer(function () {
                        return timer.c = tick(elapsed || 1) ? d3_true : tick, 1
                    }, 0, time)
                }
                function tick(elapsed) {
                    if (lock.active !== id)
                        return 1;
                    for (var t = elapsed / duration, e = ease(t), n = tweened.length; n > 0; )
                        tweened[--n].call(node, e);
                    return t >= 1 ? (transition.event && transition.event.end.call(node, node.__data__, i), stop()) : void 0
                }
                function stop() {
                    return--lock.count ? delete lock[id] : delete node[ns], 1
                }
                var duration, ease, delay = transition.delay, timer = d3_timer_active, tweened = [];
                return timer.t = delay + time, elapsed >= delay ? start(elapsed - delay) : void(timer.c = start)
            }, 0, time)
        }
    }
    function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function (d) {
            var v0 = x0(d);
            return"translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)"
        })
    }
    function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function (d) {
            var v0 = y0(d);
            return"translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")"
        })
    }
    function d3_time_formatIsoNative(date) {
        return date.toISOString()
    }
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x)
        }
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function (d) {
                    return d / 31536e6
                }), count)[2]] : i ? methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i] : [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]]
        }
        return scale.invert = function (x) {
            return d3_time_scaleDate(linear.invert(x))
        }, scale.domain = function (x) {
            return arguments.length ? (linear.domain(x), scale) : linear.domain().map(d3_time_scaleDate)
        }, scale.nice = function (interval, skip) {
            function skipped(date) {
                return!isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length
            }
            var domain = scale.domain(), extent = d3_scaleExtent(domain), method = null == interval ? tickMethod(extent, 10) : "number" == typeof interval && tickMethod(extent, interval);
            return method && (interval = method[0], skip = method[1]), scale.domain(d3_scale_nice(domain, skip > 1 ? {floor: function (date) {
                    for (; skipped(date = interval.floor(date)); )
                        date = d3_time_scaleDate(date - 1);
                    return date
                }, ceil: function (date) {
                    for (; skipped(date = interval.ceil(date)); )
                        date = d3_time_scaleDate(+date + 1);
                    return date
                }} : interval))
        }, scale.ticks = function (interval, skip) {
            var extent = d3_scaleExtent(scale.domain()), method = null == interval ? tickMethod(extent, 10) : "number" == typeof interval ? tickMethod(extent, interval) : !interval.range && [{range: interval}, skip];
            return method && (interval = method[0], skip = method[1]), interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), 1 > skip ? 1 : skip)
        }, scale.tickFormat = function () {
            return format
        }, scale.copy = function () {
            return d3_time_scale(linear.copy(), methods, format)
        }, d3_scale_linearRebind(scale, linear)
    }
    function d3_time_scaleDate(t) {
        return new Date(t)
    }
    function d3_json(request) {
        return JSON.parse(request.responseText)
    }
    function d3_html(request) {
        var range = d3_document.createRange();
        return range.selectNode(d3_document.body), range.createContextualFragment(request.responseText)
    }
    var d3 = {version: "3.5.3"};
    Date.now || (Date.now = function () {
        return+new Date
    });
    var d3_arraySlice = [].slice, d3_array = function (list) {
        return d3_arraySlice.call(list)
    }, d3_document = document, d3_documentElement = d3_document.documentElement, d3_window = window;
    try {
        d3_array(d3_documentElement.childNodes)[0].nodeType
    } catch (e) {
        d3_array = function (list) {
            for (var i = list.length, array = new Array(i); i--; )
                array[i] = list[i];
            return array
        }
    }
    try {
        d3_document.createElement("div").style.setProperty("opacity", 0, "")
    } catch (error) {
        var d3_element_prototype = d3_window.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
        d3_element_prototype.setAttribute = function (name, value) {
            d3_element_setAttribute.call(this, name, value + "")
        }, d3_element_prototype.setAttributeNS = function (space, local, value) {
            d3_element_setAttributeNS.call(this, space, local, value + "")
        }, d3_style_prototype.setProperty = function (name, value, priority) {
            d3_style_setProperty.call(this, name, value + "", priority)
        }
    }
    d3.ascending = d3_ascending, d3.descending = function (a, b) {
        return a > b ? -1 : b > a ? 1 : b >= a ? 0 : NaN
    }, d3.min = function (array, f) {
        var a, b, i = -1, n = array.length;
        if (1 === arguments.length) {
            for (; ++i < n; )
                if (null != (b = array[i]) && b >= b) {
                    a = b;
                    break
                }
            for (; ++i < n; )
                null != (b = array[i]) && a > b && (a = b)
        } else {
            for (; ++i < n; )
                if (null != (b = f.call(array, array[i], i)) && b >= b) {
                    a = b;
                    break
                }
            for (; ++i < n; )
                null != (b = f.call(array, array[i], i)) && a > b && (a = b)
        }
        return a
    }, d3.max = function (array, f) {
        var a, b, i = -1, n = array.length;
        if (1 === arguments.length) {
            for (; ++i < n; )
                if (null != (b = array[i]) && b >= b) {
                    a = b;
                    break
                }
            for (; ++i < n; )
                null != (b = array[i]) && b > a && (a = b)
        } else {
            for (; ++i < n; )
                if (null != (b = f.call(array, array[i], i)) && b >= b) {
                    a = b;
                    break
                }
            for (; ++i < n; )
                null != (b = f.call(array, array[i], i)) && b > a && (a = b)
        }
        return a
    }, d3.extent = function (array, f) {
        var a, b, c, i = -1, n = array.length;
        if (1 === arguments.length) {
            for (; ++i < n; )
                if (null != (b = array[i]) && b >= b) {
                    a = c = b;
                    break
                }
            for (; ++i < n; )
                null != (b = array[i]) && (a > b && (a = b), b > c && (c = b))
        } else {
            for (; ++i < n; )
                if (null != (b = f.call(array, array[i], i)) && b >= b) {
                    a = c = b;
                    break
                }
            for (; ++i < n; )
                null != (b = f.call(array, array[i], i)) && (a > b && (a = b), b > c && (c = b))
        }
        return[a, c]
    }, d3.sum = function (array, f) {
        var a, s = 0, n = array.length, i = -1;
        if (1 === arguments.length)
            for (; ++i < n; )
                d3_numeric(a = +array[i]) && (s += a);
        else
            for (; ++i < n; )
                d3_numeric(a = +f.call(array, array[i], i)) && (s += a);
        return s
    }, d3.mean = function (array, f) {
        var a, s = 0, n = array.length, i = -1, j = n;
        if (1 === arguments.length)
            for (; ++i < n; )
                d3_numeric(a = d3_number(array[i])) ? s += a : --j;
        else
            for (; ++i < n; )
                d3_numeric(a = d3_number(f.call(array, array[i], i))) ? s += a : --j;
        return j ? s / j : void 0
    }, d3.quantile = function (values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v
    }, d3.median = function (array, f) {
        var a, numbers = [], n = array.length, i = -1;
        if (1 === arguments.length)
            for (; ++i < n; )
                d3_numeric(a = d3_number(array[i])) && numbers.push(a);
        else
            for (; ++i < n; )
                d3_numeric(a = d3_number(f.call(array, array[i], i))) && numbers.push(a);
        return numbers.length ? d3.quantile(numbers.sort(d3_ascending), .5) : void 0
    }, d3.variance = function (array, f) {
        var a, d, n = array.length, m = 0, s = 0, i = -1, j = 0;
        if (1 === arguments.length)
            for (; ++i < n; )
                d3_numeric(a = d3_number(array[i])) && (d = a - m, m += d / ++j, s += d * (a - m));
        else
            for (; ++i < n; )
                d3_numeric(a = d3_number(f.call(array, array[i], i))) && (d = a - m, m += d / ++j, s += d * (a - m));
        return j > 1 ? s / (j - 1) : void 0
    }, d3.deviation = function () {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v
    };
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left, d3.bisect = d3.bisectRight = d3_bisect.right, d3.bisector = function (f) {
        return d3_bisector(1 === f.length ? function (d, x) {
            return d3_ascending(f(d), x)
        } : f)
    }, d3.shuffle = function (array, i0, i1) {
        (m = arguments.length) < 3 && (i1 = array.length, 2 > m && (i0 = 0));
        for (var t, i, m = i1 - i0; m; )
            i = Math.random() * m-- | 0, t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        return array
    }, d3.permute = function (array, indexes) {
        for (var i = indexes.length, permutes = new Array(i); i--; )
            permutes[i] = array[indexes[i]];
        return permutes
    }, d3.pairs = function (array) {
        for (var p0, i = 0, n = array.length - 1, p1 = array[0], pairs = new Array(0 > n ? 0 : n); n > i; )
            pairs[i] = [p0 = p1, p1 = array[++i]];
        return pairs
    }, d3.zip = function () {
        if (!(n = arguments.length))
            return[];
        for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; )
            for (var n, j = -1, zip = zips[i] = new Array(n); ++j < n; )
                zip[j] = arguments[j][i];
        return zips
    }, d3.transpose = function (matrix) {
        return d3.zip.apply(d3, matrix)
    }, d3.keys = function (map) {
        var keys = [];
        for (var key in map)
            keys.push(key);
        return keys
    }, d3.values = function (map) {
        var values = [];
        for (var key in map)
            values.push(map[key]);
        return values
    }, d3.entries = function (map) {
        var entries = [];
        for (var key in map)
            entries.push({key: key, value: map[key]});
        return entries
    }, d3.merge = function (arrays) {
        for (var m, merged, array, n = arrays.length, i = -1, j = 0; ++i < n; )
            j += arrays[i].length;
        for (merged = new Array(j); --n >= 0; )
            for (array = arrays[n], m = array.length; --m >= 0; )
                merged[--j] = array[m];
        return merged
    };
    var abs = Math.abs;
    d3.range = function (start, stop, step) {
        if (arguments.length < 3 && (step = 1, arguments.length < 2 && (stop = start, start = 0)), (stop - start) / step === 1 / 0)
            throw new Error("infinite range");
        var j, range = [], k = d3_range_integerScale(abs(step)), i = -1;
        if (start *= k, stop *= k, step *= k, 0 > step)
            for (; (j = start + step * ++i) > stop; )
                range.push(j / k);
        else
            for (; (j = start + step * ++i) < stop; )
                range.push(j / k);
        return range
    }, d3.map = function (object, f) {
        var map = new d3_Map;
        if (object instanceof d3_Map)
            object.forEach(function (key, value) {
                map.set(key, value)
            });
        else if (Array.isArray(object)) {
            var o, i = -1, n = object.length;
            if (1 === arguments.length)
                for (; ++i < n; )
                    map.set(i, object[i]);
            else
                for (; ++i < n; )
                    map.set(f.call(object, o = object[i], i), o)
        } else
            for (var key in object)
                map.set(key, object[key]);
        return map
    };
    var d3_map_proto = "__proto__", d3_map_zero = "\x00";
    d3_class(d3_Map, {has: d3_map_has, get: function (key) {
            return this._[d3_map_escape(key)]
        }, set: function (key, value) {
            return this._[d3_map_escape(key)] = value
        }, remove: d3_map_remove, keys: d3_map_keys, values: function () {
            var values = [];
            for (var key in this._)
                values.push(this._[key]);
            return values
        }, entries: function () {
            var entries = [];
            for (var key in this._)
                entries.push({key: d3_map_unescape(key), value: this._[key]});
            return entries
        }, size: d3_map_size, empty: d3_map_empty, forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key), this._[key])
        }}), d3.nest = function () {
        function map(mapType, array, depth) {
            if (depth >= keys.length)
                return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            for (var keyValue, object, setter, values, i = -1, n = array.length, key = keys[depth++], valuesByKey = new d3_Map; ++i < n; )
                (values = valuesByKey.get(keyValue = key(object = array[i]))) ? values.push(object) : valuesByKey.set(keyValue, [object]);
            return mapType ? (object = mapType(), setter = function (keyValue, values) {
                object.set(keyValue, map(mapType, values, depth))
            }) : (object = {}, setter = function (keyValue, values) {
                object[keyValue] = map(mapType, values, depth)
            }), valuesByKey.forEach(setter), object
        }
        function entries(map, depth) {
            if (depth >= keys.length)
                return map;
            var array = [], sortKey = sortKeys[depth++];
            return map.forEach(function (key, keyMap) {
                array.push({key: key, values: entries(keyMap, depth)})
            }), sortKey ? array.sort(function (a, b) {
                return sortKey(a.key, b.key)
            }) : array
        }
        var sortValues, rollup, nest = {}, keys = [], sortKeys = [];
        return nest.map = function (array, mapType) {
            return map(mapType, array, 0)
        }, nest.entries = function (array) {
            return entries(map(d3.map, array, 0), 0)
        }, nest.key = function (d) {
            return keys.push(d), nest
        }, nest.sortKeys = function (order) {
            return sortKeys[keys.length - 1] = order, nest
        }, nest.sortValues = function (order) {
            return sortValues = order, nest
        }, nest.rollup = function (f) {
            return rollup = f, nest
        }, nest
    }, d3.set = function (array) {
        var set = new d3_Set;
        if (array)
            for (var i = 0, n = array.length; n > i; ++i)
                set.add(array[i]);
        return set
    }, d3_class(d3_Set, {has: d3_map_has, add: function (key) {
            return this._[d3_map_escape(key += "")] = !0, key
        }, remove: d3_map_remove, values: d3_map_keys, size: d3_map_size, empty: d3_map_empty, forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key))
        }}), d3.behavior = {}, d3.rebind = function (target, source) {
        for (var method, i = 1, n = arguments.length; ++i < n; )
            target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target
    };
    var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
    d3.dispatch = function () {
        for (var dispatch = new d3_dispatch, i = -1, n = arguments.length; ++i < n; )
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch
    }, d3_dispatch.prototype.on = function (type, listener) {
        var i = type.indexOf("."), name = "";
        if (i >= 0 && (name = type.slice(i + 1), type = type.slice(0, i)), type)
            return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (2 === arguments.length) {
            if (null == listener)
                for (type in this)
                    this.hasOwnProperty(type) && this[type].on(name, null);
            return this
        }
    }, d3.event = null, d3.requote = function (s) {
        return s.replace(d3_requote_re, "\\$&")
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g, d3_subclass = {}.__proto__ ? function (object, prototype) {
        object.__proto__ = prototype
    } : function (object, prototype) {
        for (var property in prototype)
            object[property] = prototype[property]
    }, d3_select = function (s, n) {
        return n.querySelector(s)
    }, d3_selectAll = function (s, n) {
        return n.querySelectorAll(s)
    }, d3_selectMatcher = d3_documentElement.matches || d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")], d3_selectMatches = function (n, s) {
        return d3_selectMatcher.call(n, s)
    };
    "function" == typeof Sizzle && (d3_select = function (s, n) {
        return Sizzle(s, n)[0] || null
    }, d3_selectAll = Sizzle, d3_selectMatches = Sizzle.matchesSelector), d3.selection = function () {
        return d3_selectionRoot
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function (selector) {
        var subgroup, subnode, group, node, subgroups = [];
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []), subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n; )
                (node = group[i]) ? (subgroup.push(subnode = selector.call(node, node.__data__, i, j)), subnode && "__data__"in node && (subnode.__data__ = node.__data__)) : subgroup.push(null)
        }
        return d3_selection(subgroups)
    }, d3_selectionPrototype.selectAll = function (selector) {
        var subgroup, node, subgroups = [];
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; )
            for (var group = this[j], i = -1, n = group.length; ++i < n; )
                (node = group[i]) && (subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j))), subgroup.parentNode = node);
        return d3_selection(subgroups)
    };
    var d3_nsPrefix = {svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/"};
    d3.ns = {prefix: d3_nsPrefix, qualify: function (name) {
            var i = name.indexOf(":"), prefix = name;
            return i >= 0 && (prefix = name.slice(0, i), name = name.slice(i + 1)), d3_nsPrefix.hasOwnProperty(prefix) ? {space: d3_nsPrefix[prefix], local: name} : name
        }}, d3_selectionPrototype.attr = function (name, value) {
        if (arguments.length < 2) {
            if ("string" == typeof name) {
                var node = this.node();
                return name = d3.ns.qualify(name), name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name)
            }
            for (value in name)
                this.each(d3_selection_attr(value, name[value]));
            return this
        }
        return this.each(d3_selection_attr(name, value))
    }, d3_selectionPrototype.classed = function (name, value) {
        if (arguments.length < 2) {
            if ("string" == typeof name) {
                var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                if (value = node.classList) {
                    for (; ++i < n; )
                        if (!value.contains(name[i]))
                            return!1
                } else
                    for (value = node.getAttribute("class"); ++i < n; )
                        if (!d3_selection_classedRe(name[i]).test(value))
                            return!1;
                return!0
            }
            for (value in name)
                this.each(d3_selection_classed(value, name[value]));
            return this
        }
        return this.each(d3_selection_classed(name, value))
    }, d3_selectionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (3 > n) {
            if ("string" != typeof name) {
                2 > n && (value = "");
                for (priority in name)
                    this.each(d3_selection_style(priority, name[priority], value));
                return this
            }
            if (2 > n)
                return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
            priority = ""
        }
        return this.each(d3_selection_style(name, value, priority))
    }, d3_selectionPrototype.property = function (name, value) {
        if (arguments.length < 2) {
            if ("string" == typeof name)
                return this.node()[name];
            for (value in name)
                this.each(d3_selection_property(value, name[value]));
            return this
        }
        return this.each(d3_selection_property(name, value))
    }, d3_selectionPrototype.text = function (value) {
        return arguments.length ? this.each("function" == typeof value ? function () {
            var v = value.apply(this, arguments);
            this.textContent = null == v ? "" : v
        } : null == value ? function () {
            this.textContent = ""
        } : function () {
            this.textContent = value
        }) : this.node().textContent
    }, d3_selectionPrototype.html = function (value) {
        return arguments.length ? this.each("function" == typeof value ? function () {
            var v = value.apply(this, arguments);
            this.innerHTML = null == v ? "" : v
        } : null == value ? function () {
            this.innerHTML = ""
        } : function () {
            this.innerHTML = value
        }) : this.node().innerHTML
    }, d3_selectionPrototype.append = function (name) {
        return name = d3_selection_creator(name), this.select(function () {
            return this.appendChild(name.apply(this, arguments))
        })
    }, d3_selectionPrototype.insert = function (name, before) {
        return name = d3_selection_creator(name), before = d3_selection_selector(before), this.select(function () {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null)
        })
    }, d3_selectionPrototype.remove = function () {
        return this.each(d3_selectionRemove)
    }, d3_selectionPrototype.data = function (value, key) {
        function bind(group, groupData) {
            var i, node, nodeData, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n);
            if (key) {
                var keyValue, nodeByKeyValue = new d3_Map, keyValues = new Array(n);
                for (i = - 1; ++i < n; )
                    nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i)) ? exitNodes[i] = node : nodeByKeyValue.set(keyValue, node), keyValues[i] = keyValue;
                for (i = - 1; ++i < m; )
                    (node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i))) ? node !== !0 && (updateNodes[i] = node, node.__data__ = nodeData) : enterNodes[i] = d3_selection_dataNode(nodeData), nodeByKeyValue.set(keyValue, !0);
                for (i = - 1; ++i < n; )
                    nodeByKeyValue.get(keyValues[i]) !== !0 && (exitNodes[i] = group[i])
            } else {
                for (i = - 1; ++i < n0; )
                    node = group[i], nodeData = groupData[i], node ? (node.__data__ = nodeData, updateNodes[i] = node) : enterNodes[i] = d3_selection_dataNode(nodeData);
                for (; m > i; ++i)
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                for (; n > i; ++i)
                    exitNodes[i] = group[i]
            }
            enterNodes.update = updateNodes, enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode, enter.push(enterNodes), update.push(updateNodes), exit.push(exitNodes)
        }
        var group, node, i = -1, n = this.length;
        if (!arguments.length) {
            for (value = new Array(n = (group = this[0]).length); ++i < n; )
                (node = group[i]) && (value[i] = node.__data__);
            return value
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if ("function" == typeof value)
            for (; ++i < n; )
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
        else
            for (; ++i < n; )
                bind(group = this[i], value);
        return update.enter = function () {
            return enter
        }, update.exit = function () {
            return exit
        }, update
    }, d3_selectionPrototype.datum = function (value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__")
    }, d3_selectionPrototype.filter = function (filter) {
        var subgroup, group, node, subgroups = [];
        "function" != typeof filter && (filter = d3_selection_filter(filter));
        for (var j = 0, m = this.length; m > j; j++) {
            subgroups.push(subgroup = []), subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; n > i; i++)
                (node = group[i]) && filter.call(node, node.__data__, i, j) && subgroup.push(node)
        }
        return d3_selection(subgroups)
    }, d3_selectionPrototype.order = function () {
        for (var j = -1, m = this.length; ++j < m; )
            for (var node, group = this[j], i = group.length - 1, next = group[i]; --i >= 0; )
                (node = group[i]) && (next && next !== node.nextSibling && next.parentNode.insertBefore(node, next), next = node);
        return this
    }, d3_selectionPrototype.sort = function (comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m; )
            this[j].sort(comparator);
        return this.order()
    }, d3_selectionPrototype.each = function (callback) {
        return d3_selection_each(this, function (node, i, j) {
            callback.call(node, node.__data__, i, j)
        })
    }, d3_selectionPrototype.call = function (callback) {
        var args = d3_array(arguments);
        return callback.apply(args[0] = this, args), this
    }, d3_selectionPrototype.empty = function () {
        return!this.node()
    }, d3_selectionPrototype.node = function () {
        for (var j = 0, m = this.length; m > j; j++)
            for (var group = this[j], i = 0, n = group.length; n > i; i++) {
                var node = group[i];
                if (node)
                    return node
            }
        return null
    }, d3_selectionPrototype.size = function () {
        var n = 0;
        return d3_selection_each(this, function () {
            ++n
        }), n
    };
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter, d3.selection.enter.prototype = d3_selection_enterPrototype, d3_selection_enterPrototype.append = d3_selectionPrototype.append, d3_selection_enterPrototype.empty = d3_selectionPrototype.empty, d3_selection_enterPrototype.node = d3_selectionPrototype.node, d3_selection_enterPrototype.call = d3_selectionPrototype.call, d3_selection_enterPrototype.size = d3_selectionPrototype.size, d3_selection_enterPrototype.select = function (selector) {
        for (var subgroup, subnode, upgroup, group, node, subgroups = [], j = -1, m = this.length; ++j < m; ) {
            upgroup = (group = this[j]).update, subgroups.push(subgroup = []), subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n; )
                (node = group[i]) ? (subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j)), subnode.__data__ = node.__data__) : subgroup.push(null)
        }
        return d3_selection(subgroups)
    }, d3_selection_enterPrototype.insert = function (name, before) {
        return arguments.length < 2 && (before = d3_selection_enterInsertBefore(this)), d3_selectionPrototype.insert.call(this, name, before)
    }, d3.select = function (node) {
        var group = ["string" == typeof node ? d3_select(node, d3_document) : node];
        return group.parentNode = d3_documentElement, d3_selection([group])
    }, d3.selectAll = function (nodes) {
        var group = d3_array("string" == typeof nodes ? d3_selectAll(nodes, d3_document) : nodes);
        return group.parentNode = d3_documentElement, d3_selection([group])
    };
    var d3_selectionRoot = d3.select(d3_documentElement);
    d3_selectionPrototype.on = function (type, listener, capture) {
        var n = arguments.length;
        if (3 > n) {
            if ("string" != typeof type) {
                2 > n && (listener = !1);
                for (capture in type)
                    this.each(d3_selection_on(capture, type[capture], listener));
                return this
            }
            if (2 > n)
                return(n = this.node()["__on" + type]) && n._;
            capture = !1
        }
        return this.each(d3_selection_on(type, listener, capture))
    };
    var d3_selection_onFilters = d3.map({mouseenter: "mouseover", mouseleave: "mouseout"});
    d3_selection_onFilters.forEach(function (k) {
        "on" + k in d3_document && d3_selection_onFilters.remove(k)
    });
    var d3_event_dragSelect = "onselectstart"in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, "userSelect"), d3_event_dragId = 0;
    d3.mouse = function (container) {
        return d3_mousePoint(container, d3_eventSource())
    };
    var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
    d3.touch = function (container, touches, identifier) {
        if (arguments.length < 3 && (identifier = touches, touches = d3_eventSource().changedTouches), touches)
            for (var touch, i = 0, n = touches.length; n > i; ++i)
                if ((touch = touches[i]).identifier === identifier)
                    return d3_mousePoint(container, touch)
    }, d3.behavior.drag = function () {
        function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart)
        }
        function dragstart(id, position, subject, move, end) {
            return function () {
                function moved() {
                    var dx, dy, position1 = position(parent, dragId);
                    position1 && (dx = position1[0] - position0[0], dy = position1[1] - position0[1], dragged |= dx | dy, position0 = position1, dispatch({type: "drag", x: position1[0] + dragOffset[0], y: position1[1] + dragOffset[1], dx: dx, dy: dy}))
                }
                function ended() {
                    position(parent, dragId) && (dragSubject.on(move + dragName, null).on(end + dragName, null), dragRestore(dragged && d3.event.target === target), dispatch({type: "dragend"}))
                }
                var dragOffset, that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (null == dragId ? "" : "-" + dragId), dragSubject = d3.select(subject()).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(), position0 = position(parent, dragId);
                origin ? (dragOffset = origin.apply(that, arguments), dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]]) : dragOffset = [0, 0], dispatch({type: "dragstart"})
            }
        }
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_behavior_dragMouseSubject, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_behavior_dragTouchSubject, "touchmove", "touchend");
        return drag.origin = function (x) {
            return arguments.length ? (origin = x, drag) : origin
        }, d3.rebind(drag, event, "on")
    }, d3.touches = function (container, touches) {
        return arguments.length < 2 && (touches = d3_eventSource().touches), touches ? d3_array(touches).map(function (touch) {
            var point = d3_mousePoint(container, touch);
            return point.identifier = touch.identifier, point
        }) : []
    };
    var \u03b5 = 1e-6, \u03b52 = \u03b5 * \u03b5, \u03c0 = Math.PI, \u03c4 = 2 * \u03c0, \u03c4\u03b5 = \u03c4 - \u03b5, half\u03c0 = \u03c0 / 2, d3_radians = \u03c0 / 180, d3_degrees = 180 / \u03c0, \u03c1 = Math.SQRT2, \u03c12 = 2, \u03c14 = 4;
    d3.interpolateZoom = function (p0, p1) {
        function interpolate(t) {
            var s = t * S;
            if (dr) {
                var coshr0 = d3_cosh(r0), u = w0 / (\u03c12 * d1) * (coshr0 * d3_tanh(\u03c1 * s + r0) - d3_sinh(r0));
                return[ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(\u03c1 * s + r0)]
            }
            return[ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(\u03c1 * s)]
        }
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + \u03c14 * d2) / (2 * w0 * \u03c12 * d1), b1 = (w1 * w1 - w0 * w0 - \u03c14 * d2) / (2 * w1 * \u03c12 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / \u03c1;
        return interpolate.duration = 1e3 * S, interpolate
    }, d3.behavior.zoom = function () {
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted)
        }
        function location(p) {
            return[(p[0] - view.x) / view.k, (p[1] - view.y) / view.k]
        }
        function point(l) {
            return[l[0] * view.k + view.x, l[1] * view.k + view.y]
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s))
        }
        function translateTo(p, l) {
            l = point(l), view.x += p[0] - l[0], view.y += p[1] - l[1]
        }
        function zoomTo(that, p, l, k) {
            that.__chart__ = {x: view.x, y: view.y, k: view.k}, scaleTo(Math.pow(2, k)), translateTo(center0 = p, l), that = d3.select(that), duration > 0 && (that = that.transition().duration(duration)), that.call(zoom.event)
        }
        function rescale() {
            x1 && x1.domain(x0.range().map(function (x) {
                return(x - view.x) / view.k
            }).map(x0.invert)), y1 && y1.domain(y0.range().map(function (y) {
                return(y - view.y) / view.k
            }).map(y0.invert))
        }
        function zoomstarted(dispatch) {
            zooming++ || dispatch({type: "zoomstart"})
        }
        function zoomed(dispatch) {
            rescale(), dispatch({type: "zoom", scale: view.k, translate: [view.x, view.y]})
        }
        function zoomended(dispatch) {
            --zooming || dispatch({type: "zoomend"}), center0 = null
        }
        function mousedowned() {
            function moved() {
                dragged = 1, translateTo(d3.mouse(that), location0), zoomed(dispatch)
            }
            function ended() {
                subject.on(mousemove, null).on(mouseup, null), dragRestore(dragged && d3.event.target === target), zoomended(dispatch)
            }
            var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress();
            d3_selection_interrupt.call(that), zoomstarted(dispatch)
        }
        function touchstarted() {
            function relocate() {
                var touches = d3.touches(that);
                return scale0 = view.k, touches.forEach(function (t) {
                    t.identifier in locations0 && (locations0[t.identifier] = location(t))
                }), touches
            }
            function started() {
                var target = d3.event.target;
                d3.select(target).on(touchmove, moved).on(touchend, ended), targets.push(target);
                for (var changed = d3.event.changedTouches, i = 0, n = changed.length; n > i; ++i)
                    locations0[changed[i].identifier] = null;
                var touches = relocate(), now = Date.now();
                if (1 === touches.length) {
                    if (500 > now - touchtime) {
                        var p = touches[0];
                        zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1), d3_eventPreventDefault()
                    }
                    touchtime = now
                } else if (touches.length > 1) {
                    var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy
                }
            }
            function moved() {
                var p0, l0, p1, l1, touches = d3.touches(that);
                d3_selection_interrupt.call(that);
                for (var i = 0, n = touches.length; n > i; ++i, l1 = null)
                    if (p1 = touches[i], l1 = locations0[p1.identifier]) {
                        if (l0)
                            break;
                        p0 = p1, l0 = l1
                    }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2], l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2], scaleTo(scale1 * scale0)
                }
                touchtime = null, translateTo(p0, l0), zoomed(dispatch)
            }
            function ended() {
                if (d3.event.touches.length) {
                    for (var changed = d3.event.changedTouches, i = 0, n = changed.length; n > i; ++i)
                        delete locations0[changed[i].identifier];
                    for (var identifier in locations0)
                        return void relocate()
                }
                d3.selectAll(targets).on(zoomName, null), subject.on(mousedown, mousedowned).on(touchstart, touchstarted), dragRestore(), zoomended(dispatch)
            }
            var scale0, that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress();
            started(), zoomstarted(dispatch), subject.on(mousedown, null).on(touchstart, started)
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            mousewheelTimer ? clearTimeout(mousewheelTimer) : (translate0 = location(center0 = center || d3.mouse(this)), d3_selection_interrupt.call(this), zoomstarted(dispatch)), mousewheelTimer = setTimeout(function () {
                mousewheelTimer = null, zoomended(dispatch)
            }, 50), d3_eventPreventDefault(), scaleTo(Math.pow(2, .002 * d3_behavior_zoomDelta()) * view.k), translateTo(center0, translate0), zoomed(dispatch)
        }
        function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1)
        }
        var translate0, center0, center, mousewheelTimer, touchtime, x0, x1, y0, y1, view = {x: 0, y: 0, k: 1}, size = [960, 500], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", touchstart = "touchstart.zoom", event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend");
        return zoom.event = function (g) {
            g.each(function () {
                var dispatch = event.of(this, arguments), view1 = view;
                d3_transitionInheritId ? d3.select(this).transition().each("start.zoom", function () {
                    view = this.__chart__ || {x: 0, y: 0, k: 1}, zoomstarted(dispatch)
                }).tween("zoom:zoom", function () {
                    var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                    return function (t) {
                        var l = i(t), k = dx / l[2];
                        this.__chart__ = view = {x: cx - l[0] * k, y: cy - l[1] * k, k: k}, zoomed(dispatch)
                    }
                }).each("interrupt.zoom", function () {
                    zoomended(dispatch)
                }).each("end.zoom", function () {
                    zoomended(dispatch)
                }) : (this.__chart__ = view, zoomstarted(dispatch), zoomed(dispatch), zoomended(dispatch))
            })
        }, zoom.translate = function (_) {
            return arguments.length ? (view = {x: +_[0], y: +_[1], k: view.k}, rescale(), zoom) : [view.x, view.y]
        }, zoom.scale = function (_) {
            return arguments.length ? (view = {x: view.x, y: view.y, k: +_}, rescale(), zoom) : view.k
        }, zoom.scaleExtent = function (_) {
            return arguments.length ? (scaleExtent = null == _ ? d3_behavior_zoomInfinity : [+_[0], +_[1]], zoom) : scaleExtent
        }, zoom.center = function (_) {
            return arguments.length ? (center = _ && [+_[0], +_[1]], zoom) : center
        }, zoom.size = function (_) {
            return arguments.length ? (size = _ && [+_[0], +_[1]], zoom) : size
        }, zoom.duration = function (_) {
            return arguments.length ? (duration = +_, zoom) : duration
        }, zoom.x = function (z) {
            return arguments.length ? (x1 = z, x0 = z.copy(), view = {x: 0, y: 0, k: 1}, zoom) : x1
        }, zoom.y = function (z) {
            return arguments.length ? (y1 = z, y0 = z.copy(), view = {x: 0, y: 0, k: 1}, zoom) : y1
        }, d3.rebind(zoom, event, "on")
    };
    var d3_behavior_zoomDelta, d3_behavior_zoomInfinity = [0, 1 / 0], d3_behavior_zoomWheel = "onwheel"in d3_document ? (d3_behavior_zoomDelta = function () {
        return-d3.event.deltaY * (d3.event.deltaMode ? 120 : 1)
    }, "wheel") : "onmousewheel"in d3_document ? (d3_behavior_zoomDelta = function () {
        return d3.event.wheelDelta
    }, "mousewheel") : (d3_behavior_zoomDelta = function () {
        return-d3.event.detail
    }, "MozMousePixelScroll");
    d3.color = d3_color, d3_color.prototype.toString = function () {
        return this.rgb() + ""
    }, d3.hsl = d3_hsl;
    var d3_hslPrototype = d3_hsl.prototype = new d3_color;
    d3_hslPrototype.brighter = function (k) {
        return k = Math.pow(.7, arguments.length ? k : 1), new d3_hsl(this.h, this.s, this.l / k)
    }, d3_hslPrototype.darker = function (k) {
        return k = Math.pow(.7, arguments.length ? k : 1), new d3_hsl(this.h, this.s, k * this.l)
    }, d3_hslPrototype.rgb = function () {
        return d3_hsl_rgb(this.h, this.s, this.l)
    }, d3.hcl = d3_hcl;
    var d3_hclPrototype = d3_hcl.prototype = new d3_color;
    d3_hclPrototype.brighter = function (k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)))
    }, d3_hclPrototype.darker = function (k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)))
    }, d3_hclPrototype.rgb = function () {
        return d3_hcl_lab(this.h, this.c, this.l).rgb()
    }, d3.lab = d3_lab;
    var d3_lab_K = 18, d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883, d3_labPrototype = d3_lab.prototype = new d3_color;
    d3_labPrototype.brighter = function (k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b)
    }, d3_labPrototype.darker = function (k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b)
    }, d3_labPrototype.rgb = function () {
        return d3_lab_rgb(this.l, this.a, this.b)
    }, d3.rgb = d3_rgb;
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color;
    d3_rgbPrototype.brighter = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        return r || g || b ? (r && i > r && (r = i), g && i > g && (g = i), b && i > b && (b = i), new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k))) : new d3_rgb(i, i, i)
    }, d3_rgbPrototype.darker = function (k) {
        return k = Math.pow(.7, arguments.length ? k : 1), new d3_rgb(k * this.r, k * this.g, k * this.b)
    }, d3_rgbPrototype.hsl = function () {
        return d3_rgb_hsl(this.r, this.g, this.b)
    }, d3_rgbPrototype.toString = function () {
        return"#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b)
    };
    var d3_rgb_names = d3.map({aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074});
    d3_rgb_names.forEach(function (key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value))
    }), d3.functor = d3_functor, d3.xhr = d3_xhrType(d3_identity), d3.dsv = function (delimiter, mimeType) {
        function dsv(url, row, callback) {
            arguments.length < 3 && (callback = row, row = null);
            var xhr = d3_xhr(url, mimeType, null == row ? response : typedResponse(row), callback);
            return xhr.row = function (_) {
                return arguments.length ? xhr.response(null == (row = _) ? response : typedResponse(_)) : row
            }, xhr
        }
        function response(request) {
            return dsv.parse(request.responseText)
        }
        function typedResponse(f) {
            return function (request) {
                return dsv.parse(request.responseText, f)
            }
        }
        function formatRow(row) {
            return row.map(formatValue).join(delimiter)
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text
        }
        var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
        return dsv.parse = function (text, f) {
            var o;
            return dsv.parseRows(text, function (row, i) {
                if (o)
                    return o(row, i - 1);
                var a = new Function("d", "return {" + row.map(function (name, i) {
                    return JSON.stringify(name) + ": d[" + i + "]"
                }).join(",") + "}");
                o = f ? function (row, i) {
                    return f(a(row), i)
                } : a
            })
        }, dsv.parseRows = function (text, f) {
            function token() {
                if (I >= N)
                    return EOF;
                if (eol)
                    return eol = !1, EOL;
                var j = I;
                if (34 === text.charCodeAt(j)) {
                    for (var i = j; i++ < N; )
                        if (34 === text.charCodeAt(i)) {
                            if (34 !== text.charCodeAt(i + 1))
                                break;
                            ++i
                        }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    return 13 === c ? (eol = !0, 10 === text.charCodeAt(i + 2) && ++I) : 10 === c && (eol = !0), text.slice(j + 1, i).replace(/""/g, '"')
                }
                for (; N > I; ) {
                    var c = text.charCodeAt(I++), k = 1;
                    if (10 === c)
                        eol = !0;
                    else if (13 === c)
                        eol = !0, 10 === text.charCodeAt(I) && (++I, ++k);
                    else if (c !== delimiterCode)
                        continue;
                    return text.slice(j, I - k)
                }
                return text.slice(j)
            }
            for (var t, eol, EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0; (t = token()) !== EOF; ) {
                for (var a = []; t !== EOL && t !== EOF; )
                    a.push(t), t = token();
                f && null == (a = f(a, n++)) || rows.push(a)
            }
            return rows
        }, dsv.format = function (rows) {
            if (Array.isArray(rows[0]))
                return dsv.formatRows(rows);
            var fieldSet = new d3_Set, fields = [];
            return rows.forEach(function (row) {
                for (var field in row)
                    fieldSet.has(field) || fields.push(fieldSet.add(field))
            }), [fields.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
                return fields.map(function (field) {
                    return formatValue(row[field])
                }).join(delimiter)
            })).join("\n")
        }, dsv.formatRows = function (rows) {
            return rows.map(formatRow).join("\n")
        }, dsv
    }, d3.csv = d3.dsv(",", "text/csv"), d3.tsv = d3.dsv("	", "text/tab-separated-values");
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] || function (callback) {
        setTimeout(callback, 17)
    };
    d3.timer = function (callback, delay, then) {
        var n = arguments.length;
        2 > n && (delay = 0), 3 > n && (then = Date.now());
        var time = then + delay, timer = {c: callback, t: time, f: !1, n: null};
        d3_timer_queueTail ? d3_timer_queueTail.n = timer : d3_timer_queueHead = timer, d3_timer_queueTail = timer, d3_timer_interval || (d3_timer_timeout = clearTimeout(d3_timer_timeout), d3_timer_interval = 1, d3_timer_frame(d3_timer_step))
    }, d3.timer.flush = function () {
        d3_timer_mark(), d3_timer_sweep()
    }, d3.round = function (x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x)
    };
    var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "\xb5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
    d3.formatPrefix = function (value, precision) {
        var i = 0;
        return value && (0 > value && (value *= -1), precision && (value = d3.round(value, d3_format_precision(value, precision))), i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10), i = Math.max(-24, Math.min(24, 3 * Math.floor((i - 1) / 3)))), d3_formatPrefixes[8 + i / 3]
    };
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i, d3_format_types = d3.map({b: function (x) {
            return x.toString(2)
        }, c: function (x) {
            return String.fromCharCode(x)
        }, o: function (x) {
            return x.toString(8)
        }, x: function (x) {
            return x.toString(16)
        }, X: function (x) {
            return x.toString(16).toUpperCase()
        }, g: function (x, p) {
            return x.toPrecision(p)
        }, e: function (x, p) {
            return x.toExponential(p)
        }, f: function (x, p) {
            return x.toFixed(p)
        }, r: function (x, p) {
            return(x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))))
        }}), d3_time = d3.time = {}, d3_date = Date;
    d3_date_utc.prototype = {getDate: function () {
            return this._.getUTCDate()
        }, getDay: function () {
            return this._.getUTCDay()
        }, getFullYear: function () {
            return this._.getUTCFullYear()
        }, getHours: function () {
            return this._.getUTCHours()
        }, getMilliseconds: function () {
            return this._.getUTCMilliseconds()
        }, getMinutes: function () {
            return this._.getUTCMinutes()
        }, getMonth: function () {
            return this._.getUTCMonth()
        }, getSeconds: function () {
            return this._.getUTCSeconds()
        }, getTime: function () {
            return this._.getTime()
        }, getTimezoneOffset: function () {
            return 0
        }, valueOf: function () {
            return this._.valueOf()
        }, setDate: function () {
            d3_time_prototype.setUTCDate.apply(this._, arguments)
        }, setDay: function () {
            d3_time_prototype.setUTCDay.apply(this._, arguments)
        }, setFullYear: function () {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments)
        }, setHours: function () {
            d3_time_prototype.setUTCHours.apply(this._, arguments)
        }, setMilliseconds: function () {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments)
        }, setMinutes: function () {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments)
        }, setMonth: function () {
            d3_time_prototype.setUTCMonth.apply(this._, arguments)
        }, setSeconds: function () {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments)
        }, setTime: function () {
            d3_time_prototype.setTime.apply(this._, arguments)
        }};
    var d3_time_prototype = Date.prototype;
    d3_time.year = d3_time_interval(function (date) {
        return date = d3_time.day(date), date.setMonth(0, 1), date
    }, function (date, offset) {
        date.setFullYear(date.getFullYear() + offset)
    }, function (date) {
        return date.getFullYear()
    }), d3_time.years = d3_time.year.range, d3_time.years.utc = d3_time.year.utc.range, d3_time.day = d3_time_interval(function (date) {
        var day = new d3_date(2e3, 0);
        return day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()), day
    }, function (date, offset) {
        date.setDate(date.getDate() + offset)
    }, function (date) {
        return date.getDate() - 1
    }), d3_time.days = d3_time.day.range, d3_time.days.utc = d3_time.day.utc.range, d3_time.dayOfYear = function (date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - 6e4 * (date.getTimezoneOffset() - year.getTimezoneOffset())) / 864e5)
    }, ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function (day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function (date) {
            return(date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7), date
        }, function (date, offset) {
            date.setDate(date.getDate() + 7 * Math.floor(offset))
        }, function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i)
        });
        d3_time[day + "s"] = interval.range, d3_time[day + "s"].utc = interval.utc.range, d3_time[day + "OfYear"] = function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7)
        }
    }), d3_time.week = d3_time.sunday, d3_time.weeks = d3_time.sunday.range, d3_time.weeks.utc = d3_time.sunday.utc.range, d3_time.weekOfYear = d3_time.sundayOfYear;
    var d3_time_formatPads = {"-": "", _: " ", 0: "0"}, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    d3.locale = function (locale) {
        return{numberFormat: d3_locale_numberFormat(locale), timeFormat: d3_locale_timeFormat(locale)}
    };
    var d3_locale_enUS = d3.locale({decimal: ".", thousands: ",", grouping: [3], currency: ["$", ""], dateTime: "%a %b %e %X %Y", date: "%m/%d/%Y", time: "%H:%M:%S", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]});
    d3.format = d3_locale_enUS.numberFormat, d3.geo = {}, d3_adder.prototype = {s: 0, t: 0, add: function (y) {
            d3_adderSum(y, this.t, d3_adderTemp), d3_adderSum(d3_adderTemp.s, this.s, this), this.s ? this.t += d3_adderTemp.t : this.s = d3_adderTemp.t
        }, reset: function () {
            this.s = this.t = 0
        }, valueOf: function () {
            return this.s
        }};
    var d3_adderTemp = new d3_adder;
    d3.geo.stream = function (object, listener) {
        object && d3_geo_streamObjectType.hasOwnProperty(object.type) ? d3_geo_streamObjectType[object.type](object, listener) : d3_geo_streamGeometry(object, listener)
    };
    var d3_geo_streamObjectType = {Feature: function (feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener)
        }, FeatureCollection: function (object, listener) {
            for (var features = object.features, i = -1, n = features.length; ++i < n; )
                d3_geo_streamGeometry(features[i].geometry, listener)
        }}, d3_geo_streamGeometryType = {Sphere: function (object, listener) {
            listener.sphere()
        }, Point: function (object, listener) {
            object = object.coordinates, listener.point(object[0], object[1], object[2])
        }, MultiPoint: function (object, listener) {
            for (var coordinates = object.coordinates, i = -1, n = coordinates.length; ++i < n; )
                object = coordinates[i], listener.point(object[0], object[1], object[2])
        }, LineString: function (object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0)
        }, MultiLineString: function (object, listener) {
            for (var coordinates = object.coordinates, i = -1, n = coordinates.length; ++i < n; )
                d3_geo_streamLine(coordinates[i], listener, 0)
        }, Polygon: function (object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener)
        }, MultiPolygon: function (object, listener) {
            for (var coordinates = object.coordinates, i = -1, n = coordinates.length; ++i < n; )
                d3_geo_streamPolygon(coordinates[i], listener)
        }, GeometryCollection: function (object, listener) {
            for (var geometries = object.geometries, i = -1, n = geometries.length; ++i < n; )
                d3_geo_streamGeometry(geometries[i], listener)
        }};
    d3.geo.area = function (object) {
        return d3_geo_areaSum = 0, d3.geo.stream(object, d3_geo_area), d3_geo_areaSum
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder, d3_geo_area = {sphere: function () {
            d3_geo_areaSum += 4 * \u03c0
        }, point: d3_noop, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: function () {
            d3_geo_areaRingSum.reset(), d3_geo_area.lineStart = d3_geo_areaRingStart
        }, polygonEnd: function () {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += 0 > area ? 4 * \u03c0 + area : area, d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop
        }};
    d3.geo.bounds = function () {
        function point(\u03bb, \u03c6) {
            ranges.push(range = [\u03bb0 = \u03bb, \u03bb1 = \u03bb]), \u03c60 > \u03c6 && (\u03c60 = \u03c6), \u03c6 > \u03c61 && (\u03c61 = \u03c6)
        }
        function linePoint(\u03bb, \u03c6) {
            var p = d3_geo_cartesian([\u03bb * d3_radians, \u03c6 * d3_radians]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection), inflection = d3_geo_spherical(inflection);
                var d\u03bb = \u03bb - \u03bb_, s = d\u03bb > 0 ? 1 : -1, \u03bbi = inflection[0] * d3_degrees * s, antimeridian = abs(d\u03bb) > 180;
                if (antimeridian ^ (\u03bbi > s * \u03bb_ && s * \u03bb > \u03bbi)) {
                    var \u03c6i = inflection[1] * d3_degrees;
                    \u03c6i > \u03c61 && (\u03c61 = \u03c6i)
                } else if (\u03bbi = (\u03bbi + 360) % 360 - 180, antimeridian ^ (\u03bbi > s * \u03bb_ && s * \u03bb > \u03bbi)) {
                    var \u03c6i = -inflection[1] * d3_degrees;
                    \u03c60 > \u03c6i && (\u03c60 = \u03c6i)
                } else
                    \u03c60 > \u03c6 && (\u03c60 = \u03c6), \u03c6 > \u03c61 && (\u03c61 = \u03c6);
                antimeridian ? \u03bb_ > \u03bb ? angle(\u03bb0, \u03bb) > angle(\u03bb0, \u03bb1) && (\u03bb1 = \u03bb) : angle(\u03bb, \u03bb1) > angle(\u03bb0, \u03bb1) && (\u03bb0 = \u03bb) : \u03bb1 >= \u03bb0 ? (\u03bb0 > \u03bb && (\u03bb0 = \u03bb), \u03bb > \u03bb1 && (\u03bb1 = \u03bb)) : \u03bb > \u03bb_ ? angle(\u03bb0, \u03bb) > angle(\u03bb0, \u03bb1) && (\u03bb1 = \u03bb) : angle(\u03bb, \u03bb1) > angle(\u03bb0, \u03bb1) && (\u03bb0 = \u03bb)
            } else
                point(\u03bb, \u03c6);
            p0 = p, \u03bb_ = \u03bb
        }
        function lineStart() {
            bound.point = linePoint
        }
        function lineEnd() {
            range[0] = \u03bb0, range[1] = \u03bb1, bound.point = point, p0 = null
        }
        function ringPoint(\u03bb, \u03c6) {
            if (p0) {
                var d\u03bb = \u03bb - \u03bb_;
                d\u03bbSum += abs(d\u03bb) > 180 ? d\u03bb + (d\u03bb > 0 ? 360 : -360) : d\u03bb
            } else
                \u03bb__ = \u03bb, \u03c6__ = \u03c6;
            d3_geo_area.point(\u03bb, \u03c6), linePoint(\u03bb, \u03c6)
        }
        function ringStart() {
            d3_geo_area.lineStart()
        }
        function ringEnd() {
            ringPoint(\u03bb__, \u03c6__), d3_geo_area.lineEnd(), abs(d\u03bbSum) > \u03b5 && (\u03bb0 = -(\u03bb1 = 180)), range[0] = \u03bb0, range[1] = \u03bb1, p0 = null
        }
        function angle(\u03bb0, \u03bb1) {
            return(\u03bb1 -= \u03bb0) < 0 ? \u03bb1 + 360 : \u03bb1
        }
        function compareRanges(a, b) {
            return a[0] - b[0]
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x
        }
        var \u03bb0, \u03c60, \u03bb1, \u03c61, \u03bb_, \u03bb__, \u03c6__, p0, d\u03bbSum, ranges, range, bound = {point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function () {
                bound.point = ringPoint, bound.lineStart = ringStart, bound.lineEnd = ringEnd, d\u03bbSum = 0, d3_geo_area.polygonStart()
            }, polygonEnd: function () {
                d3_geo_area.polygonEnd(), bound.point = point, bound.lineStart = lineStart, bound.lineEnd = lineEnd, 0 > d3_geo_areaRingSum ? (\u03bb0 = -(\u03bb1 = 180), \u03c60 = -(\u03c61 = 90)) : d\u03bbSum > \u03b5 ? \u03c61 = 90 : -\u03b5 > d\u03bbSum && (\u03c60 = -90), range[0] = \u03bb0, range[1] = \u03bb1
            }};
        return function (feature) {
            \u03c61 = \u03bb1 = -(\u03bb0 = \u03c60 = 1 / 0), ranges = [], d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for (var b, i = 1, a = ranges[0], merged = [a]; n > i; ++i)
                    b = ranges[i], withinRange(b[0], a) || withinRange(b[1], a) ? (angle(a[0], b[1]) > angle(a[0], a[1]) && (a[1] = b[1]), angle(b[0], a[1]) > angle(a[0], a[1]) && (a[0] = b[0])) : merged.push(a = b);
                for (var d\u03bb, b, best = -(1 / 0), n = merged.length - 1, i = 0, a = merged[n]; n >= i; a = b, ++i)
                    b = merged[i], (d\u03bb = angle(a[1], b[0])) > best && (best = d\u03bb, \u03bb0 = b[0], \u03bb1 = a[1])
            }
            return ranges = range = null, \u03bb0 === 1 / 0 || \u03c60 === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[\u03bb0, \u03c60], [\u03bb1, \u03c61]]
        }
    }(), d3.geo.centroid = function (object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0, d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
        return \u03b52 > m && (x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1, \u03b5 > d3_geo_centroidW1 && (x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0), m = x * x + y * y + z * z, \u03b52 > m) ? [NaN, NaN] : [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees]
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2, d3_geo_centroid = {sphere: d3_noop, point: d3_geo_centroidPoint, lineStart: d3_geo_centroidLineStart, lineEnd: d3_geo_centroidLineEnd, polygonStart: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart
        }, polygonEnd: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart
        }}, d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-\u03c0, -\u03c0 / 2]), d3_geo_clipExtentMAX = 1e9;
    d3.geo.clipExtent = function () {
        var x0, y0, x1, y1, stream, clip, clipExtent = {stream: function (output) {
                return stream && (stream.valid = !1), stream = clip(output), stream.valid = !0, stream
            }, extent: function (_) {
                return arguments.length ? (clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), stream && (stream.valid = !1, stream = null), clipExtent) : [[x0, y0], [x1, y1]]
            }};
        return clipExtent.extent([[0, 0], [960, 500]])
    }, (d3.geo.conicEqualArea = function () {
        return d3_geo_conic(d3_geo_conicEqualArea)
    }).raw = d3_geo_conicEqualArea, d3.geo.albers = function () {
        return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070)
    }, d3.geo.albersUsa = function () {
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            return point = null, lower48Point(x, y), point || (alaskaPoint(x, y), point) || hawaiiPoint(x, y), point
        }
        var point, lower48Point, alaskaPoint, hawaiiPoint, lower48 = d3.geo.albers(), alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), pointStream = {point: function (x, y) {
                point = [x, y]
            }};
        return albersUsa.invert = function (coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return(y >= .12 && .234 > y && x >= -.425 && -.214 > x ? alaska : y >= .166 && .234 > y && x >= -.214 && -.115 > x ? hawaii : lower48).invert(coordinates)
        }, albersUsa.stream = function (stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return{point: function (x, y) {
                    lower48Stream.point(x, y), alaskaStream.point(x, y), hawaiiStream.point(x, y)
                }, sphere: function () {
                    lower48Stream.sphere(), alaskaStream.sphere(), hawaiiStream.sphere()
                }, lineStart: function () {
                    lower48Stream.lineStart(), alaskaStream.lineStart(), hawaiiStream.lineStart()
                }, lineEnd: function () {
                    lower48Stream.lineEnd(), alaskaStream.lineEnd(), hawaiiStream.lineEnd()
                }, polygonStart: function () {
                    lower48Stream.polygonStart(), alaskaStream.polygonStart(), hawaiiStream.polygonStart()
                }, polygonEnd: function () {
                    lower48Stream.polygonEnd(), alaskaStream.polygonEnd(), hawaiiStream.polygonEnd()
                }}
        }, albersUsa.precision = function (_) {
            return arguments.length ? (lower48.precision(_), alaska.precision(_), hawaii.precision(_), albersUsa) : lower48.precision()
        }, albersUsa.scale = function (_) {
            return arguments.length ? (lower48.scale(_), alaska.scale(.35 * _), hawaii.scale(_), albersUsa.translate(lower48.translate())) : lower48.scale()
        }, albersUsa.translate = function (_) {
            if (!arguments.length)
                return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            return lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point, alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + \u03b5, y + .12 * k + \u03b5], [x - .214 * k - \u03b5, y + .234 * k - \u03b5]]).stream(pointStream).point, hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + \u03b5, y + .166 * k + \u03b5], [x - .115 * k - \u03b5, y + .234 * k - \u03b5]]).stream(pointStream).point,
            albersUsa
        }, albersUsa.scale(1070)
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1, d3_geo_pathArea = {point: d3_noop, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: function () {
            d3_geo_pathAreaPolygon = 0, d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart
        }, polygonEnd: function () {
            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop, d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2)
        }}, d3_geo_pathBounds = {point: d3_geo_pathBoundsPoint, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: d3_noop, polygonEnd: d3_noop}, d3_geo_pathCentroid = {point: d3_geo_pathCentroidPoint, lineStart: d3_geo_pathCentroidLineStart, lineEnd: d3_geo_pathCentroidLineEnd, polygonStart: function () {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart
        }, polygonEnd: function () {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint, d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart, d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd
        }};
    d3.geo.path = function () {
        function path(object) {
            return object && ("function" == typeof pointRadius && contextStream.pointRadius(+pointRadius.apply(this, arguments)), cacheStream && cacheStream.valid || (cacheStream = projectStream(contextStream)), d3.geo.stream(object, cacheStream)), contextStream.result()
        }
        function reset() {
            return cacheStream = null, path
        }
        var projection, context, projectStream, contextStream, cacheStream, pointRadius = 4.5;
        return path.area = function (object) {
            return d3_geo_pathAreaSum = 0, d3.geo.stream(object, projectStream(d3_geo_pathArea)), d3_geo_pathAreaSum
        }, path.centroid = function (object) {
            return d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0, d3.geo.stream(object, projectStream(d3_geo_pathCentroid)), d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN]
        }, path.bounds = function (object) {
            return d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = 1 / 0), d3.geo.stream(object, projectStream(d3_geo_pathBounds)), [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]]
        }, path.projection = function (_) {
            return arguments.length ? (projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity, reset()) : projection
        }, path.context = function (_) {
            return arguments.length ? (contextStream = null == (context = _) ? new d3_geo_pathBuffer : new d3_geo_pathContext(_), "function" != typeof pointRadius && contextStream.pointRadius(pointRadius), reset()) : context
        }, path.pointRadius = function (_) {
            return arguments.length ? (pointRadius = "function" == typeof _ ? _ : (contextStream.pointRadius(+_), +_), path) : pointRadius
        }, path.projection(d3.geo.albersUsa()).context(null)
    }, d3.geo.transform = function (methods) {
        return{stream: function (stream) {
                var transform = new d3_geo_transform(stream);
                for (var k in methods)
                    transform[k] = methods[k];
                return transform
            }}
    }, d3_geo_transform.prototype = {point: function (x, y) {
            this.stream.point(x, y)
        }, sphere: function () {
            this.stream.sphere()
        }, lineStart: function () {
            this.stream.lineStart()
        }, lineEnd: function () {
            this.stream.lineEnd()
        }, polygonStart: function () {
            this.stream.polygonStart()
        }, polygonEnd: function () {
            this.stream.polygonEnd()
        }}, d3.geo.projection = d3_geo_projection, d3.geo.projectionMutator = d3_geo_projectionMutator, (d3.geo.equirectangular = function () {
        return d3_geo_projection(d3_geo_equirectangular)
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular, d3.geo.rotation = function (rotate) {
        function forward(coordinates) {
            return coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians), coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates
        }
        return rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0), forward.invert = function (coordinates) {
            return coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians), coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates
        }, forward
    }, d3_geo_identityRotation.invert = d3_geo_equirectangular, d3.geo.circle = function () {
        function circle() {
            var center = "function" == typeof origin ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            return interpolate(null, null, 1, {point: function (x, y) {
                    ring.push(x = rotate(x, y)), x[0] *= d3_degrees, x[1] *= d3_degrees
                }}), {type: "Polygon", coordinates: [ring]}
        }
        var angle, interpolate, origin = [0, 0], precision = 6;
        return circle.origin = function (x) {
            return arguments.length ? (origin = x, circle) : origin
        }, circle.angle = function (x) {
            return arguments.length ? (interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians), circle) : angle
        }, circle.precision = function (_) {
            return arguments.length ? (interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians), circle) : precision
        }, circle.angle(90)
    }, d3.geo.distance = function (a, b) {
        var t, \u0394\u03bb = (b[0] - a[0]) * d3_radians, \u03c60 = a[1] * d3_radians, \u03c61 = b[1] * d3_radians, sin\u0394\u03bb = Math.sin(\u0394\u03bb), cos\u0394\u03bb = Math.cos(\u0394\u03bb), sin\u03c60 = Math.sin(\u03c60), cos\u03c60 = Math.cos(\u03c60), sin\u03c61 = Math.sin(\u03c61), cos\u03c61 = Math.cos(\u03c61);
        return Math.atan2(Math.sqrt((t = cos\u03c61 * sin\u0394\u03bb) * t + (t = cos\u03c60 * sin\u03c61 - sin\u03c60 * cos\u03c61 * cos\u0394\u03bb) * t), sin\u03c60 * sin\u03c61 + cos\u03c60 * cos\u03c61 * cos\u0394\u03bb)
    }, d3.geo.graticule = function () {
        function graticule() {
            return{type: "MultiLineString", coordinates: lines()}
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
                return abs(x % DX) > \u03b5
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
                return abs(y % DY) > \u03b5
            }).map(y))
        }
        var x1, x0, X1, X0, y1, y0, Y1, Y0, x, y, X, Y, dx = 10, dy = dx, DX = 90, DY = 360, precision = 2.5;
        return graticule.lines = function () {
            return lines().map(function (coordinates) {
                return{type: "LineString", coordinates: coordinates}
            })
        }, graticule.outline = function () {
            return{type: "Polygon", coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]}
        }, graticule.extent = function (_) {
            return arguments.length ? graticule.majorExtent(_).minorExtent(_) : graticule.minorExtent()
        }, graticule.majorExtent = function (_) {
            return arguments.length ? (X0 = +_[0][0], X1 = +_[1][0], Y0 = +_[0][1], Y1 = +_[1][1], X0 > X1 && (_ = X0, X0 = X1, X1 = _), Y0 > Y1 && (_ = Y0, Y0 = Y1, Y1 = _), graticule.precision(precision)) : [[X0, Y0], [X1, Y1]]
        }, graticule.minorExtent = function (_) {
            return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], x0 > x1 && (_ = x0, x0 = x1, x1 = _), y0 > y1 && (_ = y0, y0 = y1, y1 = _), graticule.precision(precision)) : [[x0, y0], [x1, y1]]
        }, graticule.step = function (_) {
            return arguments.length ? graticule.majorStep(_).minorStep(_) : graticule.minorStep()
        }, graticule.majorStep = function (_) {
            return arguments.length ? (DX = +_[0], DY = +_[1], graticule) : [DX, DY]
        }, graticule.minorStep = function (_) {
            return arguments.length ? (dx = +_[0], dy = +_[1], graticule) : [dx, dy]
        }, graticule.precision = function (_) {
            return arguments.length ? (precision = +_, x = d3_geo_graticuleX(y0, y1, 90), y = d3_geo_graticuleY(x0, x1, precision), X = d3_geo_graticuleX(Y0, Y1, 90), Y = d3_geo_graticuleY(X0, X1, precision), graticule) : precision
        }, graticule.majorExtent([[-180, -90 + \u03b5], [180, 90 - \u03b5]]).minorExtent([[-180, -80 - \u03b5], [180, 80 + \u03b5]])
    }, d3.geo.greatArc = function () {
        function greatArc() {
            return{type: "LineString", coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]}
        }
        var source_, target_, source = d3_source, target = d3_target;
        return greatArc.distance = function () {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments))
        }, greatArc.source = function (_) {
            return arguments.length ? (source = _, source_ = "function" == typeof _ ? null : _, greatArc) : source
        }, greatArc.target = function (_) {
            return arguments.length ? (target = _, target_ = "function" == typeof _ ? null : _, greatArc) : target
        }, greatArc.precision = function () {
            return arguments.length ? greatArc : 0
        }, greatArc
    }, d3.geo.interpolate = function (source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians)
    }, d3.geo.length = function (object) {
        return d3_geo_lengthSum = 0, d3.geo.stream(object, d3_geo_length), d3_geo_lengthSum
    };
    var d3_geo_lengthSum, d3_geo_length = {sphere: d3_noop, point: d3_noop, lineStart: d3_geo_lengthLineStart, lineEnd: d3_noop, polygonStart: d3_noop, polygonEnd: d3_noop}, d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (cos\u03bbcos\u03c6) {
        return Math.sqrt(2 / (1 + cos\u03bbcos\u03c6))
    }, function (\u03c1) {
        return 2 * Math.asin(\u03c1 / 2)
    });
    (d3.geo.azimuthalEqualArea = function () {
        return d3_geo_projection(d3_geo_azimuthalEqualArea)
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (cos\u03bbcos\u03c6) {
        var c = Math.acos(cos\u03bbcos\u03c6);
        return c && c / Math.sin(c)
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function () {
        return d3_geo_projection(d3_geo_azimuthalEquidistant)
    }).raw = d3_geo_azimuthalEquidistant, (d3.geo.conicConformal = function () {
        return d3_geo_conic(d3_geo_conicConformal)
    }).raw = d3_geo_conicConformal, (d3.geo.conicEquidistant = function () {
        return d3_geo_conic(d3_geo_conicEquidistant)
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function (cos\u03bbcos\u03c6) {
        return 1 / cos\u03bbcos\u03c6
    }, Math.atan);
    (d3.geo.gnomonic = function () {
        return d3_geo_projection(d3_geo_gnomonic)
    }).raw = d3_geo_gnomonic, d3_geo_mercator.invert = function (x, y) {
        return[x, 2 * Math.atan(Math.exp(y)) - half\u03c0]
    }, (d3.geo.mercator = function () {
        return d3_geo_mercatorProjection(d3_geo_mercator)
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function () {
        return 1
    }, Math.asin);
    (d3.geo.orthographic = function () {
        return d3_geo_projection(d3_geo_orthographic)
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function (cos\u03bbcos\u03c6) {
        return 1 / (1 + cos\u03bbcos\u03c6)
    }, function (\u03c1) {
        return 2 * Math.atan(\u03c1)
    });
    (d3.geo.stereographic = function () {
        return d3_geo_projection(d3_geo_stereographic)
    }).raw = d3_geo_stereographic, d3_geo_transverseMercator.invert = function (x, y) {
        return[-y, 2 * Math.atan(Math.exp(x)) - half\u03c0]
    }, (d3.geo.transverseMercator = function () {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
        return projection.center = function (_) {
            return _ ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]])
        }, projection.rotate = function (_) {
            return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90])
        }, rotate([0, 0, 90])
    }).raw = d3_geo_transverseMercator, d3.geom = {}, d3.geom.hull = function (vertices) {
        function hull(data) {
            if (data.length < 3)
                return[];
            var i, fx = d3_functor(x), fy = d3_functor(y), n = data.length, points = [], flippedPoints = [];
            for (i = 0; n > i; i++)
                points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
            for (points.sort(d3_geom_hullOrder), i = 0; n > i; i++)
                flippedPoints.push([points[i][0], -points[i][1]]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints), skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i)
                polygon.push(data[points[upper[i]][2]]);
            for (i = + skipLeft; i < lower.length - skipRight; ++i)
                polygon.push(data[points[lower[i]][2]]);
            return polygon
        }
        var x = d3_geom_pointX, y = d3_geom_pointY;
        return arguments.length ? hull(vertices) : (hull.x = function (_) {
            return arguments.length ? (x = _, hull) : x
        }, hull.y = function (_) {
            return arguments.length ? (y = _, hull) : y
        }, hull)
    }, d3.geom.polygon = function (coordinates) {
        return d3_subclass(coordinates, d3_geom_polygonPrototype), coordinates
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function () {
        for (var a, i = -1, n = this.length, b = this[n - 1], area = 0; ++i < n; )
            a = b, b = this[i], area += a[1] * b[0] - a[0] * b[1];
        return.5 * area
    }, d3_geom_polygonPrototype.centroid = function (k) {
        var a, c, i = -1, n = this.length, x = 0, y = 0, b = this[n - 1];
        for (arguments.length || (k = - 1 / (6 * this.area())); ++i < n; )
            a = b, b = this[i], c = a[0] * b[1] - b[0] * a[1], x += (a[0] + b[0]) * c, y += (a[1] + b[1]) * c;
        return[x * k, y * k]
    }, d3_geom_polygonPrototype.clip = function (subject) {
        for (var input, j, m, b, c, d, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), a = this[n - 1]; ++i < n; ) {
            for (input = subject.slice(), subject.length = 0, b = this[i], c = input[(m = input.length - closed) - 1], j = - 1; ++j < m; )
                d = input[j], d3_geom_polygonInside(d, a, b) ? (d3_geom_polygonInside(c, a, b) || subject.push(d3_geom_polygonIntersect(c, d, a, b)), subject.push(d)) : d3_geom_polygonInside(c, a, b) && subject.push(d3_geom_polygonIntersect(c, d, a, b)), c = d;
            closed && subject.push(subject[0]), a = b
        }
        return subject
    };
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiBeachPool = [], d3_geom_voronoiCirclePool = [];
    d3_geom_voronoiCell.prototype.prepare = function () {
        for (var edge, halfEdges = this.edges, iHalfEdge = halfEdges.length; iHalfEdge--; )
            edge = halfEdges[iHalfEdge].edge, edge.b && edge.a || halfEdges.splice(iHalfEdge, 1);
        return halfEdges.sort(d3_geom_voronoiHalfEdgeOrder), halfEdges.length
    }, d3_geom_voronoiHalfEdge.prototype = {start: function () {
            return this.edge.l === this.site ? this.edge.a : this.edge.b
        }, end: function () {
            return this.edge.l === this.site ? this.edge.b : this.edge.a
        }}, d3_geom_voronoiRedBlackTree.prototype = {insert: function (after, node) {
            var parent, grandpa, uncle;
            if (after) {
                if (node.P = after, node.N = after.N, after.N && (after.N.P = node), after.N = node, after.R) {
                    for (after = after.R; after.L; )
                        after = after.L;
                    after.L = node
                } else
                    after.R = node;
                parent = after
            } else
                this._ ? (after = d3_geom_voronoiRedBlackFirst(this._), node.P = null, node.N = after, after.P = after.L = node, parent = after) : (node.P = node.N = null, this._ = node, parent = null);
            for (node.L = node.R = null, node.U = parent, node.C = !0, after = node; parent && parent.C; )
                grandpa = parent.U, parent === grandpa.L ? (uncle = grandpa.R, uncle && uncle.C ? (parent.C = uncle.C = !1, grandpa.C = !0, after = grandpa) : (after === parent.R && (d3_geom_voronoiRedBlackRotateLeft(this, parent), after = parent, parent = after.U), parent.C = !1, grandpa.C = !0, d3_geom_voronoiRedBlackRotateRight(this, grandpa))) : (uncle = grandpa.L, uncle && uncle.C ? (parent.C = uncle.C = !1, grandpa.C = !0, after = grandpa) : (after === parent.L && (d3_geom_voronoiRedBlackRotateRight(this, parent), after = parent, parent = after.U), parent.C = !1, grandpa.C = !0, d3_geom_voronoiRedBlackRotateLeft(this, grandpa))), parent = after.U;
            this._.C = !1
        }, remove: function (node) {
            node.N && (node.N.P = node.P), node.P && (node.P.N = node.N), node.N = node.P = null;
            var sibling, next, red, parent = node.U, left = node.L, right = node.R;
            if (next = left ? right ? d3_geom_voronoiRedBlackFirst(right) : left : right, parent ? parent.L === node ? parent.L = next : parent.R = next : this._ = next, left && right ? (red = next.C, next.C = node.C, next.L = left, left.U = next, next !== right ? (parent = next.U, next.U = node.U, node = next.R, parent.L = node, next.R = right, right.U = next) : (next.U = parent, parent = next, node = next.R)) : (red = node.C, node = next), node && (node.U = parent), !red) {
                if (node && node.C)
                    return void(node.C = !1);
                do {
                    if (node === this._)
                        break;
                    if (node === parent.L) {
                        if (sibling = parent.R, sibling.C && (sibling.C = !1, parent.C = !0, d3_geom_voronoiRedBlackRotateLeft(this, parent), sibling = parent.R), sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                            sibling.R && sibling.R.C || (sibling.L.C = !1, sibling.C = !0, d3_geom_voronoiRedBlackRotateRight(this, sibling), sibling = parent.R), sibling.C = parent.C, parent.C = sibling.R.C = !1, d3_geom_voronoiRedBlackRotateLeft(this, parent), node = this._;
                            break
                        }
                    } else if (sibling = parent.L, sibling.C && (sibling.C = !1, parent.C = !0, d3_geom_voronoiRedBlackRotateRight(this, parent), sibling = parent.L), sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        sibling.L && sibling.L.C || (sibling.R.C = !1, sibling.C = !0, d3_geom_voronoiRedBlackRotateLeft(this, sibling), sibling = parent.L), sibling.C = parent.C, parent.C = sibling.L.C = !1, d3_geom_voronoiRedBlackRotateRight(this, parent), node = this._;
                        break
                    }
                    sibling.C = !0, node = parent, parent = parent.U
                } while (!node.C);
                node && (node.C = !1)
            }
        }}, d3.geom.voronoi = function (points) {
        function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            return d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function (cell, i) {
                var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function (e) {
                    var s = e.start();
                    return[s.x, s.y]
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
                polygon.point = data[i]
            }), polygons
        }
        function sites(data) {
            return data.map(function (d, i) {
                return{x: Math.round(fx(d, i) / \u03b5) * \u03b5, y: Math.round(fy(d, i) / \u03b5) * \u03b5, i: i}
            })
        }
        var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
        return points ? voronoi(points) : (voronoi.links = function (data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function (edge) {
                return edge.l && edge.r
            }).map(function (edge) {
                return{source: data[edge.l.i], target: data[edge.r.i]}
            })
        }, voronoi.triangles = function (data) {
            var triangles = [];
            return d3_geom_voronoi(sites(data)).cells.forEach(function (cell, i) {
                for (var e0, s0, site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l; ++j < m; )
                    e0 = e1, s0 = s1, e1 = edges[j].edge, s1 = e1.l === site ? e1.r : e1.l, i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0 && triangles.push([data[i], data[s0.i], data[s1.i]])
            }), triangles
        }, voronoi.x = function (_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x
        }, voronoi.y = function (_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y
        }, voronoi.clipExtent = function (_) {
            return arguments.length ? (clipExtent = null == _ ? d3_geom_voronoiClipExtent : _, voronoi) : clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent
        }, voronoi.size = function (_) {
            return arguments.length ? voronoi.clipExtent(_ && [[0, 0], _]) : clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1]
        }, voronoi)
    };
    var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
    d3.geom.delaunay = function (vertices) {
        return d3.geom.voronoi().triangles(vertices)
    }, d3.geom.quadtree = function (points, x1, y1, x2, y2) {
        function quadtree(data) {
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (!isNaN(x) && !isNaN(y))
                    if (n.leaf) {
                        var nx = n.x, ny = n.y;
                        if (null != nx)
                            if (abs(nx - x) + abs(ny - y) < .01)
                                insertChild(n, d, x, y, x1, y1, x2, y2);
                            else {
                                var nPoint = n.point;
                                n.x = n.y = n.point = null, insertChild(n, nPoint, nx, ny, x1, y1, x2, y2), insertChild(n, d, x, y, x1, y1, x2, y2)
                            }
                        else
                            n.x = x, n.y = y, n.point = d
                    } else
                        insertChild(n, d, x, y, x1, y1, x2, y2)
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = .5 * (x1 + x2), ym = .5 * (y1 + y2), right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = !1, n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode()), right ? x1 = xm : x2 = xm, below ? y1 = ym : y2 = ym, insert(n, d, x, y, x1, y1, x2, y2)
            }
            var d, xs, ys, i, n, x1_, y1_, x2_, y2_, fx = d3_functor(x), fy = d3_functor(y);
            if (null != x1)
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            else if (x2_ = y2_ = -(x1_ = y1_ = 1 / 0), xs = [], ys = [], n = data.length, compat)
                for (i = 0; n > i; ++i)
                    d = data[i], d.x < x1_ && (x1_ = d.x), d.y < y1_ && (y1_ = d.y), d.x > x2_ && (x2_ = d.x), d.y > y2_ && (y2_ = d.y), xs.push(d.x), ys.push(d.y);
            else
                for (i = 0; n > i; ++i) {
                    var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                    x1_ > x_ && (x1_ = x_), y1_ > y_ && (y1_ = y_), x_ > x2_ && (x2_ = x_), y_ > y2_ && (y2_ = y_), xs.push(x_), ys.push(y_)
                }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            dx > dy ? y2_ = y1_ + dx : x2_ = x1_ + dy;
            var root = d3_geom_quadtreeNode();
            if (root.add = function (d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_)
            }, root.visit = function (f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_)
            }, root.find = function (point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_)
            }, i = -1, null == x1) {
                for (; ++i < n; )
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                --i
            } else
                data.forEach(root.add);
            return xs = ys = data = d = null, root
        }
        var compat, x = d3_geom_pointX, y = d3_geom_pointY;
        return(compat = arguments.length) ? (x = d3_geom_quadtreeCompatX, y = d3_geom_quadtreeCompatY, 3 === compat && (y2 = y1, x2 = x1, y1 = x1 = 0), quadtree(points)) : (quadtree.x = function (_) {
            return arguments.length ? (x = _, quadtree) : x
        }, quadtree.y = function (_) {
            return arguments.length ? (y = _, quadtree) : y
        }, quadtree.extent = function (_) {
            return arguments.length ? (null == _ ? x1 = y1 = x2 = y2 = null : (x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1]), quadtree) : null == x1 ? null : [[x1, y1], [x2, y2]]
        }, quadtree.size = function (_) {
            return arguments.length ? (null == _ ? x1 = y1 = x2 = y2 = null : (x1 = y1 = 0, x2 = +_[0], y2 = +_[1]), quadtree) : null == x1 ? null : [x2 - x1, y2 - y1]
        }, quadtree)
    }, d3.interpolateRgb = d3_interpolateRgb, d3.interpolateObject = d3_interpolateObject, d3.interpolateNumber = d3_interpolateNumber, d3.interpolateString = d3_interpolateString;
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
    d3.interpolate = d3_interpolate, d3.interpolators = [function (a, b) {
            var t = typeof b;
            return("string" === t ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : "object" === t && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b)
        }], d3.interpolateArray = d3_interpolateArray;
    var d3_ease_default = function () {
        return d3_identity
    }, d3_ease = d3.map({linear: d3_ease_default, poly: d3_ease_poly, quad: function () {
            return d3_ease_quad
        }, cubic: function () {
            return d3_ease_cubic
        }, sin: function () {
            return d3_ease_sin
        }, exp: function () {
            return d3_ease_exp
        }, circle: function () {
            return d3_ease_circle
        }, elastic: d3_ease_elastic, back: d3_ease_back, bounce: function () {
            return d3_ease_bounce
        }}), d3_ease_mode = d3.map({"in": d3_identity, out: d3_ease_reverse, "in-out": d3_ease_reflect, "out-in": function (f) {
            return d3_ease_reflect(d3_ease_reverse(f))
        }});
    d3.ease = function (name) {
        var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
        return t = d3_ease.get(t) || d3_ease_default, m = d3_ease_mode.get(m) || d3_identity, d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))))
    }, d3.interpolateHcl = d3_interpolateHcl, d3.interpolateHsl = d3_interpolateHsl, d3.interpolateLab = d3_interpolateLab, d3.interpolateRound = d3_interpolateRound, d3.transform = function (string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return(d3.transform = function (string) {
            if (null != string) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate()
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity)
        })(string)
    }, d3_transform.prototype.toString = function () {
        return"translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")"
    };
    var d3_transformIdentity = {a: 1, b: 0, c: 0, d: 1, e: 0, f: 0};
    d3.interpolateTransform = d3_interpolateTransform, d3.layout = {}, d3.layout.bundle = function () {
        return function (links) {
            for (var paths = [], i = -1, n = links.length; ++i < n; )
                paths.push(d3_layout_bundlePath(links[i]));
            return paths
        }
    }, d3.layout.chord = function () {
        function relayout() {
            var k, x, x0, i, j, subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [];
            for (chords = [], groups = [], k = 0, i = -1; ++i < n; ) {
                for (x = 0, j = - 1; ++j < n; )
                    x += matrix[i][j];
                groupSums.push(x), subgroupIndex.push(d3.range(n)), k += x
            }
            for (sortGroups && groupIndex.sort(function (a, b) {
                return sortGroups(groupSums[a], groupSums[b])
            }), sortSubgroups && subgroupIndex.forEach(function (d, i) {
                d.sort(function (a, b) {
                    return sortSubgroups(matrix[i][a], matrix[i][b])
                })
            }), k = (\u03c4 - padding * n) / k, x = 0, i = -1; ++i < n; ) {
                for (x0 = x, j = -1; ++j < n; ) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + "-" + dj] = {index: di, subindex: dj, startAngle: a0, endAngle: a1, value: v}
                }
                groups[di] = {index: di, startAngle: x0, endAngle: x, value: (x - x0) / k}, x += padding
            }
            for (i = - 1; ++i < n; )
                for (j = i - 1; ++j < n; ) {
                    var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                    (source.value || target.value) && chords.push(source.value < target.value ? {source: target, target: source} : {source: source, target: target})
                }
            sortChords && resort()
        }
        function resort() {
            chords.sort(function (a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2)
            })
        }
        var chords, groups, matrix, n, sortGroups, sortSubgroups, sortChords, chord = {}, padding = 0;
        return chord.matrix = function (x) {
            return arguments.length ? (n = (matrix = x) && matrix.length, chords = groups = null, chord) : matrix
        }, chord.padding = function (x) {
            return arguments.length ? (padding = x, chords = groups = null, chord) : padding
        }, chord.sortGroups = function (x) {
            return arguments.length ? (sortGroups = x, chords = groups = null, chord) : sortGroups
        }, chord.sortSubgroups = function (x) {
            return arguments.length ? (sortSubgroups = x, chords = null, chord) : sortSubgroups
        }, chord.sortChords = function (x) {
            return arguments.length ? (sortChords = x, chords && resort(), chord) : sortChords
        }, chord.chords = function () {
            return chords || relayout(), chords
        }, chord.groups = function () {
            return groups || relayout(), groups
        }, chord
    }, d3.layout.force = function () {
        function repulse(node) {
            return function (quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dn > dw * dw / theta2) {
                        if (chargeDistance2 > dn) {
                            var k = quad.charge / dn;
                            node.px -= dx * k, node.py -= dy * k
                        }
                        return!0
                    }
                    if (quad.point && dn && chargeDistance2 > dn) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k, node.py -= dy * k
                    }
                }
                return!quad.charge
            }
        }
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y, force.resume()
        }
        var drag, alpha, distances, strengths, charges, force = {}, event = d3.dispatch("start", "tick", "end"), size = [1, 1], friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [];
        return force.tick = function () {
            if ((alpha *= .99) < .005)
                return event.end({type: "end", alpha: alpha = 0}), !0;
            var q, i, o, s, t, l, k, x, y, n = nodes.length, m = links.length;
            for (i = 0; m > i; ++i)
                o = links[i], s = o.source, t = o.target, x = t.x - s.x, y = t.y - s.y, (l = x * x + y * y) && (l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l, x *= l, y *= l, t.x -= x * (k = s.weight / (t.weight + s.weight)), t.y -= y * k, s.x += x * (k = 1 - k), s.y += y * k);
            if ((k = alpha * gravity) && (x = size[0] / 2, y = size[1] / 2, i = -1, k))
                for (; ++i < n; )
                    o = nodes[i], o.x += (x - o.x) * k, o.y += (y - o.y) * k;
            if (charge)
                for (d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges), i = - 1; ++i < n; )
                    (o = nodes[i]).fixed || q.visit(repulse(o));
            for (i = - 1; ++i < n; )
                o = nodes[i], o.fixed ? (o.x = o.px, o.y = o.py) : (o.x -= (o.px - (o.px = o.x)) * friction, o.y -= (o.py - (o.py = o.y)) * friction);
            event.tick({type: "tick", alpha: alpha})
        }, force.nodes = function (x) {
            return arguments.length ? (nodes = x, force) : nodes
        }, force.links = function (x) {
            return arguments.length ? (links = x, force) : links
        }, force.size = function (x) {
            return arguments.length ? (size = x, force) : size
        }, force.linkDistance = function (x) {
            return arguments.length ? (linkDistance = "function" == typeof x ? x : +x, force) : linkDistance
        }, force.distance = force.linkDistance, force.linkStrength = function (x) {
            return arguments.length ? (linkStrength = "function" == typeof x ? x : +x, force) : linkStrength
        }, force.friction = function (x) {
            return arguments.length ? (friction = +x, force) : friction
        }, force.charge = function (x) {
            return arguments.length ? (charge = "function" == typeof x ? x : +x, force) : charge
        }, force.chargeDistance = function (x) {
            return arguments.length ? (chargeDistance2 = x * x, force) : Math.sqrt(chargeDistance2)
        }, force.gravity = function (x) {
            return arguments.length ? (gravity = +x, force) : gravity
        }, force.theta = function (x) {
            return arguments.length ? (theta2 = x * x, force) : Math.sqrt(theta2)
        }, force.alpha = function (x) {
            return arguments.length ? (x = +x, alpha ? alpha = x > 0 ? x : 0 : x > 0 && (event.start({type: "start", alpha: alpha = x}), d3.timer(force.tick)), force) : alpha
        }, force.start = function () {
            function position(dimension, size) {
                if (!neighbors) {
                    for (neighbors = new Array(n), j = 0; n > j; ++j)
                        neighbors[j] = [];
                    for (j = 0; m > j; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target), neighbors[o.target.index].push(o.source)
                    }
                }
                for (var x, candidates = neighbors[i], j = -1, m = candidates.length; ++j < m; )
                    if (!isNaN(x = candidates[j][dimension]))
                        return x;
                return Math.random() * size
            }
            var i, neighbors, o, n = nodes.length, m = links.length, w = size[0], h = size[1];
            for (i = 0; n > i; ++i)
                (o = nodes[i]).index = i, o.weight = 0;
            for (i = 0; m > i; ++i)
                o = links[i], "number" == typeof o.source && (o.source = nodes[o.source]), "number" == typeof o.target && (o.target = nodes[o.target]), ++o.source.weight, ++o.target.weight;
            for (i = 0; n > i; ++i)
                o = nodes[i], isNaN(o.x) && (o.x = position("x", w)), isNaN(o.y) && (o.y = position("y", h)), isNaN(o.px) && (o.px = o.x), isNaN(o.py) && (o.py = o.y);
            if (distances = [], "function" == typeof linkDistance)
                for (i = 0; m > i; ++i)
                    distances[i] = +linkDistance.call(this, links[i], i);
            else
                for (i = 0; m > i; ++i)
                    distances[i] = linkDistance;
            if (strengths = [], "function" == typeof linkStrength)
                for (i = 0; m > i; ++i)
                    strengths[i] = +linkStrength.call(this, links[i], i);
            else
                for (i = 0; m > i; ++i)
                    strengths[i] = linkStrength;
            if (charges = [], "function" == typeof charge)
                for (i = 0; n > i; ++i)
                    charges[i] = +charge.call(this, nodes[i], i);
            else
                for (i = 0; n > i; ++i)
                    charges[i] = charge;
            return force.resume()
        }, force.resume = function () {
            return force.alpha(.1)
        }, force.stop = function () {
            return force.alpha(0)
        }, force.drag = function () {
            return drag || (drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend)), arguments.length ? void this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag) : drag
        }, d3.rebind(force, event, "on")
    };
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = 1 / 0;
    d3.layout.hierarchy = function () {
        function hierarchy(root) {
            var node, stack = [root], nodes = [];
            for (root.depth = 0; null != (node = stack.pop()); )
                if (nodes.push(node), (childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    for (var n, childs, child; --n >= 0; )
                        stack.push(child = childs[n]), child.parent = node, child.depth = node.depth + 1;
                    value && (node.value = 0), node.children = childs
                } else
                    value && (node.value = +value.call(hierarchy, node, node.depth) || 0), delete node.children;
            return d3_layout_hierarchyVisitAfter(root, function (node) {
                var childs, parent;
                sort && (childs = node.children) && childs.sort(sort), value && (parent = node.parent) && (parent.value += node.value)
            }), nodes
        }
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        return hierarchy.sort = function (x) {
            return arguments.length ? (sort = x, hierarchy) : sort
        }, hierarchy.children = function (x) {
            return arguments.length ? (children = x, hierarchy) : children
        }, hierarchy.value = function (x) {
            return arguments.length ? (value = x, hierarchy) : value
        }, hierarchy.revalue = function (root) {
            return value && (d3_layout_hierarchyVisitBefore(root, function (node) {
                node.children && (node.value = 0)
            }), d3_layout_hierarchyVisitAfter(root, function (node) {
                var parent;
                node.children || (node.value = +value.call(hierarchy, node, node.depth) || 0), (parent = node.parent) && (parent.value += node.value)
            })), root
        }, hierarchy
    }, d3.layout.partition = function () {
        function position(node, x, dx, dy) {
            var children = node.children;
            if (node.x = x, node.y = node.depth * dy, node.dx = dx, node.dy = dy, children && (n = children.length)) {
                var n, c, d, i = -1;
                for (dx = node.value?dx / node.value:0; ++i < n; )
                    position(c = children[i], x, d = c.value * dx, dy), x += d
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length))
                for (var n, i = -1; ++i < n; )
                    d = Math.max(d, depth(children[i]));
            return 1 + d
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            return position(nodes[0], 0, size[0], size[1] / depth(nodes[0])), nodes
        }
        var hierarchy = d3.layout.hierarchy(), size = [1, 1];
        return partition.size = function (x) {
            return arguments.length ? (size = x, partition) : size
        }, d3_layout_hierarchyRebind(partition, hierarchy)
    }, d3.layout.pie = function () {
        function pie(data) {
            var v, n = data.length, values = data.map(function (d, i) {
                return+value.call(pie, d, i)
            }), a = +("function" == typeof startAngle ? startAngle.apply(this, arguments) : startAngle), da = ("function" == typeof endAngle ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +("function" == typeof padAngle ? padAngle.apply(this, arguments) : padAngle)), pa = p * (0 > da ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [];
            return null != sort && index.sort(sort === d3_layout_pieSortByValue ? function (i, j) {
                return values[j] - values[i]
            } : function (i, j) {
                return sort(data[i], data[j])
            }), index.forEach(function (i) {
                arcs[i] = {data: data[i], value: v = values[i], startAngle: a, endAngle: a += v * k + pa, padAngle: p}
            }), arcs
        }
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = \u03c4, padAngle = 0;
        return pie.value = function (_) {
            return arguments.length ? (value = _, pie) : value
        }, pie.sort = function (_) {
            return arguments.length ? (sort = _, pie) : sort
        }, pie.startAngle = function (_) {
            return arguments.length ? (startAngle = _, pie) : startAngle
        }, pie.endAngle = function (_) {
            return arguments.length ? (endAngle = _, pie) : endAngle
        }, pie.padAngle = function (_) {
            return arguments.length ? (padAngle = _, pie) : padAngle
        }, pie
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function () {
        function stack(data, index) {
            if (!(n = data.length))
                return data;
            var series = data.map(function (d, i) {
                return values.call(stack, d, i)
            }), points = series.map(function (d) {
                return d.map(function (v, i) {
                    return[x.call(stack, v, i), y.call(stack, v, i)]
                })
            }), orders = order.call(stack, points, index);
            series = d3.permute(series, orders), points = d3.permute(points, orders);
            var n, i, j, o, offsets = offset.call(stack, points, index), m = series[0].length;
            for (j = 0; m > j; ++j)
                for (out.call(stack, series[0][j], o = offsets[j], points[0][j][1]), i = 1; n > i; ++i)
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
            return data
        }
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
        return stack.values = function (x) {
            return arguments.length ? (values = x, stack) : values
        }, stack.order = function (x) {
            return arguments.length ? (order = "function" == typeof x ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault, stack) : order
        }, stack.offset = function (x) {
            return arguments.length ? (offset = "function" == typeof x ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero, stack) : offset
        }, stack.x = function (z) {
            return arguments.length ? (x = z, stack) : x
        }, stack.y = function (z) {
            return arguments.length ? (y = z, stack) : y
        }, stack.out = function (z) {
            return arguments.length ? (out = z, stack) : out
        }, stack
    };
    var d3_layout_stackOrders = d3.map({"inside-out": function (data) {
            var i, j, n = data.length, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function (a, b) {
                return max[a] - max[b]
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; n > i; ++i)
                j = index[i], bottom > top ? (top += sums[j], tops.push(j)) : (bottom += sums[j], bottoms.push(j));
            return bottoms.reverse().concat(tops)
        }, reverse: function (data) {
            return d3.range(data.length).reverse()
        }, "default": d3_layout_stackOrderDefault}), d3_layout_stackOffsets = d3.map({silhouette: function (data) {
            var i, j, o, n = data.length, m = data[0].length, sums = [], max = 0, y0 = [];
            for (j = 0; m > j; ++j) {
                for (i = 0, o = 0; n > i; i++)
                    o += data[i][j][1];
                o > max && (max = o), sums.push(o)
            }
            for (j = 0; m > j; ++j)
                y0[j] = (max - sums[j]) / 2;
            return y0
        }, wiggle: function (data) {
            var i, j, k, s1, s2, s3, dx, o, o0, n = data.length, x = data[0], m = x.length, y0 = [];
            for (y0[0] = o = o0 = 0, j = 1; m > j; ++j) {
                for (i = 0, s1 = 0; n > i; ++i)
                    s1 += data[i][j][1];
                for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; n > i; ++i) {
                    for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); i > k; ++k)
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    s2 += s3 * data[i][j][1]
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0, o0 > o && (o0 = o)
            }
            for (j = 0; m > j; ++j)
                y0[j] -= o0;
            return y0
        }, expand: function (data) {
            var i, j, o, n = data.length, m = data[0].length, k = 1 / n, y0 = [];
            for (j = 0; m > j; ++j) {
                for (i = 0, o = 0; n > i; i++)
                    o += data[i][j][1];
                if (o)
                    for (i = 0; n > i; i++)
                        data[i][j][1] /= o;
                else
                    for (i = 0; n > i; i++)
                        data[i][j][1] = k
            }
            for (j = 0; m > j; ++j)
                y0[j] = 0;
            return y0
        }, zero: d3_layout_stackOffsetZero});
    d3.layout.histogram = function () {
        function histogram(data, i) {
            for (var bin, x, bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n; ++i < m; )
                bin = bins[i] = [], bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]), bin.y = 0;
            if (m > 0)
                for (i = - 1; ++i < n; )
                    x = values[i], x >= range[0] && x <= range[1] && (bin = bins[d3.bisect(thresholds, x, 1, m) - 1], bin.y += k, bin.push(data[i]));
            return bins
        }
        var frequency = !0, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        return histogram.value = function (x) {
            return arguments.length ? (valuer = x, histogram) : valuer
        }, histogram.range = function (x) {
            return arguments.length ? (ranger = d3_functor(x), histogram) : ranger
        }, histogram.bins = function (x) {
            return arguments.length ? (binner = "number" == typeof x ? function (range) {
                return d3_layout_histogramBinFixed(range, x)
            } : d3_functor(x), histogram) : binner
        }, histogram.frequency = function (x) {
            return arguments.length ? (frequency = !!x, histogram) : frequency
        }, histogram
    }, d3.layout.pack = function () {
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = null == radius ? Math.sqrt : "function" == typeof radius ? radius : function () {
                return radius
            };
            if (root.x = root.y = 0, d3_layout_hierarchyVisitAfter(root, function (d) {
                d.r = +r(d.value)
            }), d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings), padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r += dr
                }), d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings), d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r -= dr
                })
            }
            return d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h)), nodes
        }
        var radius, hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [1, 1];
        return pack.size = function (_) {
            return arguments.length ? (size = _, pack) : size
        }, pack.radius = function (_) {
            return arguments.length ? (radius = null == _ || "function" == typeof _ ? _ : +_, pack) : radius
        }, pack.padding = function (_) {
            return arguments.length ? (padding = +_, pack) : padding
        }, d3_layout_hierarchyRebind(pack, hierarchy)
    }, d3.layout.tree = function () {
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            if (d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z, d3_layout_hierarchyVisitBefore(root1, secondWalk), nodeSize)
                d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    node.x < left.x && (left = node), node.x > right.x && (right = node), node.depth > bottom.depth && (bottom = node)
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    node.x = (node.x + tx) * kx, node.y = node.depth * ky
                })
            }
            return nodes
        }
        function wrapTree(root0) {
            for (var node1, root1 = {A: null, children: [root0]}, queue = [root1]; null != (node1 = queue.pop()); )
                for (var child, children = node1.children, i = 0, n = children.length; n > i; ++i)
                    queue.push((children[i] = child = {_: children[i], parent: node1, children: (child = children[i].children) && child.slice() || [], A: null, a: null, z: 0, m: 0, c: 0, s: 0, t: null, i: i}).a = child);
            return root1.children[0]
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                w ? (v.z = w.z + separation(v._, w._), v.m = v.z - midpoint) : v.z = midpoint
            } else
                w && (v.z = w.z + separation(v._, w._));
            v.parent.A = apportion(v, w, v.parent.A || siblings[0])
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m, v.m += v.parent.m
        }
        function apportion(v, w, ancestor) {
            if (w) {
                for (var shift, vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m; vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip; )
                    vom = d3_layout_treeLeft(vom), vop = d3_layout_treeRight(vop), vop.a = v, shift = vim.z + sim - vip.z - sip + separation(vim._, vip._), shift > 0 && (d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift), sip += shift, sop += shift), sim += vim.m, sip += vip.m, som += vom.m, sop += vop.m;
                vim && !d3_layout_treeRight(vop) && (vop.t = vim, vop.m += sim - sop), vip && !d3_layout_treeLeft(vom) && (vom.t = vip, vom.m += sip - som, ancestor = v)
            }
            return ancestor
        }
        function sizeNode(node) {
            node.x *= size[0], node.y = node.depth * size[1]
        }
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = null;
        return tree.separation = function (x) {
            return arguments.length ? (separation = x, tree) : separation
        }, tree.size = function (x) {
            return arguments.length ? (nodeSize = null == (size = x) ? sizeNode : null, tree) : nodeSize ? null : size
        }, tree.nodeSize = function (x) {
            return arguments.length ? (nodeSize = null == (size = x) ? null : sizeNode, tree) : nodeSize ? size : null
        }, d3_layout_hierarchyRebind(tree, hierarchy)
    }, d3.layout.cluster = function () {
        function cluster(d, i) {
            var previousNode, nodes = hierarchy.call(this, d, i), root = nodes[0], x = 0;
            d3_layout_hierarchyVisitAfter(root, function (node) {
                var children = node.children;
                children && children.length ? (node.x = d3_layout_clusterX(children), node.y = d3_layout_clusterY(children)) : (node.x = previousNode ? x += separation(node, previousNode) : 0, node.y = 0, previousNode = node)
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            return d3_layout_hierarchyVisitAfter(root, nodeSize ? function (node) {
                node.x = (node.x - root.x) * size[0], node.y = (root.y - node.y) * size[1]
            } : function (node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0], node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1]
            }), nodes
        }
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = !1;
        return cluster.separation = function (x) {
            return arguments.length ? (separation = x, cluster) : separation
        }, cluster.size = function (x) {
            return arguments.length ? (nodeSize = null == (size = x), cluster) : nodeSize ? null : size
        }, cluster.nodeSize = function (x) {
            return arguments.length ? (nodeSize = null != (size = x), cluster) : nodeSize ? size : null
        }, d3_layout_hierarchyRebind(cluster, hierarchy)
    }, d3.layout.treemap = function () {
        function scale(children, k) {
            for (var child, area, i = -1, n = children.length; ++i < n; )
                area = (child = children[i]).value * (0 > k ? 0 : k), child.area = isNaN(area) || 0 >= area ? 0 : area
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var child, score, n, rect = pad(node), row = [], remaining = children.slice(), best = 1 / 0, u = "slice" === mode ? rect.dx : "dice" === mode ? rect.dy : "slice-dice" === mode ? 1 & node.depth ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy);
                for (scale(remaining, rect.dx * rect.dy / node.value), row.area = 0; (n = remaining.length) > 0; )
                    row.push(child = remaining[n - 1]), row.area += child.area, "squarify" !== mode || (score = worst(row, u)) <= best ? (remaining.pop(), best = score) : (row.area -= row.pop().area, position(row, u, rect, !1), u = Math.min(rect.dx, rect.dy), row.length = row.area = 0, best = 1 / 0);
                row.length && (position(row, u, rect, !0), row.length = row.area = 0), children.forEach(squarify)
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var child, rect = pad(node), remaining = children.slice(), row = [];
                for (scale(remaining, rect.dx * rect.dy / node.value), row.area = 0; child = remaining.pop(); )
                    row.push(child), row.area += child.area, null != child.z && (position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length), row.length = row.area = 0);
                children.forEach(stickify)
            }
        }
        function worst(row, u) {
            for (var r, s = row.area, rmax = 0, rmin = 1 / 0, i = -1, n = row.length; ++i < n; )
                (r = row[i].area) && (rmin > r && (rmin = r), r > rmax && (rmax = r));
            return s *= s, u *= u, s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : 1 / 0
        }
        function position(row, u, rect, flush) {
            var o, i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0;
            if (u == rect.dx) {
                for ((flush || v > rect.dy) && (v = rect.dy); ++i < n; )
                    o = row[i], o.x = x, o.y = y, o.dy = v, x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                o.z = !0, o.dx += rect.x + rect.dx - x, rect.y += v, rect.dy -= v
            } else {
                for ((flush || v > rect.dx) && (v = rect.dx); ++i < n; )
                    o = row[i], o.x = x, o.y = y, o.dx = v, y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                o.z = !1, o.dy += rect.y + rect.dy - y, rect.x += v, rect.dx -= v
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            return root.x = 0, root.y = 0, root.dx = size[0], root.dy = size[1], stickies && hierarchy.revalue(root), scale([root], root.dx * root.dy / root.value), (stickies ? stickify : squarify)(root), sticky && (stickies = nodes), nodes
        }
        var stickies, hierarchy = d3.layout.hierarchy(), round = Math.round, size = [1, 1], padding = null, pad = d3_layout_treemapPadNull, sticky = !1, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
        return treemap.size = function (x) {
            return arguments.length ? (size = x, treemap) : size
        }, treemap.padding = function (x) {
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return null == p ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, "number" == typeof p ? [p, p, p, p] : p)
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x)
            }
            if (!arguments.length)
                return padding;
            var type;
            return pad = null == (padding = x) ? d3_layout_treemapPadNull : "function" == (type = typeof x) ? padFunction : "number" === type ? (x = [x, x, x, x], padConstant) : padConstant, treemap
        }, treemap.round = function (x) {
            return arguments.length ? (round = x ? Math.round : Number, treemap) : round != Number
        }, treemap.sticky = function (x) {
            return arguments.length ? (sticky = x, stickies = null, treemap) : sticky
        }, treemap.ratio = function (x) {
            return arguments.length ? (ratio = x, treemap) : ratio
        }, treemap.mode = function (x) {
            return arguments.length ? (mode = x + "", treemap) : mode
        }, d3_layout_hierarchyRebind(treemap, hierarchy)
    }, d3.random = {normal: function (\u00b5, \u03c3) {
            var n = arguments.length;
            return 2 > n && (\u03c3 = 1), 1 > n && (\u00b5 = 0), function () {
                var x, y, r;
                do
                    x = 2 * Math.random() - 1, y = 2 * Math.random() - 1, r = x * x + y * y;
                while (!r || r > 1);
                return \u00b5 + \u03c3 * x * Math.sqrt(-2 * Math.log(r) / r)
            }
        }, logNormal: function () {
            var random = d3.random.normal.apply(d3, arguments);
            return function () {
                return Math.exp(random())
            }
        }, bates: function (m) {
            var random = d3.random.irwinHall(m);
            return function () {
                return random() / m
            }
        }, irwinHall: function (m) {
            return function () {
                for (var s = 0, j = 0; m > j; j++)
                    s += Math.random();
                return s
            }
        }}, d3.scale = {};
    var d3_scale_niceIdentity = {floor: d3_identity, ceil: d3_identity};
    d3.scale.linear = function () {
        return d3_scale_linear([0, 1], [0, 1], d3_interpolate, !1)
    };
    var d3_scale_linearFormatSignificant = {s: 1, g: 1, p: 1, r: 1, e: 1};
    d3.scale.log = function () {
        return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, !0, [1, 10])
    };
    var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {floor: function (x) {
            return-Math.ceil(-x)
        }, ceil: function (x) {
            return-Math.floor(-x)
        }};
    d3.scale.pow = function () {
        return d3_scale_pow(d3.scale.linear(), 1, [0, 1])
    }, d3.scale.sqrt = function () {
        return d3.scale.pow().exponent(.5)
    }, d3.scale.ordinal = function () {
        return d3_scale_ordinal([], {t: "range", a: [[]]})
    }, d3.scale.category10 = function () {
        return d3.scale.ordinal().range(d3_category10)
    }, d3.scale.category20 = function () {
        return d3.scale.ordinal().range(d3_category20)
    }, d3.scale.category20b = function () {
        return d3.scale.ordinal().range(d3_category20b)
    }, d3.scale.category20c = function () {
        return d3.scale.ordinal().range(d3_category20c)
    };
    var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString), d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString), d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString), d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
    d3.scale.quantile = function () {
        return d3_scale_quantile([], [])
    }, d3.scale.quantize = function () {
        return d3_scale_quantize(0, 1, [0, 1])
    }, d3.scale.threshold = function () {
        return d3_scale_threshold([.5], [0, 1])
    }, d3.scale.identity = function () {
        return d3_scale_identity([0, 1])
    }, d3.svg = {}, d3.svg.arc = function () {
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half\u03c0, a1 = endAngle.apply(this, arguments) - half\u03c0, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r0 > r1 && (rc = r1, r1 = r0, r0 = rc), da >= \u03c4\u03b5)
                return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, x0, y0, x1, y1, x2, y2, x3, y3, p0 = 0, p1 = 0, path = [];
            if ((ap = (+padAngle.apply(this, arguments) || 0) / 2) && (rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments), cw || (p1 *= -1), r1 && (p1 = d3_asin(rp / r1 * Math.sin(ap))), r0 && (p0 = d3_asin(rp / r0 * Math.sin(ap)))), r1) {
                x0 = r1 * Math.cos(a0 + p1), y0 = r1 * Math.sin(a0 + p1), x1 = r1 * Math.cos(a1 - p1), y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <= \u03c0 ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1), y0 = r1 * Math.sin(h1), x1 = y1 = null
                }
            } else
                x0 = y0 = 0;
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0), y2 = r0 * Math.sin(a1 - p0), x3 = r0 * Math.cos(a0 + p0), y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <= \u03c0 ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0), y2 = r0 * Math.sin(h0), x3 = y3 = null
                }
            } else
                x2 = y2 = 0;
            if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
                cr = r1 > r0 ^ cw ? 0 : 1;
                var oc = null == x3 ? [x2, y2] : null == x1 ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                if (null != x1) {
                    var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(null == x3 ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
                    rc === rc1 ? path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]) : path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0])
                } else
                    path.push("M", x0, ",", y0);
                if (null != x3) {
                    var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([x2, y2], null == x1 ? [x0, y0] : [x1, y1], r0, -rc0, cw);
                    rc === rc0 ? path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]) : path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0])
                } else
                    path.push("L", x2, ",", y2)
            } else
                path.push("M", x0, ",", y0), null != x1 && path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1), path.push("L", x2, ",", y2), null != x3 && path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            return path.push("Z"), path.join("")
        }
        function circleSegment(r1, cw) {
            return"M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1
        }
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        return arc.innerRadius = function (v) {
            return arguments.length ? (innerRadius = d3_functor(v), arc) : innerRadius
        }, arc.outerRadius = function (v) {
            return arguments.length ? (outerRadius = d3_functor(v), arc) : outerRadius
        }, arc.cornerRadius = function (v) {
            return arguments.length ? (cornerRadius = d3_functor(v), arc) : cornerRadius
        }, arc.padRadius = function (v) {
            return arguments.length ? (padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v), arc) : padRadius
        }, arc.startAngle = function (v) {
            return arguments.length ? (startAngle = d3_functor(v), arc) : startAngle
        }, arc.endAngle = function (v) {
            return arguments.length ? (endAngle = d3_functor(v), arc) : endAngle
        }, arc.padAngle = function (v) {
            return arguments.length ? (padAngle = d3_functor(v), arc) : padAngle
        }, arc.centroid = function () {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half\u03c0;
            return[Math.cos(a) * r, Math.sin(a) * r]
        }, arc
    };
    var d3_svg_arcAuto = "auto";
    d3.svg.line = function () {
        return d3_svg_line(d3_identity)
    };
    var d3_svg_lineInterpolators = d3.map({linear: d3_svg_lineLinear, "linear-closed": d3_svg_lineLinearClosed, step: d3_svg_lineStep, "step-before": d3_svg_lineStepBefore, "step-after": d3_svg_lineStepAfter, basis: d3_svg_lineBasis, "basis-open": d3_svg_lineBasisOpen, "basis-closed": d3_svg_lineBasisClosed, bundle: d3_svg_lineBundle, cardinal: d3_svg_lineCardinal, "cardinal-open": d3_svg_lineCardinalOpen, "cardinal-closed": d3_svg_lineCardinalClosed, monotone: d3_svg_lineMonotone});
    d3_svg_lineInterpolators.forEach(function (key, value) {
        value.key = key, value.closed = /-closed$/.test(key)
    });
    var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0], d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0], d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
    d3.svg.line.radial = function () {
        var line = d3_svg_line(d3_svg_lineRadial);
        return line.radius = line.x, delete line.x, line.angle = line.y, delete line.y, line
    }, d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter, d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore, d3.svg.area = function () {
        return d3_svg_area(d3_identity)
    }, d3.svg.area.radial = function () {
        var area = d3_svg_area(d3_svg_lineRadial);
        return area.radius = area.x, delete area.x, area.innerRadius = area.x0, delete area.x0, area.outerRadius = area.x1, delete area.x1, area.angle = area.y, delete area.y, area.startAngle = area.y0, delete area.y0, area.endAngle = area.y1, delete area.y1, area
    }, d3.svg.chord = function () {
        function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return"M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z"
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half\u03c0, a1 = endAngle.call(self, subgroup, i) - half\u03c0;
            return{r: r, a0: a0, a1: a1, p0: [r * Math.cos(a0), r * Math.sin(a0)], p1: [r * Math.cos(a1), r * Math.sin(a1)]}
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1
        }
        function arc(r, p, a) {
            return"A" + r + "," + r + " 0 " + +(a > \u03c0) + ",1 " + p
        }
        function curve(r0, p0, r1, p1) {
            return"Q 0,0 " + p1
        }
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        return chord.radius = function (v) {
            return arguments.length ? (radius = d3_functor(v), chord) : radius
        }, chord.source = function (v) {
            return arguments.length ? (source = d3_functor(v), chord) : source
        }, chord.target = function (v) {
            return arguments.length ? (target = d3_functor(v), chord) : target
        }, chord.startAngle = function (v) {
            return arguments.length ? (startAngle = d3_functor(v), chord) : startAngle
        }, chord.endAngle = function (v) {
            return arguments.length ? (endAngle = d3_functor(v), chord) : endAngle
        }, chord
    }, d3.svg.diagonal = function () {
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];
            return p = p.map(projection), "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3]
        }
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        return diagonal.source = function (x) {
            return arguments.length ? (source = d3_functor(x), diagonal) : source
        }, diagonal.target = function (x) {
            return arguments.length ? (target = d3_functor(x), diagonal) : target
        }, diagonal.projection = function (x) {
            return arguments.length ? (projection = x, diagonal) : projection
        }, diagonal
    }, d3.svg.diagonal.radial = function () {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        return diagonal.projection = function (x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection
        }, diagonal
    }, d3.svg.symbol = function () {
        function symbol(d, i) {
            return(d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i))
        }
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        return symbol.type = function (x) {
            return arguments.length ? (type = d3_functor(x), symbol) : type
        }, symbol.size = function (x) {
            return arguments.length ? (size = d3_functor(x), symbol) : size
        }, symbol
    };
    var d3_svg_symbols = d3.map({circle: d3_svg_symbolCircle, cross: function (size) {
            var r = Math.sqrt(size / 5) / 2;
            return"M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z"
        }, diamond: function (size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return"M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z"
        }, square: function (size) {
            var r = Math.sqrt(size) / 2;
            return"M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z"
        }, "triangle-down": function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return"M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z"
        }, "triangle-up": function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return"M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z"
        }});
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    d3_selectionPrototype.transition = function (name) {
        for (var subgroup, node, id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], transition = d3_transitionInherit || {time: Date.now(), ease: d3_ease_cubicInOut, delay: 0, duration: 250}, j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; )
                (node = group[i]) && d3_transitionNode(node, i, ns, id, transition), subgroup.push(node)
        }
        return d3_transition(subgroups, ns, id)
    }, d3_selectionPrototype.interrupt = function (name) {
        return this.each(null == name ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)))
    };
    var d3_transitionInheritId, d3_transitionInherit, d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace()), d3_transitionPrototype = [], d3_transitionId = 0;
    d3_transitionPrototype.call = d3_selectionPrototype.call, d3_transitionPrototype.empty = d3_selectionPrototype.empty, d3_transitionPrototype.node = d3_selectionPrototype.node, d3_transitionPrototype.size = d3_selectionPrototype.size, d3.transition = function (selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3_selectionRoot.transition(selection)
    }, d3.transition.prototype = d3_transitionPrototype, d3_transitionPrototype.select = function (selector) {
        var subgroup, subnode, node, id = this.id, ns = this.namespace, subgroups = [];
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; )
                (node = group[i]) && (subnode = selector.call(node, node.__data__, i, j)) ? ("__data__"in node && (subnode.__data__ = node.__data__), d3_transitionNode(subnode, i, ns, id, node[ns][id]), subgroup.push(subnode)) : subgroup.push(null)
        }
        return d3_transition(subgroups, ns, id)
    }, d3_transitionPrototype.selectAll = function (selector) {
        var subgroup, subnodes, node, subnode, transition, id = this.id, ns = this.namespace, subgroups = [];
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; )
            for (var group = this[j], i = -1, n = group.length; ++i < n; )
                if (node = group[i]) {
                    transition = node[ns][id], subnodes = selector.call(node, node.__data__, i, j), subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o; )
                        (subnode = subnodes[k]) && d3_transitionNode(subnode, k, ns, id, transition), subgroup.push(subnode)
                }
        return d3_transition(subgroups, ns, id)
    }, d3_transitionPrototype.filter = function (filter) {
        var subgroup, group, node, subgroups = [];
        "function" != typeof filter && (filter = d3_selection_filter(filter));
        for (var j = 0, m = this.length; m > j; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; n > i; i++)
                (node = group[i]) && filter.call(node, node.__data__, i, j) && subgroup.push(node)
        }
        return d3_transition(subgroups, this.namespace, this.id)
    }, d3_transitionPrototype.tween = function (name, tween) {
        var id = this.id, ns = this.namespace;
        return arguments.length < 2 ? this.node()[ns][id].tween.get(name) : d3_selection_each(this, null == tween ? function (node) {
            node[ns][id].tween.remove(name)
        } : function (node) {
            node[ns][id].tween.set(name, tween)
        })
    }, d3_transitionPrototype.attr = function (nameNS, value) {
        function attrNull() {
            this.removeAttribute(name)
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local)
        }
        function attrTween(b) {
            return null == b ? attrNull : (b += "", function () {
                var i, a = this.getAttribute(name);
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttribute(name, i(t))
                })
            })
        }
        function attrTweenNS(b) {
            return null == b ? attrNullNS : (b += "", function () {
                var i, a = this.getAttributeNS(name.space, name.local);
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttributeNS(name.space, name.local, i(t))
                })
            })
        }
        if (arguments.length < 2) {
            for (value in nameNS)
                this.attr(value, nameNS[value]);
            return this
        }
        var interpolate = "transform" == nameNS ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween)
    }, d3_transitionPrototype.attrTween = function (nameNS, tween) {
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function (t) {
                this.setAttribute(name, f(t))
            }
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function (t) {
                this.setAttributeNS(name.space, name.local, f(t))
            }
        }
        var name = d3.ns.qualify(nameNS);
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween)
    }, d3_transitionPrototype.style = function (name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name)
        }
        function styleString(b) {
            return null == b ? styleNull : (b += "", function () {
                var i, a = d3_window.getComputedStyle(this, null).getPropertyValue(name);
                return a !== b && (i = d3_interpolate(a, b), function (t) {
                    this.style.setProperty(name, i(t), priority)
                })
            })
        }
        var n = arguments.length;
        if (3 > n) {
            if ("string" != typeof name) {
                2 > n && (value = "");
                for (priority in name)
                    this.style(priority, name[priority], value);
                return this
            }
            priority = ""
        }
        return d3_transition_tween(this, "style." + name, value, styleString)
    }, d3_transitionPrototype.styleTween = function (name, tween, priority) {
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
            return f && function (t) {
                this.style.setProperty(name, f(t), priority)
            }
        }
        return arguments.length < 3 && (priority = ""), this.tween("style." + name, styleTween)
    }, d3_transitionPrototype.text = function (value) {
        return d3_transition_tween(this, "text", value, d3_transition_text)
    }, d3_transitionPrototype.remove = function () {
        var ns = this.namespace;
        return this.each("end.transition", function () {
            var p;
            this[ns].count < 2 && (p = this.parentNode) && p.removeChild(this)
        })
    }, d3_transitionPrototype.ease = function (value) {
        var id = this.id, ns = this.namespace;
        return arguments.length < 1 ? this.node()[ns][id].ease : ("function" != typeof value && (value = d3.ease.apply(d3, arguments)), d3_selection_each(this, function (node) {
            node[ns][id].ease = value
        }))
    }, d3_transitionPrototype.delay = function (value) {
        var id = this.id, ns = this.namespace;
        return arguments.length < 1 ? this.node()[ns][id].delay : d3_selection_each(this, "function" == typeof value ? function (node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j)
        } : (value = +value, function (node) {
            node[ns][id].delay = value
        }))
    }, d3_transitionPrototype.duration = function (value) {
        var id = this.id, ns = this.namespace;
        return arguments.length < 1 ? this.node()[ns][id].duration : d3_selection_each(this, "function" == typeof value ? function (node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j))
        } : (value = Math.max(1, value), function (node) {
            node[ns][id].duration = value
        }))
    }, d3_transitionPrototype.each = function (type, listener) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
                d3_transitionInheritId = id, d3_selection_each(this, function (node, i, j) {
                    d3_transitionInherit = node[ns][id], type.call(node, node.__data__, i, j)
                })
            } finally {
                d3_transitionInherit = inherit, d3_transitionInheritId = inheritId
            }
        } else
            d3_selection_each(this, function (node) {
                var transition = node[ns][id];
                (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener)
            });
        return this
    }, d3_transitionPrototype.transition = function () {
        for (var subgroup, group, node, transition, id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], j = 0, m = this.length; m > j; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; n > i; i++)
                (node = group[i]) && (transition = node[ns][id0], d3_transitionNode(node, i, ns, id1, {time: transition.time, ease: transition.ease, delay: transition.delay + transition.duration, duration: transition.duration})), subgroup.push(node)
        }
        return d3_transition(subgroups, ns, id1)
    }, d3.svg.axis = function () {
        function axis(g) {
            g.each(function () {
                var tickTransform, g = d3.select(this), scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy(), ticks = null == tickValues ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = null == tickFormat_ ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", \u03b5), tickExit = d3.transition(tick.exit()).style("opacity", \u03b5).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([0]), pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
                tickEnter.append("line"), tickEnter.append("text");
                var x1, x2, y1, y2, lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = "top" === orient || "left" === orient ? -1 : 1;
                if ("bottom" === orient || "top" === orient ? (tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2", text.attr("dy", 0 > sign ? "0em" : ".71em").style("text-anchor", "middle"), pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize)) : (tickTransform = d3_svg_axisY,
                        x1 = "y", y1 = "x", x2 = "y2", y2 = "x2", text.attr("dy", ".32em").style("text-anchor", 0 > sign ? "end" : "start"), pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize)), lineEnter.attr(y2, sign * innerTickSize), textEnter.attr(y1, sign * tickSpacing), lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize), textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing), scale1.rangeBand) {
                    var x = scale1, dx = x.rangeBand() / 2;
                    scale0 = scale1 = function (d) {
                        return x(d) + dx
                    }
                } else
                    scale0.rangeBand ? scale0 = scale1 : tickExit.call(tickTransform, scale1, scale0);
                tickEnter.call(tickTransform, scale0, scale1), tickUpdate.call(tickTransform, scale1, scale1)
            })
        }
        var tickFormat_, scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null;
        return axis.scale = function (x) {
            return arguments.length ? (scale = x, axis) : scale
        }, axis.orient = function (x) {
            return arguments.length ? (orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient, axis) : orient
        }, axis.ticks = function () {
            return arguments.length ? (tickArguments_ = arguments, axis) : tickArguments_
        }, axis.tickValues = function (x) {
            return arguments.length ? (tickValues = x, axis) : tickValues
        }, axis.tickFormat = function (x) {
            return arguments.length ? (tickFormat_ = x, axis) : tickFormat_
        }, axis.tickSize = function (x) {
            var n = arguments.length;
            return n ? (innerTickSize = +x, outerTickSize = +arguments[n - 1], axis) : innerTickSize
        }, axis.innerTickSize = function (x) {
            return arguments.length ? (innerTickSize = +x, axis) : innerTickSize
        }, axis.outerTickSize = function (x) {
            return arguments.length ? (outerTickSize = +x, axis) : outerTickSize
        }, axis.tickPadding = function (x) {
            return arguments.length ? (tickPadding = +x, axis) : tickPadding
        }, axis.tickSubdivide = function () {
            return arguments.length && axis
        }, axis
    };
    var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};
    d3.svg.brush = function () {
        function brush(g) {
            g.each(function () {
                var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart), background = g.selectAll(".background").data([0]);
                background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair"), g.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                var resize = g.selectAll(".resize").data(resizes, d3_identity);
                resize.exit().remove(), resize.enter().append("g").attr("class", function (d) {
                    return"resize " + d
                }).style("cursor", function (d) {
                    return d3_svg_brushCursor[d]
                }).append("rect").attr("x", function (d) {
                    return/[ew]$/.test(d) ? -3 : null
                }).attr("y", function (d) {
                    return/^[ns]/.test(d) ? -3 : null
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden"), resize.style("display", brush.empty() ? "none" : null);
                var range, gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background);
                x && (range = d3_scaleRange(x), backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]), redrawX(gUpdate)), y && (range = d3_scaleRange(y), backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]), redrawY(gUpdate)), redraw(gUpdate)
            })
        }
        function redraw(g) {
            g.selectAll(".resize").attr("transform", function (d) {
                return"translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")"
            })
        }
        function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]), g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0])
        }
        function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]), g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0])
        }
        function brushstart() {
            function keydown() {
                32 == d3.event.keyCode && (dragging || (center = null, origin[0] -= xExtent[1], origin[1] -= yExtent[1], dragging = 2), d3_eventPreventDefault())
            }
            function keyup() {
                32 == d3.event.keyCode && 2 == dragging && (origin[0] += xExtent[1], origin[1] += yExtent[1], dragging = 0, d3_eventPreventDefault())
            }
            function brushmove() {
                var point = d3.mouse(target), moved = !1;
                offset && (point[0] += offset[0], point[1] += offset[1]), dragging || (d3.event.altKey ? (center || (center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2]), origin[0] = xExtent[+(point[0] < center[0])], origin[1] = yExtent[+(point[1] < center[1])]) : center = null), resizingX && move1(point, x, 0) && (redrawX(g), moved = !0), resizingY && move1(point, y, 1) && (redrawY(g), moved = !0), moved && (redraw(g), event_({type: "brush", mode: dragging ? "move" : "resize"}))
            }
            function move1(point, scale, i) {
                var min, max, range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0];
                return dragging && (r0 -= position, r1 -= size + position), min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i], dragging ? max = (min += position) + size : (center && (position = Math.max(r0, Math.min(r1, 2 * center[i] - min))), min > position ? (max = min, min = position) : max = position), extent[0] != min || extent[1] != max ? (i ? yExtentDomain = null : xExtentDomain = null, extent[0] = min, extent[1] = max, !0) : void 0
            }
            function brushend() {
                brushmove(), g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null), d3.select("body").style("cursor", null), w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null), dragRestore(), event_({type: "brushend"})
            }
            var center, offset, target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(), origin = d3.mouse(target), w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches ? w.on("touchmove.brush", brushmove).on("touchend.brush", brushend) : w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend), g.interrupt().selectAll("*").interrupt(), dragging)
                origin[0] = xExtent[0] - origin[0], origin[1] = yExtent[0] - origin[1];
            else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]], origin[0] = xExtent[ex], origin[1] = yExtent[ey]
            } else
                d3.event.altKey && (center = origin.slice());
            g.style("pointer-events", "none").selectAll(".resize").style("display", null), d3.select("body").style("cursor", eventTarget.style("cursor")), event_({type: "brushstart"}), brushmove()
        }
        var xExtentDomain, yExtentDomain, event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [0, 0], yExtent = [0, 0], xClamp = !0, yClamp = !0, resizes = d3_svg_brushResizes[0];
        return brush.event = function (g) {
            g.each(function () {
                var event_ = event.of(this, arguments), extent1 = {x: xExtent, y: yExtent, i: xExtentDomain, j: yExtentDomain}, extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1, d3_transitionInheritId ? d3.select(this).transition().each("start.brush", function () {
                    xExtentDomain = extent0.i, yExtentDomain = extent0.j, xExtent = extent0.x, yExtent = extent0.y, event_({type: "brushstart"})
                }).tween("brush:brush", function () {
                    var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                    return xExtentDomain = yExtentDomain = null, function (t) {
                        xExtent = extent1.x = xi(t), yExtent = extent1.y = yi(t), event_({type: "brush", mode: "resize"})
                    }
                }).each("end.brush", function () {
                    xExtentDomain = extent1.i, yExtentDomain = extent1.j, event_({type: "brush", mode: "resize"}), event_({type: "brushend"})
                }) : (event_({type: "brushstart"}), event_({type: "brush", mode: "resize"}), event_({type: "brushend"}))
            })
        }, brush.x = function (z) {
            return arguments.length ? (x = z, resizes = d3_svg_brushResizes[!x << 1 | !y], brush) : x
        }, brush.y = function (z) {
            return arguments.length ? (y = z, resizes = d3_svg_brushResizes[!x << 1 | !y], brush) : y
        }, brush.clamp = function (z) {
            return arguments.length ? (x && y ? (xClamp = !!z[0], yClamp = !!z[1]) : x ? xClamp = !!z : y && (yClamp = !!z), brush) : x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null
        }, brush.extent = function (z) {
            var x0, x1, y0, y1, t;
            return arguments.length ? (x && (x0 = z[0], x1 = z[1], y && (x0 = x0[0], x1 = x1[0]), xExtentDomain = [x0, x1], x.invert && (x0 = x(x0), x1 = x(x1)), x0 > x1 && (t = x0, x0 = x1, x1 = t), (x0 != xExtent[0] || x1 != xExtent[1]) && (xExtent = [x0, x1])), y && (y0 = z[0], y1 = z[1], x && (y0 = y0[1], y1 = y1[1]), yExtentDomain = [y0, y1], y.invert && (y0 = y(y0), y1 = y(y1)), y0 > y1 && (t = y0, y0 = y1, y1 = t), (y0 != yExtent[0] || y1 != yExtent[1]) && (yExtent = [y0, y1])), brush) : (x && (xExtentDomain ? (x0 = xExtentDomain[0], x1 = xExtentDomain[1]) : (x0 = xExtent[0], x1 = xExtent[1], x.invert && (x0 = x.invert(x0), x1 = x.invert(x1)), x0 > x1 && (t = x0, x0 = x1, x1 = t))), y && (yExtentDomain ? (y0 = yExtentDomain[0], y1 = yExtentDomain[1]) : (y0 = yExtent[0], y1 = yExtent[1], y.invert && (y0 = y.invert(y0), y1 = y.invert(y1)), y0 > y1 && (t = y0, y0 = y1, y1 = t))), x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1])
        }, brush.clear = function () {
            return brush.empty() || (xExtent = [0, 0], yExtent = [0, 0], xExtentDomain = yExtentDomain = null), brush
        }, brush.empty = function () {
            return!!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1]
        }, d3.rebind(brush, event, "on")
    };
    var d3_svg_brushCursor = {n: "ns-resize", e: "ew-resize", s: "ns-resize", w: "ew-resize", nw: "nwse-resize", ne: "nesw-resize", se: "nwse-resize", sw: "nesw-resize"}, d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []], d3_time_format = d3_time.format = d3_locale_enUS.timeFormat, d3_time_formatUtc = d3_time_format.utc, d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
    d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso, d3_time_formatIsoNative.parse = function (string) {
        var date = new Date(string);
        return isNaN(date) ? null : date
    }, d3_time_formatIsoNative.toString = d3_time_formatIso.toString, d3_time.second = d3_time_interval(function (date) {
        return new d3_date(1e3 * Math.floor(date / 1e3))
    }, function (date, offset) {
        date.setTime(date.getTime() + 1e3 * Math.floor(offset))
    }, function (date) {
        return date.getSeconds()
    }), d3_time.seconds = d3_time.second.range, d3_time.seconds.utc = d3_time.second.utc.range, d3_time.minute = d3_time_interval(function (date) {
        return new d3_date(6e4 * Math.floor(date / 6e4))
    }, function (date, offset) {
        date.setTime(date.getTime() + 6e4 * Math.floor(offset))
    }, function (date) {
        return date.getMinutes()
    }), d3_time.minutes = d3_time.minute.range, d3_time.minutes.utc = d3_time.minute.utc.range, d3_time.hour = d3_time_interval(function (date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date(36e5 * (Math.floor(date / 36e5 - timezone) + timezone))
    }, function (date, offset) {
        date.setTime(date.getTime() + 36e5 * Math.floor(offset))
    }, function (date) {
        return date.getHours()
    }), d3_time.hours = d3_time.hour.range, d3_time.hours.utc = d3_time.hour.utc.range, d3_time.month = d3_time_interval(function (date) {
        return date = d3_time.day(date), date.setDate(1), date
    }, function (date, offset) {
        date.setMonth(date.getMonth() + offset)
    }, function (date) {
        return date.getMonth()
    }), d3_time.months = d3_time.month.range, d3_time.months.utc = d3_time.month.utc.range;
    var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6], d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]], d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function (d) {
                return d.getMilliseconds()
            }], [":%S", function (d) {
                return d.getSeconds()
            }], ["%I:%M", function (d) {
                return d.getMinutes()
            }], ["%I %p", function (d) {
                return d.getHours()
            }], ["%a %d", function (d) {
                return d.getDay() && 1 != d.getDate()
            }], ["%b %d", function (d) {
                return 1 != d.getDate()
            }], ["%B", function (d) {
                return d.getMonth()
            }], ["%Y", d3_true]]), d3_time_scaleMilliseconds = {range: function (start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate)
        }, floor: d3_identity, ceil: d3_identity};
    d3_time_scaleLocalMethods.year = d3_time.year, d3_time.scale = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat)
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function (m) {
        return[m[0].utc, m[1]]
    }), d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function (d) {
                return d.getUTCMilliseconds()
            }], [":%S", function (d) {
                return d.getUTCSeconds()
            }], ["%I:%M", function (d) {
                return d.getUTCMinutes()
            }], ["%I %p", function (d) {
                return d.getUTCHours()
            }], ["%a %d", function (d) {
                return d.getUTCDay() && 1 != d.getUTCDate()
            }], ["%b %d", function (d) {
                return 1 != d.getUTCDate()
            }], ["%B", function (d) {
                return d.getUTCMonth()
            }], ["%Y", d3_true]]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc, d3_time.scale.utc = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat)
    }, d3.text = d3_xhrType(function (request) {
        return request.responseText
    }), d3.json = function (url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback)
    }, d3.html = function (url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback)
    }, d3.xml = d3_xhrType(function (request) {
        return request.responseXML
    }), "function" == typeof define && define.amd ? define(d3) : "object" == typeof module && module.exports && (module.exports = d3), this.d3 = d3
}();
var colorbrewer = {YlGn: {3: ["#f7fcb9", "#addd8e", "#31a354"], 4: ["#ffffcc", "#c2e699", "#78c679", "#238443"], 5: ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"], 6: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"], 7: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"], 8: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"], 9: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"]}, YlGnBu: {3: ["#edf8b1", "#7fcdbb", "#2c7fb8"], 4: ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"], 5: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"], 6: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"], 7: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"], 8: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"], 9: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"]}, GnBu: {3: ["#e0f3db", "#a8ddb5", "#43a2ca"], 4: ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"], 5: ["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"], 6: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca", "#0868ac"], 7: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"], 8: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"], 9: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"]}, BuGn: {3: ["#e5f5f9", "#99d8c9", "#2ca25f"], 4: ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"], 5: ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"], 6: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#2ca25f", "#006d2c"], 7: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"], 8: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"], 9: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"]}, PuBuGn: {3: ["#ece2f0", "#a6bddb", "#1c9099"], 4: ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"], 5: ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"], 6: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#1c9099", "#016c59"], 7: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"], 8: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"], 9: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"]}, PuBu: {3: ["#ece7f2", "#a6bddb", "#2b8cbe"], 4: ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"], 5: ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"], 6: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d"], 7: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"], 8: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"], 9: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"]}, BuPu: {3: ["#e0ecf4", "#9ebcda", "#8856a7"], 4: ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"], 5: ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"], 6: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8856a7", "#810f7c"], 7: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"], 8: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"], 9: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"]}, RdPu: {3: ["#fde0dd", "#fa9fb5", "#c51b8a"], 4: ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"], 5: ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"], 6: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"], 7: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"], 8: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"], 9: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"]}, PuRd: {3: ["#e7e1ef", "#c994c7", "#dd1c77"], 4: ["#f1eef6", "#d7b5d8", "#df65b0", "#ce1256"], 5: ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"], 6: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#dd1c77", "#980043"], 7: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"], 8: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"], 9: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"]}, OrRd: {3: ["#fee8c8", "#fdbb84", "#e34a33"], 4: ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"], 5: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"], 6: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#e34a33", "#b30000"], 7: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"], 8: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"], 9: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]}, YlOrRd: {3: ["#ffeda0", "#feb24c", "#f03b20"], 4: ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"], 5: ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"], 6: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"], 7: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"], 8: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"], 9: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"]}, YlOrBr: {3: ["#fff7bc", "#fec44f", "#d95f0e"], 4: ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"], 5: ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"], 6: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"], 7: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"], 8: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"], 9: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"]}, Purples: {3: ["#efedf5", "#bcbddc", "#756bb1"], 4: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"], 5: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"], 6: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"], 7: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"], 8: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"], 9: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"]}, Blues: {3: ["#deebf7", "#9ecae1", "#3182bd"], 4: ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"], 5: ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"], 6: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"], 7: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"], 8: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"], 9: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"]}, Greens: {3: ["#e5f5e0", "#a1d99b", "#31a354"], 4: ["#edf8e9", "#bae4b3", "#74c476", "#238b45"], 5: ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"], 6: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"], 7: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"], 8: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"], 9: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"]}, Oranges: {3: ["#fee6ce", "#fdae6b", "#e6550d"], 4: ["#feedde", "#fdbe85", "#fd8d3c", "#d94701"], 5: ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"], 6: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"], 7: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"], 8: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"], 9: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"]}, Reds: {3: ["#fee0d2", "#fc9272", "#de2d26"], 4: ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"], 5: ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"], 6: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"], 7: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"], 8: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"], 9: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"]}, Greys: {3: ["#f0f0f0", "#bdbdbd", "#636363"], 4: ["#f7f7f7", "#cccccc", "#969696", "#525252"], 5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"], 6: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"], 7: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"], 8: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"], 9: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"]}, PuOr: {3: ["#f1a340", "#f7f7f7", "#998ec3"], 4: ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"], 5: ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"], 6: ["#b35806", "#f1a340", "#fee0b6", "#d8daeb", "#998ec3", "#542788"], 7: ["#b35806", "#f1a340", "#fee0b6", "#f7f7f7", "#d8daeb", "#998ec3", "#542788"], 8: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788"], 9: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788"], 10: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"], 11: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"]}, BrBG: {3: ["#d8b365", "#f5f5f5", "#5ab4ac"], 4: ["#a6611a", "#dfc27d", "#80cdc1", "#018571"], 5: ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"], 6: ["#8c510a", "#d8b365", "#f6e8c3", "#c7eae5", "#5ab4ac", "#01665e"], 7: ["#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"], 8: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e"], 9: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e"], 10: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"], 11: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"]}, PRGn: {3: ["#af8dc3", "#f7f7f7", "#7fbf7b"], 4: ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"], 5: ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"], 6: ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"], 7: ["#762a83", "#af8dc3", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#7fbf7b", "#1b7837"], 8: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"], 9: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"], 10: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"], 11: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"]}, PiYG: {3: ["#e9a3c9", "#f7f7f7", "#a1d76a"], 4: ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"], 5: ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"], 6: ["#c51b7d", "#e9a3c9", "#fde0ef", "#e6f5d0", "#a1d76a", "#4d9221"], 7: ["#c51b7d", "#e9a3c9", "#fde0ef", "#f7f7f7", "#e6f5d0", "#a1d76a", "#4d9221"], 8: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"], 9: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"], 10: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"], 11: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"]}, RdBu: {3: ["#ef8a62", "#f7f7f7", "#67a9cf"], 4: ["#ca0020", "#f4a582", "#92c5de", "#0571b0"], 5: ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"], 6: ["#b2182b", "#ef8a62", "#fddbc7", "#d1e5f0", "#67a9cf", "#2166ac"], 7: ["#b2182b", "#ef8a62", "#fddbc7", "#f7f7f7", "#d1e5f0", "#67a9cf", "#2166ac"], 8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"], 9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"], 10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"], 11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"]}, RdGy: {3: ["#ef8a62", "#ffffff", "#999999"], 4: ["#ca0020", "#f4a582", "#bababa", "#404040"], 5: ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"], 6: ["#b2182b", "#ef8a62", "#fddbc7", "#e0e0e0", "#999999", "#4d4d4d"], 7: ["#b2182b", "#ef8a62", "#fddbc7", "#ffffff", "#e0e0e0", "#999999", "#4d4d4d"], 8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"], 9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"], 10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"], 11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"]}, RdYlBu: {3: ["#fc8d59", "#ffffbf", "#91bfdb"], 4: ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"], 5: ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"], 6: ["#d73027", "#fc8d59", "#fee090", "#e0f3f8", "#91bfdb", "#4575b4"], 7: ["#d73027", "#fc8d59", "#fee090", "#ffffbf", "#e0f3f8", "#91bfdb", "#4575b4"], 8: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"], 9: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"], 10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"], 11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"]}, Spectral: {3: ["#fc8d59", "#ffffbf", "#99d594"], 4: ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"], 5: ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"], 6: ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"], 7: ["#d53e4f", "#fc8d59", "#fee08b", "#ffffbf", "#e6f598", "#99d594", "#3288bd"], 8: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"], 9: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"], 10: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"], 11: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"]}, RdYlGn: {3: ["#fc8d59", "#ffffbf", "#91cf60"], 4: ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"], 5: ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"], 6: ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"], 7: ["#d73027", "#fc8d59", "#fee08b", "#ffffbf", "#d9ef8b", "#91cf60", "#1a9850"], 8: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"], 9: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"], 10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"], 11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]}, Accent: {3: ["#7fc97f", "#beaed4", "#fdc086"], 4: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"], 5: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"], 6: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f"], 7: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17"], 8: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"]}, Dark2: {3: ["#1b9e77", "#d95f02", "#7570b3"], 4: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"], 5: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"], 6: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"], 7: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d"], 8: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"]}, Paired: {3: ["#a6cee3", "#1f78b4", "#b2df8a"], 4: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"], 5: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"], 6: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c"], 7: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"], 8: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"], 9: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6"], 10: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a"], 11: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99"], 12: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"]}, Pastel1: {3: ["#fbb4ae", "#b3cde3", "#ccebc5"], 4: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"], 5: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"], 6: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc"], 7: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"], 8: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec"], 9: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]}, Pastel2: {3: ["#b3e2cd", "#fdcdac", "#cbd5e8"], 4: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4"], 5: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"], 6: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae"], 7: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc"], 8: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"]}, Set1: {3: ["#e41a1c", "#377eb8", "#4daf4a"], 4: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"], 5: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"], 6: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33"], 7: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628"], 8: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"], 9: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"]}, Set2: {3: ["#66c2a5", "#fc8d62", "#8da0cb"], 4: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"], 5: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"], 6: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f"], 7: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494"], 8: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"]}, Set3: {3: ["#8dd3c7", "#ffffb3", "#bebada"], 4: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"], 5: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"], 6: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462"], 7: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69"], 8: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5"], 9: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9"], 10: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd"], 11: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5"], 12: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]}};
!function (view) {
    "use strict";
    if (view.URL = view.URL || view.webkitURL, view.Blob && view.URL)
        try {
            return void new Blob
        } catch (e) {
        }
    var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || function (view) {
        var get_class = function (object) {
            return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1]
        }, FakeBlobBuilder = function () {
            this.data = []
        }, FakeBlob = function (data, type, encoding) {
            this.data = data, this.size = data.length, this.type = type, this.encoding = encoding
        }, FBB_proto = FakeBlobBuilder.prototype, FB_proto = FakeBlob.prototype, FileReaderSync = view.FileReaderSync, FileException = function (type) {
            this.code = this[this.name = type]
        }, file_ex_codes = "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR".split(" "), file_ex_code = file_ex_codes.length, real_URL = view.URL || view.webkitURL || view, real_create_object_URL = real_URL.createObjectURL, real_revoke_object_URL = real_URL.revokeObjectURL, URL = real_URL, btoa = view.btoa, atob = view.atob, ArrayBuffer = view.ArrayBuffer, Uint8Array = view.Uint8Array, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;
        for (FakeBlob.fake = FB_proto.fake = !0; file_ex_code--; )
            FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
        return real_URL.createObjectURL || (URL = view.URL = function (uri) {
            var uri_origin, uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a");
            return uri_info.href = uri, "origin"in uri_info || ("data:" === uri_info.protocol.toLowerCase() ? uri_info.origin = null : (uri_origin = uri.match(origin), uri_info.origin = uri_origin && uri_origin[1])), uri_info
        }), URL.createObjectURL = function (blob) {
            var data_URI_header, type = blob.type;
            return null === type && (type = "application/octet-stream"), blob instanceof FakeBlob ? (data_URI_header = "data:" + type, "base64" === blob.encoding ? data_URI_header + ";base64," + blob.data : "URI" === blob.encoding ? data_URI_header + "," + decodeURIComponent(blob.data) : btoa ? data_URI_header + ";base64," + btoa(blob.data) : data_URI_header + "," + encodeURIComponent(blob.data)) : real_create_object_URL ? real_create_object_URL.call(real_URL, blob) : void 0
        }, URL.revokeObjectURL = function (object_URL) {
            "data:" !== object_URL.substring(0, 5) && real_revoke_object_URL && real_revoke_object_URL.call(real_URL, object_URL)
        }, FBB_proto.append = function (data) {
            var bb = this.data;
            if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
                for (var str = "", buf = new Uint8Array(data), i = 0, buf_len = buf.length; buf_len > i; i++)
                    str += String.fromCharCode(buf[i]);
                bb.push(str)
            } else if ("Blob" === get_class(data) || "File" === get_class(data)) {
                if (!FileReaderSync)
                    throw new FileException("NOT_READABLE_ERR");
                var fr = new FileReaderSync;
                bb.push(fr.readAsBinaryString(data))
            } else
                data instanceof FakeBlob ? "base64" === data.encoding && atob ? bb.push(atob(data.data)) : "URI" === data.encoding ? bb.push(decodeURIComponent(data.data)) : "raw" === data.encoding && bb.push(data.data) : ("string" != typeof data && (data += ""), bb.push(unescape(encodeURIComponent(data))))
        }, FBB_proto.getBlob = function (type) {
            return arguments.length || (type = null), new FakeBlob(this.data.join(""), type, "raw")
        }, FBB_proto.toString = function () {
            return"[object BlobBuilder]"
        }, FB_proto.slice = function (start, end, type) {
            var args = arguments.length;
            return 3 > args && (type = null), new FakeBlob(this.data.slice(start, args > 1 ? end : this.data.length), type, this.encoding)
        }, FB_proto.toString = function () {
            return"[object Blob]"
        }, FB_proto.close = function () {
            this.size = 0, delete this.data
        }, FakeBlobBuilder
    }(view);
    view.Blob = function (blobParts, options) {
        var type = options ? options.type || "" : "", builder = new BlobBuilder;
        if (blobParts)
            for (var i = 0, len = blobParts.length; len > i; i++)
                builder.append(blobParts[i]);
        return builder.getBlob(type)
    }
}("undefined" != typeof self && self || "undefined" != typeof window && window || this.content || this);
var saveAs = saveAs || "undefined" != typeof navigator && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator) || function (view) {
    "use strict";
    if ("undefined" == typeof navigator || !/MSIE [1-9]\./.test(navigator.userAgent)) {
        var doc = view.document, get_URL = function () {
            return view.URL || view.webkitURL || view
        }, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"), can_use_save_link = "download"in save_link, click = function (node) {
            var event = doc.createEvent("MouseEvents");
            event.initMouseEvent("click", !0, !1, view, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), node.dispatchEvent(event)
        }, webkit_req_fs = view.webkitRequestFileSystem, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem, throw_outside = function (ex) {
            (view.setImmediate || view.setTimeout)(function () {
                throw ex
            }, 0)
        }, force_saveable_type = "application/octet-stream", fs_min_size = 0, arbitrary_revoke_timeout = 500, revoke = function (file) {
            var revoker = function () {
                "string" == typeof file ? get_URL().revokeObjectURL(file) : file.remove()
            };
            view.chrome ? revoker() : setTimeout(revoker, arbitrary_revoke_timeout)
        }, dispatch = function (filesaver, event_types, event) {
            event_types = [].concat(event_types);
            for (var i = event_types.length; i--; ) {
                var listener = filesaver["on" + event_types[i]];
                if ("function" == typeof listener)
                    try {
                        listener.call(filesaver, event || filesaver)
                    } catch (ex) {
                        throw_outside(ex)
                    }
            }
        }, FileSaver = function (blob, name) {
            var object_url, target_view, slice, filesaver = this, type = blob.type, blob_changed = !1, dispatch_all = function () {
                dispatch(filesaver, "writestart progress write writeend".split(" "))
            }, fs_error = function () {
                if ((blob_changed || !object_url) && (object_url = get_URL().createObjectURL(blob)), target_view)
                    target_view.location.href = object_url;
                else {
                    var new_tab = view.open(object_url, "_blank");
                    void 0 == new_tab && "undefined" != typeof safari && (view.location.href = object_url)
                }
                filesaver.readyState = filesaver.DONE, dispatch_all(), revoke(object_url)
            }, abortable = function (func) {
                return function () {
                    return filesaver.readyState !== filesaver.DONE ? func.apply(this, arguments) : void 0
                }
            }, create_if_not_found = {create: !0, exclusive: !1};
            return filesaver.readyState = filesaver.INIT, name || (name = "download"), can_use_save_link ? (object_url = get_URL().createObjectURL(blob), save_link.href = object_url, save_link.download = name, click(save_link), filesaver.readyState = filesaver.DONE, dispatch_all(), void revoke(object_url)) : (view.chrome && type && type !== force_saveable_type && (slice = blob.slice || blob.webkitSlice, blob = slice.call(blob, 0, blob.size, force_saveable_type), blob_changed = !0), webkit_req_fs && "download" !== name && (name += ".download"), (type === force_saveable_type || webkit_req_fs) && (target_view = view), req_fs ? (fs_min_size += blob.size, void req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
                fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
                    var save = function () {
                        dir.getFile(name, create_if_not_found, abortable(function (file) {
                            file.createWriter(abortable(function (writer) {
                                writer.onwriteend = function (event) {
                                    target_view.location.href = file.toURL(), filesaver.readyState = filesaver.DONE, dispatch(filesaver, "writeend", event), revoke(file)
                                }, writer.onerror = function () {
                                    var error = writer.error;
                                    error.code !== error.ABORT_ERR && fs_error()
                                }, "writestart progress write abort".split(" ").forEach(function (event) {
                                    writer["on" + event] = filesaver["on" + event]
                                }), writer.write(blob), filesaver.abort = function () {
                                    writer.abort(), filesaver.readyState = filesaver.DONE
                                }, filesaver.readyState = filesaver.WRITING
                            }), fs_error)
                        }), fs_error)
                    };
                    dir.getFile(name, {create: !1}, abortable(function (file) {
                        file.remove(), save()
                    }), abortable(function (ex) {
                        ex.code === ex.NOT_FOUND_ERR ? save() : fs_error()
                    }))
                }), fs_error)
            }), fs_error)) : void fs_error())
        }, FS_proto = FileSaver.prototype, saveAs = function (blob, name) {
            return new FileSaver(blob, name)
        };
        return FS_proto.abort = function () {
            var filesaver = this;
            filesaver.readyState = filesaver.DONE, dispatch(filesaver, "abort")
        }, FS_proto.readyState = FS_proto.INIT = 0, FS_proto.WRITING = 1, FS_proto.DONE = 2, FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null, saveAs
    }
}("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);
"undefined" != typeof module && module.exports ? module.exports.saveAs = saveAs : "undefined" != typeof define && null !== define && null != define.amd && define([], function () {
    return saveAs
});
var UUID;
UUID = function (overwrittenUUID) {
    function UUID() {
    }
    return UUID.generate = function () {
        var rand = UUID._getRandomInt, hex = UUID._hexAligner;
        return hex(rand(32), 8) + "-" + hex(rand(16), 4) + "-" + hex(16384 | rand(12), 4) + "-" + hex(32768 | rand(14), 4) + "-" + hex(rand(48), 12)
    }, UUID._getRandomInt = function (x) {
        return 0 > x ? NaN : 30 >= x ? 0 | Math.random() * (1 << x) : 53 >= x ? (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << x - 30)) * (1 << 30) : NaN
    }, UUID._getIntAligner = function (radix) {
        return function (num, length) {
            for (var str = num.toString(radix), i = length - str.length, z = "0"; i > 0; i >>>= 1, z += z)
                1 & i && (str = z + str);
            return str
        }
    }, UUID._hexAligner = UUID._getIntAligner(16), UUID.FIELD_NAMES = ["timeLow", "timeMid", "timeHiAndVersion", "clockSeqHiAndReserved", "clockSeqLow", "node"], UUID.FIELD_SIZES = [32, 16, 16, 8, 8, 48], UUID.genV4 = function () {
        var rand = UUID._getRandomInt;
        return(new UUID)._init(rand(32), rand(16), 16384 | rand(12), 128 | rand(6), rand(8), rand(48))
    }, UUID.parse = function (strId) {
        var r, p = /^\s*(urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(\})?\s*$/i;
        if (r = p.exec(strId)) {
            var l = r[1] || "", t = r[8] || "";
            if (l + t === "" || "{" === l && "}" === t || "urn:uuid:" === l.toLowerCase() && "" === t)
                return(new UUID)._init(parseInt(r[2], 16), parseInt(r[3], 16), parseInt(r[4], 16), parseInt(r[5], 16), parseInt(r[6], 16), parseInt(r[7], 16))
        }
        return null
    }, UUID.prototype._init = function () {
        var names = UUID.FIELD_NAMES, sizes = UUID.FIELD_SIZES, bin = UUID._binAligner, hex = UUID._hexAligner;
        this.intFields = new Array(6), this.bitFields = new Array(6), this.hexFields = new Array(6);
        for (var i = 0; 6 > i; i++) {
            var intValue = parseInt(arguments[i] || 0);
            this.intFields[i] = this.intFields[names[i]] = intValue, this.bitFields[i] = this.bitFields[names[i]] = bin(intValue, sizes[i]), this.hexFields[i] = this.hexFields[names[i]] = hex(intValue, sizes[i] / 4)
        }
        return this.version = this.intFields.timeHiAndVersion >> 12 & 15, this.bitString = this.bitFields.join(""), this.hexString = this.hexFields[0] + "-" + this.hexFields[1] + "-" + this.hexFields[2] + "-" + this.hexFields[3] + this.hexFields[4] + "-" + this.hexFields[5], this.urn = "urn:uuid:" + this.hexString, this
    }, UUID._binAligner = UUID._getIntAligner(2), UUID.prototype.toString = function () {
        return this.hexString
    }, UUID.prototype.equals = function (uuid) {
        if (!(uuid instanceof UUID))
            return!1;
        for (var i = 0; 6 > i; i++)
            if (this.intFields[i] !== uuid.intFields[i])
                return!1;
        return!0
    }, UUID.genV1 = function () {
        var now = (new Date).getTime(), st = UUID._state;
        now != st.timestamp ? (now < st.timestamp && st.sequence++, st.timestamp = now, st.tick = UUID._getRandomInt(4)) : Math.random() < UUID._tsRatio && st.tick < 9984 ? st.tick += 1 + UUID._getRandomInt(4) : st.sequence++;
        var tf = UUID._getTimeFieldValues(st.timestamp), tl = tf.low + st.tick, thav = 4095 & tf.hi | 4096;
        st.sequence &= 16383;
        var cshar = st.sequence >>> 8 | 128, csl = 255 & st.sequence;
        return(new UUID)._init(tl, tf.mid, thav, cshar, csl, st.node)
    }, UUID.resetState = function () {
        UUID._state = new UUID._state.constructor
    }, UUID._tsRatio = .25, UUID._state = new function () {
        var rand = UUID._getRandomInt;
        this.timestamp = 0, this.sequence = rand(14), this.node = 1099511627776 * (1 | rand(8)) + rand(40), this.tick = rand(4)
    }, UUID._getTimeFieldValues = function (time) {
        var ts = time - Date.UTC(1582, 9, 15), hm = ts / 4294967296 * 1e4 & 268435455;
        return{low: 1e4 * (268435455 & ts) % 4294967296, mid: 65535 & hm, hi: hm >>> 16, timestamp: ts}
    }, UUID.makeBackwardCompatible = function () {
        var f = UUID.generate;
        UUID.generate = function (o) {
            return o && 1 == o.version ? UUID.genV1().hexString : f.call(UUID)
        }, UUID.makeBackwardCompatible = function () {
        }
    }, UUID.overwrittenUUID = overwrittenUUID, UUID
}(UUID), window.Modernizr = function (window, document, undefined) {
    function setCss(str) {
        mStyle.cssText = str
    }
    function setCssAll(str1, str2) {
        return setCss(prefixes.join(str1 + ";") + (str2 || ""))
    }
    function is(obj, type) {
        return typeof obj === type
    }
    function contains(str, substr) {
        return!!~("" + str).indexOf(substr)
    }
    function testProps(props, prefixed) {
        for (var i in props) {
            var prop = props[i];
            if (!contains(prop, "-") && mStyle[prop] !== undefined)
                return"pfx" == prefixed ? prop : !0
        }
        return!1
    }
    function testDOMProps(props, obj, elem) {
        for (var i in props) {
            var item = obj[props[i]];
            if (item !== undefined)
                return elem === !1 ? props[i] : is(item, "function") ? item.bind(elem || obj) : item
        }
        return!1
    }
    function testPropsAll(prop, prefixed, elem) {
        var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1), props = (prop + " " + cssomPrefixes.join(ucProp + " ") + ucProp).split(" ");
        return is(prefixed, "string") || is(prefixed, "undefined") ? testProps(props, prefixed) : (props = (prop + " " + domPrefixes.join(ucProp + " ") + ucProp).split(" "), testDOMProps(props, prefixed, elem))
    }
    function webforms() {
        Modernizr.input = function (props) {
            for (var i = 0, len = props.length; len > i; i++)
                attrs[props[i]] = !!(props[i]in inputElem);
            return attrs.list && (attrs.list = !(!document.createElement("datalist") || !window.HTMLDataListElement)), attrs
        }("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")), Modernizr.inputtypes = function (props) {
            for (var bool, inputElemType, defaultView, i = 0, len = props.length; len > i; i++)
                inputElem.setAttribute("type", inputElemType = props[i]), bool = "text" !== inputElem.type, bool && (inputElem.value = smile, inputElem.style.cssText = "position:absolute;visibility:hidden;", /^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined ? (docElement.appendChild(inputElem), defaultView = document.defaultView, bool = defaultView.getComputedStyle && "textfield" !== defaultView.getComputedStyle(inputElem, null).WebkitAppearance && 0 !== inputElem.offsetHeight, docElement.removeChild(inputElem)) : /^(search|tel)$/.test(inputElemType) || (bool = /^(url|email)$/.test(inputElemType) ? inputElem.checkValidity && inputElem.checkValidity() === !1 : inputElem.value != smile)), inputs[props[i]] = !!bool;
            return inputs
        }("search tel url email datetime date month week time datetime-local number range color".split(" "))
    }
    var featureName, hasOwnProp, version = "2.6.2", Modernizr = {}, enableClasses = !0, docElement = document.documentElement, mod = "modernizr", modElem = document.createElement(mod), mStyle = modElem.style, inputElem = document.createElement("input"), smile = ":)", toString = {}.toString, prefixes = " -webkit- -moz- -o- -ms- ".split(" "), omPrefixes = "Webkit Moz O ms", cssomPrefixes = omPrefixes.split(" "), domPrefixes = omPrefixes.toLowerCase().split(" "), ns = {svg: "http://www.w3.org/2000/svg"}, tests = {}, inputs = {}, attrs = {}, classes = [], slice = classes.slice, injectElementWithStyles = function (rule, callback, nodes, testnames) {
        var style, ret, node, docOverflow, div = document.createElement("div"), body = document.body, fakeBody = body || document.createElement("body");
        if (parseInt(nodes, 10))
            for (; nodes--; )
                node = document.createElement("div"), node.id = testnames ? testnames[nodes] : mod + (nodes + 1), div.appendChild(node);
        return style = ["&#173;", '<style id="s', mod, '">', rule, "</style>"].join(""), div.id = mod, (body ? div : fakeBody).innerHTML += style, fakeBody.appendChild(div), body || (fakeBody.style.background = "", fakeBody.style.overflow = "hidden", docOverflow = docElement.style.overflow, docElement.style.overflow = "hidden", docElement.appendChild(fakeBody)), ret = callback(div, rule), body ? div.parentNode.removeChild(div) : (fakeBody.parentNode.removeChild(fakeBody), docElement.style.overflow = docOverflow), !!ret
    }, testMediaQuery = function (mq) {
        var matchMedia = window.matchMedia || window.msMatchMedia;
        if (matchMedia)
            return matchMedia(mq).matches;
        var bool;
        return injectElementWithStyles("@media " + mq + " { #" + mod + " { position: absolute; } }", function (node) {
            bool = "absolute" == (window.getComputedStyle ? getComputedStyle(node, null) : node.currentStyle).position
        }), bool
    }, isEventSupported = function () {
        function isEventSupported(eventName, element) {
            element = element || document.createElement(TAGNAMES[eventName] || "div"), eventName = "on" + eventName;
            var isSupported = eventName in element;
            return isSupported || (element.setAttribute || (element = document.createElement("div")), element.setAttribute && element.removeAttribute && (element.setAttribute(eventName, ""), isSupported = is(element[eventName], "function"), is(element[eventName], "undefined") || (element[eventName] = undefined), element.removeAttribute(eventName))), element = null, isSupported
        }
        var TAGNAMES = {select: "input", change: "input", submit: "form", reset: "form", error: "img", load: "img", abort: "img"};
        return isEventSupported
    }(), _hasOwnProperty = {}.hasOwnProperty;
    hasOwnProp = is(_hasOwnProperty, "undefined") || is(_hasOwnProperty.call, "undefined") ? function (object, property) {
        return property in object && is(object.constructor.prototype[property], "undefined")
    } : function (object, property) {
        return _hasOwnProperty.call(object, property)
    }, Function.prototype.bind || (Function.prototype.bind = function (that) {
        var target = this;
        if ("function" != typeof target)
            throw new TypeError;
        var args = slice.call(arguments, 1), bound = function () {
            if (this instanceof bound) {
                var F = function () {
                };
                F.prototype = target.prototype;
                var self = new F, result = target.apply(self, args.concat(slice.call(arguments)));
                return Object(result) === result ? result : self
            }
            return target.apply(that, args.concat(slice.call(arguments)))
        };
        return bound
    }), tests.flexbox = function () {
        return testPropsAll("flexWrap")
    }, tests.flexboxlegacy = function () {
        return testPropsAll("boxDirection")
    }, tests.canvas = function () {
        var elem = document.createElement("canvas");
        return!(!elem.getContext || !elem.getContext("2d"))
    }, tests.canvastext = function () {
        return!(!Modernizr.canvas || !is(document.createElement("canvas").getContext("2d").fillText, "function"))
    }, tests.webgl = function () {
        return!!window.WebGLRenderingContext
    }, tests.touch = function () {
        var bool;
        return"ontouchstart"in window || window.DocumentTouch && document instanceof DocumentTouch ? bool = !0 : injectElementWithStyles(["@media (", prefixes.join("touch-enabled),("), mod, ")", "{#modernizr{top:9px;position:absolute}}"].join(""), function (node) {
            bool = 9 === node.offsetTop
        }), bool
    }, tests.geolocation = function () {
        return"geolocation"in navigator
    }, tests.postmessage = function () {
        return!!window.postMessage
    }, tests.websqldatabase = function () {
        return!!window.openDatabase
    }, tests.indexedDB = function () {
        return!!testPropsAll("indexedDB", window)
    }, tests.hashchange = function () {
        return isEventSupported("hashchange", window) && (document.documentMode === undefined || document.documentMode > 7)
    }, tests.history = function () {
        return!(!window.history || !history.pushState)
    }, tests.draganddrop = function () {
        var div = document.createElement("div");
        return"draggable"in div || "ondragstart"in div && "ondrop"in div
    }, tests.websockets = function () {
        return"WebSocket"in window || "MozWebSocket"in window
    }, tests.rgba = function () {
        return setCss("background-color:rgba(150,255,150,.5)"), contains(mStyle.backgroundColor, "rgba")
    }, tests.hsla = function () {
        return setCss("background-color:hsla(120,40%,100%,.5)"), contains(mStyle.backgroundColor, "rgba") || contains(mStyle.backgroundColor, "hsla")
    }, tests.multiplebgs = function () {
        return setCss("background:url(https://),url(https://),red url(https://)"), /(url\s*\(.*?){3}/.test(mStyle.background)
    }, tests.backgroundsize = function () {
        return testPropsAll("backgroundSize")
    }, tests.borderimage = function () {
        return testPropsAll("borderImage")
    }, tests.borderradius = function () {
        return testPropsAll("borderRadius")
    }, tests.boxshadow = function () {
        return testPropsAll("boxShadow")
    }, tests.textshadow = function () {
        return"" === document.createElement("div").style.textShadow
    }, tests.opacity = function () {
        return setCssAll("opacity:.55"), /^0.55$/.test(mStyle.opacity)
    }, tests.cssanimations = function () {
        return testPropsAll("animationName")
    }, tests.csscolumns = function () {
        return testPropsAll("columnCount")
    }, tests.cssgradients = function () {
        var str1 = "background-image:", str2 = "gradient(linear,left top,right bottom,from(#9f9),to(white));", str3 = "linear-gradient(left top,#9f9, white);";
        return setCss((str1 + "-webkit- ".split(" ").join(str2 + str1) + prefixes.join(str3 + str1)).slice(0, -str1.length)), contains(mStyle.backgroundImage, "gradient")
    }, tests.cssreflections = function () {
        return testPropsAll("boxReflect")
    }, tests.csstransforms = function () {
        return!!testPropsAll("transform")
    }, tests.csstransforms3d = function () {
        var ret = !!testPropsAll("perspective");
        return ret && "webkitPerspective"in docElement.style && injectElementWithStyles("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}", function (node, rule) {
            ret = 9 === node.offsetLeft && 3 === node.offsetHeight
        }), ret
    }, tests.csstransitions = function () {
        return testPropsAll("transition")
    }, tests.fontface = function () {
        var bool;
        return injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}', function (node, rule) {
            var style = document.getElementById("smodernizr"), sheet = style.sheet || style.styleSheet, cssText = sheet ? sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || "" : "";
            bool = /src/i.test(cssText) && 0 === cssText.indexOf(rule.split(" ")[0])
        }), bool
    }, tests.generatedcontent = function () {
        var bool;
        return injectElementWithStyles(["#", mod, "{font:0/0 a}#", mod, ':after{content:"', smile, '";visibility:hidden;font:3px/1 a}'].join(""), function (node) {
            bool = node.offsetHeight >= 3
        }), bool
    }, tests.video = function () {
        var elem = document.createElement("video"), bool = !1;
        try {
            (bool = !!elem.canPlayType) && (bool = new Boolean(bool), bool.ogg = elem.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ""), bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ""), bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ""))
        } catch (e) {
        }
        return bool
    }, tests.audio = function () {
        var elem = document.createElement("audio"), bool = !1;
        try {
            (bool = !!elem.canPlayType) && (bool = new Boolean(bool), bool.ogg = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), bool.mp3 = elem.canPlayType("audio/mpeg;").replace(/^no$/, ""), bool.wav = elem.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""), bool.m4a = (elem.canPlayType("audio/x-m4a;") || elem.canPlayType("audio/aac;")).replace(/^no$/, ""))
        } catch (e) {
        }
        return bool
    }, tests.localstorage = function () {
        try {
            return localStorage.setItem(mod, mod), localStorage.removeItem(mod), !0
        } catch (e) {
            return!1
        }
    }, tests.sessionstorage = function () {
        try {
            return sessionStorage.setItem(mod, mod), sessionStorage.removeItem(mod), !0
        } catch (e) {
            return!1
        }
    }, tests.webworkers = function () {
        return!!window.Worker
    }, tests.applicationcache = function () {
        return!!window.applicationCache
    }, tests.svg = function () {
        return!!document.createElementNS && !!document.createElementNS(ns.svg, "svg").createSVGRect
    }, tests.inlinesvg = function () {
        var div = document.createElement("div");
        return div.innerHTML = "<svg/>", (div.firstChild && div.firstChild.namespaceURI) == ns.svg
    }, tests.smil = function () {
        return!!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, "animate")))
    }, tests.svgclippaths = function () {
        return!!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, "clipPath")))
    };
    for (var feature in tests)
        hasOwnProp(tests, feature) && (featureName = feature.toLowerCase(), Modernizr[featureName] = tests[feature](), classes.push((Modernizr[featureName] ? "" : "no-") + featureName));
    return Modernizr.input || webforms(), Modernizr.addTest = function (feature, test) {
        if ("object" == typeof feature)
            for (var key in feature)
                hasOwnProp(feature, key) && Modernizr.addTest(key, feature[key]);
        else {
            if (feature = feature.toLowerCase(), Modernizr[feature] !== undefined)
                return Modernizr;
            test = "function" == typeof test ? test() : test, "undefined" != typeof enableClasses && enableClasses && (docElement.className += " " + (test ? "" : "no-") + feature), Modernizr[feature] = test
        }
        return Modernizr
    }, setCss(""), modElem = inputElem = null, function (window, document) {
        function addStyleSheet(ownerDocument, cssText) {
            var p = ownerDocument.createElement("p"), parent = ownerDocument.getElementsByTagName("head")[0] || ownerDocument.documentElement;
            return p.innerHTML = "x<style>" + cssText + "</style>", parent.insertBefore(p.lastChild, parent.firstChild)
        }
        function getElements() {
            var elements = html5.elements;
            return"string" == typeof elements ? elements.split(" ") : elements
        }
        function getExpandoData(ownerDocument) {
            var data = expandoData[ownerDocument[expando]];
            return data || (data = {}, expanID++, ownerDocument[expando] = expanID, expandoData[expanID] = data), data
        }
        function createElement(nodeName, ownerDocument, data) {
            if (ownerDocument || (ownerDocument = document), supportsUnknownElements)
                return ownerDocument.createElement(nodeName);
            data || (data = getExpandoData(ownerDocument));
            var node;
            return node = data.cache[nodeName] ? data.cache[nodeName].cloneNode() : saveClones.test(nodeName) ? (data.cache[nodeName] = data.createElem(nodeName)).cloneNode() : data.createElem(nodeName), node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node
        }
        function createDocumentFragment(ownerDocument, data) {
            if (ownerDocument || (ownerDocument = document), supportsUnknownElements)
                return ownerDocument.createDocumentFragment();
            data = data || getExpandoData(ownerDocument);
            for (var clone = data.frag.cloneNode(), i = 0, elems = getElements(), l = elems.length; l > i; i++)
                clone.createElement(elems[i]);
            return clone
        }
        function shivMethods(ownerDocument, data) {
            data.cache || (data.cache = {}, data.createElem = ownerDocument.createElement, data.createFrag = ownerDocument.createDocumentFragment, data.frag = data.createFrag()), ownerDocument.createElement = function (nodeName) {
                return html5.shivMethods ? createElement(nodeName, ownerDocument, data) : data.createElem(nodeName)
            }, ownerDocument.createDocumentFragment = Function("h,f", "return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(" + getElements().join().replace(/\w+/g, function (nodeName) {
                return data.createElem(nodeName), data.frag.createElement(nodeName), 'c("' + nodeName + '")'
            }) + ");return n}")(html5, data.frag)
        }
        function shivDocument(ownerDocument) {
            ownerDocument || (ownerDocument = document);
            var data = getExpandoData(ownerDocument);
            return!html5.shivCSS || supportsHtml5Styles || data.hasCSS || (data.hasCSS = !!addStyleSheet(ownerDocument, "article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}mark{background:#FF0;color:#000}")), supportsUnknownElements || shivMethods(ownerDocument, data), ownerDocument
        }
        var supportsHtml5Styles, supportsUnknownElements, options = window.html5 || {}, reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i, saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i, expando = "_html5shiv", expanID = 0, expandoData = {};
        !function () {
            try {
                var a = document.createElement("a");
                a.innerHTML = "<xyz></xyz>", supportsHtml5Styles = "hidden"in a, supportsUnknownElements = 1 == a.childNodes.length || function () {
                    document.createElement("a");
                    var frag = document.createDocumentFragment();
                    return"undefined" == typeof frag.cloneNode || "undefined" == typeof frag.createDocumentFragment || "undefined" == typeof frag.createElement
                }()
            } catch (e) {
                supportsHtml5Styles = !0, supportsUnknownElements = !0
            }
        }();
        var html5 = {elements: options.elements || "abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video", shivCSS: options.shivCSS !== !1, supportsUnknownElements: supportsUnknownElements, shivMethods: options.shivMethods !== !1, type: "default", shivDocument: shivDocument, createElement: createElement, createDocumentFragment: createDocumentFragment};
        window.html5 = html5, shivDocument(document)
    }(this, document), Modernizr._version = version, Modernizr._prefixes = prefixes, Modernizr._domPrefixes = domPrefixes, Modernizr._cssomPrefixes = cssomPrefixes, Modernizr.mq = testMediaQuery, Modernizr.hasEvent = isEventSupported, Modernizr.testProp = function (prop) {
        return testProps([prop])
    }, Modernizr.testAllProps = testPropsAll, Modernizr.testStyles = injectElementWithStyles, Modernizr.prefixed = function (prop, obj, elem) {
        return obj ? testPropsAll(prop, obj, elem) : testPropsAll(prop, "pfx")
    }, docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (enableClasses ? " js " + classes.join(" ") : ""), Modernizr
}(this, this.document), jQuery.easing.jswing = jQuery.easing.swing, jQuery.extend(jQuery.easing, {def: "easeOutQuad", swing: function (x, t, b, c, d) {
        return jQuery.easing[jQuery.easing.def](x, t, b, c, d)
    }, easeInQuad: function (x, t, b, c, d) {
        return c * (t /= d) * t + b
    }, easeOutQuad: function (x, t, b, c, d) {
        return-c * (t /= d) * (t - 2) + b
    }, easeInOutQuad: function (x, t, b, c, d) {
        return(t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b
    }, easeInCubic: function (x, t, b, c, d) {
        return c * (t /= d) * t * t + b
    }, easeOutCubic: function (x, t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b
    }, easeInOutCubic: function (x, t, b, c, d) {
        return(t /= d / 2) < 1 ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b
    }, easeInQuart: function (x, t, b, c, d) {
        return c * (t /= d) * t * t * t + b
    }, easeOutQuart: function (x, t, b, c, d) {
        return-c * ((t = t / d - 1) * t * t * t - 1) + b
    }, easeInOutQuart: function (x, t, b, c, d) {
        return(t /= d / 2) < 1 ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b
    }, easeInQuint: function (x, t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b
    }, easeOutQuint: function (x, t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b
    }, easeInOutQuint: function (x, t, b, c, d) {
        return(t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b
    }, easeInSine: function (x, t, b, c, d) {
        return-c * Math.cos(t / d * (Math.PI / 2)) + c + b
    }, easeOutSine: function (x, t, b, c, d) {
        return c * Math.sin(t / d * (Math.PI / 2)) + b
    }, easeInOutSine: function (x, t, b, c, d) {
        return-c / 2 * (Math.cos(Math.PI * t / d) - 1) + b
    }, easeInExpo: function (x, t, b, c, d) {
        return 0 == t ? b : c * Math.pow(2, 10 * (t / d - 1)) + b
    }, easeOutExpo: function (x, t, b, c, d) {
        return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b
    }, easeInOutExpo: function (x, t, b, c, d) {
        return 0 == t ? b : t == d ? b + c : (t /= d / 2) < 1 ? c / 2 * Math.pow(2, 10 * (t - 1)) + b : c / 2 * (-Math.pow(2, -10 * --t) + 2) + b
    }, easeInCirc: function (x, t, b, c, d) {
        return-c * (Math.sqrt(1 - (t /= d) * t) - 1) + b
    }, easeOutCirc: function (x, t, b, c, d) {
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b
    }, easeInOutCirc: function (x, t, b, c, d) {
        return(t /= d / 2) < 1 ? -c / 2 * (Math.sqrt(1 - t * t) - 1) + b : c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b
    }, easeInElastic: function (x, t, b, c, d) {
        var s = 1.70158, p = 0, a = c;
        if (0 == t)
            return b;
        if (1 == (t /= d))
            return b + c;
        if (p || (p = .3 * d), a < Math.abs(c)) {
            a = c;
            var s = p / 4
        } else
            var s = p / (2 * Math.PI) * Math.asin(c / a);
        return-(a * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t * d - s) * Math.PI / p)) + b
    }, easeOutElastic: function (x, t, b, c, d) {
        var s = 1.70158, p = 0, a = c;
        if (0 == t)
            return b;
        if (1 == (t /= d))
            return b + c;
        if (p || (p = .3 * d), a < Math.abs(c)) {
            a = c;
            var s = p / 4
        } else
            var s = p / (2 * Math.PI) * Math.asin(c / a);
        return a * Math.pow(2, -10 * t) * Math.sin(2 * (t * d - s) * Math.PI / p) + c + b
    }, easeInOutElastic: function (x, t, b, c, d) {
        var s = 1.70158, p = 0, a = c;
        if (0 == t)
            return b;
        if (2 == (t /= d / 2))
            return b + c;
        if (p || (p = .3 * d * 1.5), a < Math.abs(c)) {
            a = c;
            var s = p / 4
        } else
            var s = p / (2 * Math.PI) * Math.asin(c / a);
        return 1 > t ? -.5 * a * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t * d - s) * Math.PI / p) + b : a * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t * d - s) * Math.PI / p) * .5 + c + b
    }, easeInBack: function (x, t, b, c, d, s) {
        return void 0 == s && (s = 1.70158), c * (t /= d) * t * ((s + 1) * t - s) + b
    }, easeOutBack: function (x, t, b, c, d, s) {
        return void 0 == s && (s = 1.70158), c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b
    }, easeInOutBack: function (x, t, b, c, d, s) {
        return void 0 == s && (s = 1.70158), (t /= d / 2) < 1 ? c / 2 * t * t * (((s *= 1.525) + 1) * t - s) + b : c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b
    }, easeInBounce: function (x, t, b, c, d) {
        return c - jQuery.easing.easeOutBounce(x, d - t, 0, c, d) + b
    }, easeOutBounce: function (x, t, b, c, d) {
        return(t /= d) < 1 / 2.75 ? 7.5625 * c * t * t + b : 2 / 2.75 > t ? c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b : 2.5 / 2.75 > t ? c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b : c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b
    }, easeInOutBounce: function (x, t, b, c, d) {
        return d / 2 > t ? .5 * jQuery.easing.easeInBounce(x, 2 * t, 0, c, d) + b : .5 * jQuery.easing.easeOutBounce(x, 2 * t - d, 0, c, d) + .5 * c + b
    }}), function () {
    "use strict";
    angular.module("base64", []).constant("$base64", function () {
        function getbyte64(s, i) {
            var idx = ALPHA.indexOf(s.charAt(i));
            if (-1 == idx)
                throw"Cannot decode base64";
            return idx
        }
        function decode(s) {
            s = "" + s;
            var pads, i, b10, imax = s.length;
            if (0 == imax)
                return s;
            if (imax % 4 != 0)
                throw"Cannot decode base64";
            pads = 0, s.charAt(imax - 1) == PADCHAR && (pads = 1, s.charAt(imax - 2) == PADCHAR && (pads = 2), imax -= 4);
            var x = [];
            for (i = 0; imax > i; i += 4)
                b10 = getbyte64(s, i) << 18 | getbyte64(s, i + 1) << 12 | getbyte64(s, i + 2) << 6 | getbyte64(s, i + 3), x.push(String.fromCharCode(b10 >> 16, b10 >> 8 & 255, 255 & b10));
            switch (pads) {
                case 1:
                    b10 = getbyte64(s, i) << 18 | getbyte64(s, i + 1) << 12 | getbyte64(s, i + 2) << 6, x.push(String.fromCharCode(b10 >> 16, b10 >> 8 & 255));
                    break;
                case 2:
                    b10 = getbyte64(s, i) << 18 | getbyte64(s, i + 1) << 12, x.push(String.fromCharCode(b10 >> 16))
            }
            return x.join("")
        }
        function getbyte(s, i) {
            var x = s.charCodeAt(i);
            if (x > 255)
                throw"INVALID_CHARACTER_ERR: DOM Exception 5";
            return x
        }
        function encode(s) {
            if (1 != arguments.length)
                throw"SyntaxError: Not enough arguments";
            var i, b10, x = [];
            s = "" + s;
            var imax = s.length - s.length % 3;
            if (0 == s.length)
                return s;
            for (i = 0; imax > i; i += 3)
                b10 = getbyte(s, i) << 16 | getbyte(s, i + 1) << 8 | getbyte(s, i + 2), x.push(ALPHA.charAt(b10 >> 18)), x.push(ALPHA.charAt(b10 >> 12 & 63)), x.push(ALPHA.charAt(b10 >> 6 & 63)), x.push(ALPHA.charAt(63 & b10));
            switch (s.length - imax) {
                case 1:
                    b10 = getbyte(s, i) << 16, x.push(ALPHA.charAt(b10 >> 18) + ALPHA.charAt(b10 >> 12 & 63) + PADCHAR + PADCHAR);
                    break;
                case 2:
                    b10 = getbyte(s, i) << 16 | getbyte(s, i + 1) << 8, x.push(ALPHA.charAt(b10 >> 18) + ALPHA.charAt(b10 >> 12 & 63) + ALPHA.charAt(b10 >> 6 & 63) + PADCHAR)
            }
            return x.join("")
        }
        var PADCHAR = "=", ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        return{encode: encode, decode: decode}
    }())
}();
var mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
!function () {
    function build() {
        var svg = {};
        return svg.FRAMERATE = 30, svg.MAX_VIRTUAL_PIXELS = 3e4, svg.init = function (ctx) {
            var uniqueId = 0;
            svg.UniqueId = function () {
                return uniqueId++, "canvg" + uniqueId
            }, svg.Definitions = {}, svg.Styles = {}, svg.Animations = [], svg.Images = [], svg.ctx = ctx, svg.ViewPort = new function () {
                this.viewPorts = [], this.Clear = function () {
                    this.viewPorts = []
                }, this.SetCurrent = function (width, height) {
                    this.viewPorts.push({width: width, height: height})
                }, this.RemoveCurrent = function () {
                    this.viewPorts.pop()
                }, this.Current = function () {
                    return this.viewPorts[this.viewPorts.length - 1]
                }, this.width = function () {
                    return this.Current().width
                }, this.height = function () {
                    return this.Current().height
                }, this.ComputeSize = function (d) {
                    return null != d && "number" == typeof d ? d : "x" == d ? this.width() : "y" == d ? this.height() : Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2)
                }
            }
        }, svg.init(), svg.ImagesLoaded = function () {
            for (var i = 0; i < svg.Images.length; i++)
                if (!svg.Images[i].loaded)
                    return!1;
            return!0
        }, svg.trim = function (s) {
            return s.replace(/^\s+|\s+$/g, "")
        }, svg.compressSpaces = function (s) {
            return s.replace(/[\s\r\t\n]+/gm, " ")
        }, svg.ajax = function (url) {
            var AJAX;
            return AJAX = window.XMLHttpRequest ? new XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP"), AJAX ? (AJAX.open("GET", url, !1), AJAX.send(null), AJAX.responseText) : null
        }, svg.parseXml = function (xml) {
            if (window.DOMParser) {
                var parser = new DOMParser;
                return parser.parseFromString(xml, "text/xml")
            }
            xml = xml.replace(/<!DOCTYPE svg[^>]*>/, "");
            var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            return xmlDoc.async = "false", xmlDoc.loadXML(xml), xmlDoc
        }, svg.Property = function (name, value) {
            this.name = name, this.value = value
        }, svg.Property.prototype.getValue = function () {
            return this.value
        }, svg.Property.prototype.hasValue = function () {
            return null != this.value && "" !== this.value
        }, svg.Property.prototype.numValue = function () {
            if (!this.hasValue())
                return 0;
            var n = parseFloat(this.value);
            return(this.value + "").match(/%$/) && (n /= 100), n
        }, svg.Property.prototype.valueOrDefault = function (def) {
            return this.hasValue() ? this.value : def
        }, svg.Property.prototype.numValueOrDefault = function (def) {
            return this.hasValue() ? this.numValue() : def
        }, svg.Property.prototype.addOpacity = function (opacity) {
            var newValue = this.value;
            if (null != opacity && "" != opacity && "string" == typeof this.value) {
                var color = new RGBColor(this.value);
                color.ok && (newValue = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + opacity + ")")
            }
            return new svg.Property(this.name, newValue)
        }, svg.Property.prototype.getDefinition = function () {
            var name = this.value.match(/#([^\)'"]+)/);
            return name && (name = name[1]), name || (name = this.value), svg.Definitions[name]
        }, svg.Property.prototype.isUrlDefinition = function () {
            return 0 == this.value.indexOf("url(")
        }, svg.Property.prototype.getFillStyleDefinition = function (e, opacityProp) {
            var def = this.getDefinition();
            if (null != def && def.createGradient)
                return def.createGradient(svg.ctx, e, opacityProp);
            if (null != def && def.createPattern) {
                if (def.getHrefAttribute().hasValue()) {
                    var pt = def.attribute("patternTransform");
                    def = def.getHrefAttribute().getDefinition(), pt.hasValue() && (def.attribute("patternTransform", !0).value = pt.value)
                }
                return def.createPattern(svg.ctx, e)
            }
            return null
        }, svg.Property.prototype.getDPI = function () {
            return 96
        }, svg.Property.prototype.getEM = function (viewPort) {
            var em = 12, fontSize = new svg.Property("fontSize", svg.Font.Parse(svg.ctx.font).fontSize);
            return fontSize.hasValue() && (em = fontSize.toPixels(viewPort)), em
        }, svg.Property.prototype.getUnits = function () {
            var s = this.value + "";
            return s.replace(/[0-9\.\-]/g, "")
        }, svg.Property.prototype.toPixels = function (viewPort, processPercent) {
            if (!this.hasValue())
                return 0;
            var s = this.value + "";
            if (s.match(/em$/))
                return this.numValue() * this.getEM(viewPort);
            if (s.match(/ex$/))
                return this.numValue() * this.getEM(viewPort) / 2;
            if (s.match(/px$/))
                return this.numValue();
            if (s.match(/pt$/))
                return this.numValue() * this.getDPI(viewPort) * (1 / 72);
            if (s.match(/pc$/))
                return 15 * this.numValue();
            if (s.match(/cm$/))
                return this.numValue() * this.getDPI(viewPort) / 2.54;
            if (s.match(/mm$/))
                return this.numValue() * this.getDPI(viewPort) / 25.4;
            if (s.match(/in$/))
                return this.numValue() * this.getDPI(viewPort);
            if (s.match(/%$/))
                return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
            var n = this.numValue();
            return processPercent && 1 > n ? n * svg.ViewPort.ComputeSize(viewPort) : n
        }, svg.Property.prototype.toMilliseconds = function () {
            if (!this.hasValue())
                return 0;
            var s = this.value + "";
            return s.match(/s$/) ? 1e3 * this.numValue() : (s.match(/ms$/), this.numValue())
        }, svg.Property.prototype.toRadians = function () {
            if (!this.hasValue())
                return 0;
            var s = this.value + "";
            return s.match(/deg$/) ? this.numValue() * (Math.PI / 180) : s.match(/grad$/) ? this.numValue() * (Math.PI / 200) : s.match(/rad$/) ? this.numValue() : this.numValue() * (Math.PI / 180)
        }, svg.Font = new function () {
            this.Styles = "normal|italic|oblique|inherit", this.Variants = "normal|small-caps|inherit", this.Weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit", this.CreateFont = function (fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
                var f = null != inherit ? this.Parse(inherit) : this.CreateFont("", "", "", "", "", svg.ctx.font);
                return{fontFamily: fontFamily || f.fontFamily, fontSize: fontSize || f.fontSize, fontStyle: fontStyle || f.fontStyle, fontWeight: fontWeight || f.fontWeight, fontVariant: fontVariant || f.fontVariant, toString: function () {
                        return[this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(" ")
                    }}
            };
            var that = this;
            this.Parse = function (s) {
                for (var f = {}, d = svg.trim(svg.compressSpaces(s || "")).split(" "), set = {fontSize: !1, fontStyle: !1, fontWeight: !1, fontVariant: !1}, ff = "", i = 0; i < d.length; i++)
                    set.fontStyle || -1 == that.Styles.indexOf(d[i]) ? set.fontVariant || -1 == that.Variants.indexOf(d[i]) ? set.fontWeight || -1 == that.Weights.indexOf(d[i]) ? set.fontSize ? "inherit" != d[i] && (ff += d[i]) : ("inherit" != d[i] && (f.fontSize = d[i].split("/")[0]), set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = !0) : ("inherit" != d[i] && (f.fontWeight = d[i]), set.fontStyle = set.fontVariant = set.fontWeight = !0) : ("inherit" != d[i] && (f.fontVariant = d[i]), set.fontStyle = set.fontVariant = !0) : ("inherit" != d[i] && (f.fontStyle = d[i]), set.fontStyle = !0);
                return"" != ff && (f.fontFamily = ff), f
            }
        }, svg.ToNumberArray = function (s) {
            for (var a = svg.trim(svg.compressSpaces((s || "").replace(/,/g, " "))).split(" "), i = 0; i < a.length; i++)
                a[i] = parseFloat(a[i]);
            return a
        }, svg.Point = function (x, y) {
            this.x = x, this.y = y
        }, svg.Point.prototype.angleTo = function (p) {
            return Math.atan2(p.y - this.y, p.x - this.x)
        }, svg.Point.prototype.applyTransform = function (v) {
            var xp = this.x * v[0] + this.y * v[2] + v[4], yp = this.x * v[1] + this.y * v[3] + v[5];
            this.x = xp, this.y = yp
        }, svg.CreatePoint = function (s) {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1])
        }, svg.CreatePath = function (s) {
            for (var a = svg.ToNumberArray(s), path = [], i = 0; i < a.length; i += 2)
                path.push(new svg.Point(a[i], a[i + 1]));
            return path
        }, svg.BoundingBox = function (x1, y1, x2, y2) {
            this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN, this.x = function () {
                return this.x1
            }, this.y = function () {
                return this.y1
            }, this.width = function () {
                return this.x2 - this.x1
            }, this.height = function () {
                return this.y2 - this.y1
            }, this.addPoint = function (x, y) {
                null != x && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = x, this.x2 = x), x < this.x1 && (this.x1 = x), x > this.x2 && (this.x2 = x)), null != y && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = y, this.y2 = y), y < this.y1 && (this.y1 = y), y > this.y2 && (this.y2 = y))
            }, this.addX = function (x) {
                this.addPoint(x, null)
            }, this.addY = function (y) {
                this.addPoint(null, y)
            }, this.addBoundingBox = function (bb) {
                this.addPoint(bb.x1, bb.y1), this.addPoint(bb.x2, bb.y2)
            }, this.addQuadraticCurve = function (p0x, p0y, p1x, p1y, p2x, p2y) {
                var cp1x = p0x + 2 / 3 * (p1x - p0x), cp1y = p0y + 2 / 3 * (p1y - p0y), cp2x = cp1x + 1 / 3 * (p2x - p0x), cp2y = cp1y + 1 / 3 * (p2y - p0y);
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y)
            }, this.addBezierCurve = function (p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
                for (this.addPoint(p0[0], p0[1]), this.addPoint(p3[0], p3[1]), i = 0; 1 >= i; i++) {
                    var f = function (t) {
                        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i]
                    }, b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i], a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i], c = 3 * p1[i] - 3 * p0[i];
                    if (0 != a) {
                        var b2ac = Math.pow(b, 2) - 4 * c * a;
                        if (!(0 > b2ac)) {
                            var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                            t1 > 0 && 1 > t1 && (0 == i && this.addX(f(t1)), 1 == i && this.addY(f(t1)));
                            var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                            t2 > 0 && 1 > t2 && (0 == i && this.addX(f(t2)), 1 == i && this.addY(f(t2)))
                        }
                    } else {
                        if (0 == b)
                            continue;
                        var t = -c / b;
                        t > 0 && 1 > t && (0 == i && this.addX(f(t)), 1 == i && this.addY(f(t)))
                    }
                }
            }, this.isPointInBox = function (x, y) {
                return this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2
            }, this.addPoint(x1, y1), this.addPoint(x2, y2)
        }, svg.Transform = function (v) {
            var that = this;
            this.Type = {}, this.Type.translate = function (s) {
                this.p = svg.CreatePoint(s), this.apply = function (ctx) {
                    ctx.translate(this.p.x || 0, this.p.y || 0)
                }, this.unapply = function (ctx) {
                    ctx.translate(-1 * this.p.x || 0, -1 * this.p.y || 0)
                }, this.applyToPoint = function (p) {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0, this.p.y || 0])
                }
            }, this.Type.rotate = function (s) {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property("angle", a[0]), this.cx = a[1] || 0, this.cy = a[2] || 0, this.apply = function (ctx) {
                    ctx.translate(this.cx, this.cy), ctx.rotate(this.angle.toRadians()), ctx.translate(-this.cx, -this.cy)
                }, this.unapply = function (ctx) {
                    ctx.translate(this.cx, this.cy), ctx.rotate(-1 * this.angle.toRadians()), ctx.translate(-this.cx, -this.cy)
                }, this.applyToPoint = function (p) {
                    var a = this.angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0, this.p.y || 0]), p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]), p.applyTransform([1, 0, 0, 1, -this.p.x || 0, -this.p.y || 0])
                }
            }, this.Type.scale = function (s) {
                this.p = svg.CreatePoint(s), this.apply = function (ctx) {
                    ctx.scale(this.p.x || 1, this.p.y || this.p.x || 1)
                }, this.unapply = function (ctx) {
                    ctx.scale(1 / this.p.x || 1, 1 / this.p.y || this.p.x || 1)
                }, this.applyToPoint = function (p) {
                    p.applyTransform([this.p.x || 0, 0, 0, this.p.y || 0, 0, 0])
                }
            }, this.Type.matrix = function (s) {
                this.m = svg.ToNumberArray(s), this.apply = function (ctx) {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5])
                }, this.applyToPoint = function (p) {
                    p.applyTransform(this.m)
                }
            }, this.Type.SkewBase = function (s) {
                this.base = that.Type.matrix, this.base(s), this.angle = new svg.Property("angle", s)
            }, this.Type.SkewBase.prototype = new this.Type.matrix, this.Type.skewX = function (s) {
                this.base = that.Type.SkewBase, this.base(s), this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0]
            }, this.Type.skewX.prototype = new this.Type.SkewBase, this.Type.skewY = function (s) {
                this.base = that.Type.SkewBase, this.base(s), this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0]
            }, this.Type.skewY.prototype = new this.Type.SkewBase, this.transforms = [], this.apply = function (ctx) {
                for (var i = 0; i < this.transforms.length; i++)
                    this.transforms[i].apply(ctx)
            }, this.unapply = function (ctx) {
                for (var i = this.transforms.length - 1; i >= 0; i--)
                    this.transforms[i].unapply(ctx)
            }, this.applyToPoint = function (p) {
                for (var i = 0; i < this.transforms.length; i++)
                    this.transforms[i].applyToPoint(p)
            };
            for (var data = svg.trim(svg.compressSpaces(v)).replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/), i = 0; i < data.length; i++) {
                var type = svg.trim(data[i].split("(")[0]), s = data[i].split("(")[1].replace(")", ""), transform = new this.Type[type](s);
                transform.type = type, this.transforms.push(transform)
            }
        }, svg.AspectRatio = function (ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
            aspectRatio = svg.compressSpaces(aspectRatio), aspectRatio = aspectRatio.replace(/^defer\s/, "");
            var align = aspectRatio.split(" ")[0] || "xMidYMid", meetOrSlice = aspectRatio.split(" ")[1] || "meet", scaleX = width / desiredWidth, scaleY = height / desiredHeight, scaleMin = Math.min(scaleX, scaleY), scaleMax = Math.max(scaleX, scaleY);
            "meet" == meetOrSlice && (desiredWidth *= scaleMin, desiredHeight *= scaleMin), "slice" == meetOrSlice && (desiredWidth *= scaleMax, desiredHeight *= scaleMax), refX = new svg.Property("refX", refX), refY = new svg.Property("refY", refY), refX.hasValue() && refY.hasValue() ? ctx.translate(-scaleMin * refX.toPixels("x"), -scaleMin * refY.toPixels("y")) : (align.match(/^xMid/) && ("meet" == meetOrSlice && scaleMin == scaleY || "slice" == meetOrSlice && scaleMax == scaleY) && ctx.translate(width / 2 - desiredWidth / 2, 0), align.match(/YMid$/) && ("meet" == meetOrSlice && scaleMin == scaleX || "slice" == meetOrSlice && scaleMax == scaleX) && ctx.translate(0, height / 2 - desiredHeight / 2), align.match(/^xMax/) && ("meet" == meetOrSlice && scaleMin == scaleY || "slice" == meetOrSlice && scaleMax == scaleY) && ctx.translate(width - desiredWidth, 0), align.match(/YMax$/) && ("meet" == meetOrSlice && scaleMin == scaleX || "slice" == meetOrSlice && scaleMax == scaleX) && ctx.translate(0, height - desiredHeight)), "none" == align ? ctx.scale(scaleX, scaleY) : "meet" == meetOrSlice ? ctx.scale(scaleMin, scaleMin) : "slice" == meetOrSlice && ctx.scale(scaleMax, scaleMax), ctx.translate(null == minX ? 0 : -minX, null == minY ? 0 : -minY)
        }, svg.Element = {}, svg.EmptyProperty = new svg.Property("EMPTY", ""), svg.Element.ElementBase = function (node) {
            if (this.attributes = {}, this.styles = {}, this.children = [], this.attribute = function (name, createIfNotExists) {
                var a = this.attributes[name];
                return null != a ? a : (1 == createIfNotExists && (a = new svg.Property(name, ""), this.attributes[name] = a), a || svg.EmptyProperty)
            }, this.getHrefAttribute = function () {
                for (var a in this.attributes)
                    if (a.match(/:href$/))
                        return this.attributes[a];
                return svg.EmptyProperty
            }, this.style = function (name, createIfNotExists) {
                var s = this.styles[name];
                if (null != s)
                    return s;
                var a = this.attribute(name);
                if (null != a && a.hasValue())
                    return this.styles[name] = a, a;
                var p = this.parent;
                if (null != p) {
                    var ps = p.style(name);
                    if (null != ps && ps.hasValue())
                        return ps
                }
                return 1 == createIfNotExists && (s = new svg.Property(name, ""), this.styles[name] = s), s || svg.EmptyProperty
            }, this.render = function (ctx) {
                if ("none" != this.style("display").value && "hidden" != this.attribute("visibility").value) {
                    if (ctx.save(), this.attribute("mask").hasValue()) {
                        var mask = this.attribute("mask").getDefinition();
                        null != mask && mask.apply(ctx, this)
                    } else if (this.style("filter").hasValue()) {
                        var filter = this.style("filter").getDefinition();
                        null != filter && filter.apply(ctx, this)
                    } else
                        this.setContext(ctx), this.renderChildren(ctx), this.clearContext(ctx);
                    ctx.restore()
                }
            }, this.setContext = function () {
            }, this.clearContext = function () {
            }, this.renderChildren = function (ctx) {
                for (var i = 0; i < this.children.length; i++)
                    this.children[i].render(ctx)
            }, this.addChild = function (childNode, create) {
                var child = childNode;
                create && (child = svg.CreateElement(childNode)), child.parent = this, this.children.push(child)
            }, null != node && 1 == node.nodeType) {
                for (var i = 0; i < node.childNodes.length; i++) {
                    var childNode = node.childNodes[i];
                    if (1 == childNode.nodeType && this.addChild(childNode, !0), this.captureTextNodes && 3 == childNode.nodeType) {
                        var text = childNode.nodeValue || childNode.text || "";
                        "" != svg.trim(svg.compressSpaces(text)) && this.addChild(new svg.Element.tspan(childNode), !1)
                    }
                }
                for (var i = 0; i < node.attributes.length; i++) {
                    var attribute = node.attributes[i];
                    this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue)
                }
                var styles = svg.Styles[node.nodeName];
                if (null != styles)
                    for (var name in styles)
                        this.styles[name] = styles[name];
                if (this.attribute("class").hasValue())
                    for (var classes = svg.compressSpaces(this.attribute("class").value).split(" "), j = 0; j < classes.length; j++) {
                        if (styles = svg.Styles["." + classes[j]], null != styles)
                            for (var name in styles)
                                this.styles[name] = styles[name];
                        if (styles = svg.Styles[node.nodeName + "." + classes[j]], null != styles)
                            for (var name in styles)
                                this.styles[name] = styles[name]
                    }
                if (this.attribute("id").hasValue()) {
                    var styles = svg.Styles["#" + this.attribute("id").value];
                    if (null != styles)
                        for (var name in styles)
                            this.styles[name] = styles[name]
                }
                if (this.attribute("style").hasValue())
                    for (var styles = this.attribute("style").value.split(";"), i = 0; i < styles.length; i++)
                        if ("" != svg.trim(styles[i])) {
                            var style = styles[i].split(":"), name = svg.trim(style[0]), value = svg.trim(style[1]);
                            this.styles[name] = new svg.Property(name, value)
                        }
                this.attribute("id").hasValue() && null == svg.Definitions[this.attribute("id").value] && (svg.Definitions[this.attribute("id").value] = this)
            }
        }, svg.Element.RenderedElementBase = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.setContext = function (ctx) {
                if (this.style("fill").isUrlDefinition()) {
                    var fs = this.style("fill").getFillStyleDefinition(this, this.style("fill-opacity"));
                    null != fs && (ctx.fillStyle = fs)
                } else if (this.style("fill").hasValue()) {
                    var fillStyle = this.style("fill");
                    "currentColor" == fillStyle.value && (fillStyle.value = this.style("color").value), ctx.fillStyle = "none" == fillStyle.value ? "rgba(0,0,0,0)" : fillStyle.value
                }
                if (this.style("fill-opacity").hasValue()) {
                    var fillStyle = new svg.Property("fill", ctx.fillStyle);
                    fillStyle = fillStyle.addOpacity(this.style("fill-opacity").value), ctx.fillStyle = fillStyle.value
                }
                if (this.style("stroke").isUrlDefinition()) {
                    var fs = this.style("stroke").getFillStyleDefinition(this, this.style("stroke-opacity"));
                    null != fs && (ctx.strokeStyle = fs)
                } else if (this.style("stroke").hasValue()) {
                    var strokeStyle = this.style("stroke");
                    "currentColor" == strokeStyle.value && (strokeStyle.value = this.style("color").value), ctx.strokeStyle = "none" == strokeStyle.value ? "rgba(0,0,0,0)" : strokeStyle.value
                }
                if (this.style("stroke-opacity").hasValue()) {
                    var strokeStyle = new svg.Property("stroke", ctx.strokeStyle);
                    strokeStyle = strokeStyle.addOpacity(this.style("stroke-opacity").value), ctx.strokeStyle = strokeStyle.value
                }
                if (this.style("stroke-width").hasValue()) {
                    var newLineWidth = this.style("stroke-width").toPixels();
                    ctx.lineWidth = 0 == newLineWidth ? .001 : newLineWidth
                }
                if (this.style("stroke-linecap").hasValue() && (ctx.lineCap = this.style("stroke-linecap").value), this.style("stroke-linejoin").hasValue() && (ctx.lineJoin = this.style("stroke-linejoin").value), this.style("stroke-miterlimit").hasValue() && (ctx.miterLimit = this.style("stroke-miterlimit").value), this.style("stroke-dasharray").hasValue()) {
                    var gaps = svg.ToNumberArray(this.style("stroke-dasharray").value);
                    "undefined" != typeof ctx.setLineDash ? ctx.setLineDash(gaps) : "undefined" != typeof ctx.webkitLineDash ? ctx.webkitLineDash = gaps : "undefined" != typeof ctx.mozDash && (ctx.mozDash = gaps);
                    var offset = this.style("stroke-dashoffset").numValueOrDefault(1);
                    "undefined" != typeof ctx.lineDashOffset ? ctx.lineDashOffset = offset : "undefined" != typeof ctx.webkitLineDashOffset ? ctx.webkitLineDashOffset = offset : "undefined" != typeof ctx.mozDashOffset && (ctx.mozDashOffset = offset)
                }
                if ("undefined" != typeof ctx.font && (ctx.font = svg.Font.CreateFont(this.style("font-style").value, this.style("font-variant").value, this.style("font-weight").value, this.style("font-size").hasValue() ? this.style("font-size").toPixels() + "px" : "", this.style("font-family").value).toString()), this.attribute("transform").hasValue()) {
                    var transform = new svg.Transform(this.attribute("transform").value);
                    transform.apply(ctx)
                }
                if (this.style("clip-path").hasValue()) {
                    var clip = this.style("clip-path").getDefinition();
                    null != clip && clip.apply(ctx)
                }
                this.style("opacity").hasValue() && (ctx.globalAlpha = this.style("opacity").numValue())
            }
        }, svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase, svg.Element.PathElementBase = function (node) {
            this.base = svg.Element.RenderedElementBase, this.base(node), this.path = function (ctx) {
                return null != ctx && ctx.beginPath(), new svg.BoundingBox
            }, this.renderChildren = function (ctx) {
                this.path(ctx), svg.Mouse.checkPath(this, ctx), "" != ctx.fillStyle && (this.attribute("fill-rule").hasValue() ? ctx.fill(this.attribute("fill-rule").value) : ctx.fill()), "" != ctx.strokeStyle && ctx.stroke();
                var markers = this.getMarkers();
                if (null != markers) {
                    if (this.style("marker-start").isUrlDefinition()) {
                        var marker = this.style("marker-start").getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1])
                    }
                    if (this.style("marker-mid").isUrlDefinition())
                        for (var marker = this.style("marker-mid").getDefinition(), i = 1; i < markers.length - 1; i++)
                            marker.render(ctx, markers[i][0], markers[i][1]);
                    if (this.style("marker-end").isUrlDefinition()) {
                        var marker = this.style("marker-end").getDefinition();
                        marker.render(ctx, markers[markers.length - 1][0], markers[markers.length - 1][1])
                    }
                }
            }, this.getBoundingBox = function () {
                return this.path()
            }, this.getMarkers = function () {
                return null
            }
        }, svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase, svg.Element.svg = function (node) {
            this.base = svg.Element.RenderedElementBase, this.base(node), this.baseClearContext = this.clearContext, this.clearContext = function (ctx) {
                this.baseClearContext(ctx), svg.ViewPort.RemoveCurrent()
            }, this.baseSetContext = this.setContext, this.setContext = function (ctx) {
                ctx.strokeStyle = "rgba(0,0,0,0)", ctx.lineCap = "butt", ctx.lineJoin = "miter", ctx.miterLimit = 4, this.baseSetContext(ctx), this.attribute("x").hasValue() || (this.attribute("x", !0).value = 0), this.attribute("y").hasValue() || (this.attribute("y", !0).value = 0), ctx.translate(this.attribute("x").toPixels("x"), this.attribute("y").toPixels("y"));
                var width = svg.ViewPort.width(), height = svg.ViewPort.height();
                if (this.attribute("width").hasValue() || (this.attribute("width", !0).value = "100%"), this.attribute("height").hasValue() || (this.attribute("height", !0).value = "100%"), "undefined" == typeof this.root) {
                    width = this.attribute("width").toPixels("x"), height = this.attribute("height").toPixels("y");
                    var x = 0, y = 0;
                    this.attribute("refX").hasValue() && this.attribute("refY").hasValue() && (x = -this.attribute("refX").toPixels("x"), y = -this.attribute("refY").toPixels("y")), ctx.beginPath(), ctx.moveTo(x, y), ctx.lineTo(width, y), ctx.lineTo(width, height), ctx.lineTo(x, height), ctx.closePath(), ctx.clip()
                }
                if (svg.ViewPort.SetCurrent(width, height), this.attribute("viewBox").hasValue()) {
                    var viewBox = svg.ToNumberArray(this.attribute("viewBox").value), minX = viewBox[0], minY = viewBox[1];
                    width = viewBox[2], height = viewBox[3], svg.AspectRatio(ctx, this.attribute("preserveAspectRatio").value, svg.ViewPort.width(), width, svg.ViewPort.height(), height, minX, minY, this.attribute("refX").value, this.attribute("refY").value), svg.ViewPort.RemoveCurrent(), svg.ViewPort.SetCurrent(viewBox[2], viewBox[3])
                }
            }
        }, svg.Element.svg.prototype = new svg.Element.RenderedElementBase, svg.Element.rect = function (node) {
            this.base = svg.Element.PathElementBase, this.base(node), this.path = function (ctx) {
                var x = this.attribute("x").toPixels("x"), y = this.attribute("y").toPixels("y"), width = this.attribute("width").toPixels("x"), height = this.attribute("height").toPixels("y"), rx = this.attribute("rx").toPixels("x"), ry = this.attribute("ry").toPixels("y");
                return this.attribute("rx").hasValue() && !this.attribute("ry").hasValue() && (ry = rx), this.attribute("ry").hasValue() && !this.attribute("rx").hasValue() && (rx = ry), rx = Math.min(rx, width / 2), ry = Math.min(ry, height / 2), null != ctx && (ctx.beginPath(), ctx.moveTo(x + rx, y), ctx.lineTo(x + width - rx, y), ctx.quadraticCurveTo(x + width, y, x + width, y + ry), ctx.lineTo(x + width, y + height - ry), ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height), ctx.lineTo(x + rx, y + height), ctx.quadraticCurveTo(x, y + height, x, y + height - ry), ctx.lineTo(x, y + ry), ctx.quadraticCurveTo(x, y, x + rx, y), ctx.closePath()), new svg.BoundingBox(x, y, x + width, y + height)
            }
        }, svg.Element.rect.prototype = new svg.Element.PathElementBase, svg.Element.circle = function (node) {
            this.base = svg.Element.PathElementBase, this.base(node), this.path = function (ctx) {
                var cx = this.attribute("cx").toPixels("x"), cy = this.attribute("cy").toPixels("y"), r = this.attribute("r").toPixels();
                return null != ctx && (ctx.beginPath(), ctx.arc(cx, cy, r, 0, 2 * Math.PI, !0), ctx.closePath()), new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r)
            }
        }, svg.Element.circle.prototype = new svg.Element.PathElementBase, svg.Element.ellipse = function (node) {
            this.base = svg.Element.PathElementBase, this.base(node), this.path = function (ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3), rx = this.attribute("rx").toPixels("x"), ry = this.attribute("ry").toPixels("y"), cx = this.attribute("cx").toPixels("x"), cy = this.attribute("cy").toPixels("y");
                return null != ctx && (ctx.beginPath(), ctx.moveTo(cx, cy - ry), ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy), ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry), ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy), ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry), ctx.closePath()), new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry)
            }
        }, svg.Element.ellipse.prototype = new svg.Element.PathElementBase, svg.Element.line = function (node) {
            this.base = svg.Element.PathElementBase, this.base(node), this.getPoints = function () {
                return[new svg.Point(this.attribute("x1").toPixels("x"), this.attribute("y1").toPixels("y")), new svg.Point(this.attribute("x2").toPixels("x"), this.attribute("y2").toPixels("y"))]
            }, this.path = function (ctx) {
                var points = this.getPoints();
                return null != ctx && (ctx.beginPath(), ctx.moveTo(points[0].x, points[0].y), ctx.lineTo(points[1].x, points[1].y)), new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y)
            }, this.getMarkers = function () {
                var points = this.getPoints(), a = points[0].angleTo(points[1]);
                return[[points[0], a], [points[1], a]]
            }
        }, svg.Element.line.prototype = new svg.Element.PathElementBase, svg.Element.polyline = function (node) {
            this.base = svg.Element.PathElementBase, this.base(node), this.points = svg.CreatePath(this.attribute("points").value), this.path = function (ctx) {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                null != ctx && (ctx.beginPath(), ctx.moveTo(this.points[0].x, this.points[0].y));
                for (var i = 1; i < this.points.length; i++)
                    bb.addPoint(this.points[i].x, this.points[i].y), null != ctx && ctx.lineTo(this.points[i].x, this.points[i].y);
                return bb
            }, this.getMarkers = function () {
                for (var markers = [], i = 0; i < this.points.length - 1; i++)
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i + 1])]);
                return markers.push([this.points[this.points.length - 1], markers[markers.length - 1][1]]), markers
            }
        }, svg.Element.polyline.prototype = new svg.Element.PathElementBase, svg.Element.polygon = function (node) {
            this.base = svg.Element.polyline, this.base(node), this.basePath = this.path, this.path = function (ctx) {
                var bb = this.basePath(ctx);
                return null != ctx && (ctx.lineTo(this.points[0].x, this.points[0].y), ctx.closePath()), bb
            }
        }, svg.Element.polygon.prototype = new svg.Element.polyline, svg.Element.path = function (node) {
            this.base = svg.Element.PathElementBase, this.base(node);
            var d = this.attribute("d").value;
            d = d.replace(/,/gm, " "), d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, "$1 $2"), d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), d = d.replace(/([0-9])([+\-])/gm, "$1 $2"), d = d.replace(/(\.[0-9]*)(\.)/gm, "$1 $2"), d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 "), d = svg.compressSpaces(d), d = svg.trim(d), this.PathParser = new function (d) {
                this.tokens = d.split(" "), this.reset = function () {
                    this.i = -1, this.command = "", this.previousCommand = "", this.start = new svg.Point(0, 0), this.control = new svg.Point(0, 0), this.current = new svg.Point(0, 0), this.points = [], this.angles = []
                }, this.isEnd = function () {
                    return this.i >= this.tokens.length - 1
                }, this.isCommandOrEnd = function () {
                    return this.isEnd() ? !0 : null != this.tokens[this.i + 1].match(/^[A-Za-z]$/)
                }, this.isRelativeCommand = function () {
                    switch (this.command) {
                        case"m":
                        case"l":
                        case"h":
                        case"v":
                        case"c":
                        case"s":
                        case"q":
                        case"t":
                        case"a":
                        case"z":
                            return!0
                    }
                    return!1
                }, this.getToken = function () {
                    return this.i++, this.tokens[this.i]
                }, this.getScalar = function () {
                    return parseFloat(this.getToken())
                }, this.nextCommand = function () {
                    this.previousCommand = this.command, this.command = this.getToken()
                }, this.getPoint = function () {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p)
                }, this.getAsControlPoint = function () {
                    var p = this.getPoint();
                    return this.control = p, p
                }, this.getAsCurrentPoint = function () {
                    var p = this.getPoint();
                    return this.current = p, p
                }, this.getReflectedControlPoint = function () {
                    if ("c" != this.previousCommand.toLowerCase() && "s" != this.previousCommand.toLowerCase() && "q" != this.previousCommand.toLowerCase() && "t" != this.previousCommand.toLowerCase())
                        return this.current;
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
                    return p
                }, this.makeAbsolute = function (p) {
                    return this.isRelativeCommand() && (p.x += this.current.x, p.y += this.current.y), p
                }, this.addMarker = function (p, from, priorTo) {
                    null != priorTo && this.angles.length > 0 && null == this.angles[this.angles.length - 1] && (this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(priorTo)), this.addMarkerAngle(p, null == from ? null : from.angleTo(p))
                }, this.addMarkerAngle = function (p, a) {
                    this.points.push(p), this.angles.push(a)
                }, this.getMarkerPoints = function () {
                    return this.points
                }, this.getMarkerAngles = function () {
                    for (var i = 0; i < this.angles.length; i++)
                        if (null == this.angles[i])
                            for (var j = i + 1; j < this.angles.length; j++)
                                if (null != this.angles[j]) {
                                    this.angles[i] = this.angles[j];
                                    break
                                }
                    return this.angles
                }
            }(d), this.path = function (ctx) {
                var pp = this.PathParser;
                pp.reset();
                var bb = new svg.BoundingBox;
                for (null != ctx && ctx.beginPath(); !pp.isEnd(); )
                    switch (pp.nextCommand(), pp.command) {
                        case"M":
                        case"m":
                            var p = pp.getAsCurrentPoint();
                            for (pp.addMarker(p), bb.addPoint(p.x, p.y), null != ctx && ctx.moveTo(p.x, p.y), pp.start = pp.current; !pp.isCommandOrEnd(); ) {
                                var p = pp.getAsCurrentPoint();
                                pp.addMarker(p, pp.start), bb.addPoint(p.x, p.y), null != ctx && ctx.lineTo(p.x, p.y)
                            }
                            break;
                        case"L":
                        case"l":
                            for (; !pp.isCommandOrEnd(); ) {
                                var c = pp.current, p = pp.getAsCurrentPoint();
                                pp.addMarker(p, c), bb.addPoint(p.x, p.y), null != ctx && ctx.lineTo(p.x, p.y)
                            }
                            break;
                        case"H":
                        case"h":
                            for (; !pp.isCommandOrEnd(); ) {
                                var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                                pp.addMarker(newP, pp.current), pp.current = newP, bb.addPoint(pp.current.x, pp.current.y), null != ctx && ctx.lineTo(pp.current.x, pp.current.y)
                            }
                            break;
                        case"V":
                        case"v":
                            for (; !pp.isCommandOrEnd(); ) {
                                var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                                pp.addMarker(newP, pp.current), pp.current = newP, bb.addPoint(pp.current.x, pp.current.y), null != ctx && ctx.lineTo(pp.current.x, pp.current.y)
                            }
                            break;
                        case"C":
                        case"c":
                            for (; !pp.isCommandOrEnd(); ) {
                                var curr = pp.current, p1 = pp.getPoint(), cntrl = pp.getAsControlPoint(), cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1), bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y), null != ctx && ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case"S":
                        case"s":
                            for (; !pp.isCommandOrEnd(); ) {
                                var curr = pp.current, p1 = pp.getReflectedControlPoint(), cntrl = pp.getAsControlPoint(), cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1), bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y), null != ctx && ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case"Q":
                        case"q":
                            for (; !pp.isCommandOrEnd(); ) {
                                var curr = pp.current, cntrl = pp.getAsControlPoint(), cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl), bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y), null != ctx && ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case"T":
                        case"t":
                            for (; !pp.isCommandOrEnd(); ) {
                                var curr = pp.current, cntrl = pp.getReflectedControlPoint();
                                pp.control = cntrl;
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl), bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y), null != ctx && ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case"A":
                        case"a":
                            for (; !pp.isCommandOrEnd(); ) {
                                var curr = pp.current, rx = pp.getScalar(), ry = pp.getScalar(), xAxisRotation = pp.getScalar() * (Math.PI / 180), largeArcFlag = pp.getScalar(), sweepFlag = pp.getScalar(), cp = pp.getAsCurrentPoint(), currp = new svg.Point(Math.cos(xAxisRotation) * (curr.x - cp.x) / 2 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2, -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2), l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);
                                l > 1 && (rx *= Math.sqrt(l), ry *= Math.sqrt(l));
                                var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(currp.y, 2) - Math.pow(ry, 2) * Math.pow(currp.x, 2)) / (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));
                                isNaN(s) && (s = 0);
                                var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx), centp = new svg.Point((curr.x + cp.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (curr.y + cp.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y), m = function (v) {
                                    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2))
                                }, r = function (u, v) {
                                    return(u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v))
                                }, a = function (u, v) {
                                    return(u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v))
                                }, a1 = a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]), u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry], v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry], ad = a(u, v);
                                r(u, v) <= -1 && (ad = Math.PI), r(u, v) >= 1 && (ad = 0);
                                var dir = 1 - sweepFlag ? 1 : -1, ah = a1 + dir * (ad / 2), halfWay = new svg.Point(centp.x + rx * Math.cos(ah), centp.y + ry * Math.sin(ah));
                                if (pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2), pp.addMarkerAngle(cp, ah - dir * Math.PI), bb.addPoint(cp.x, cp.y), null != ctx) {
                                    var r = rx > ry ? rx : ry, sx = rx > ry ? 1 : rx / ry, sy = rx > ry ? ry / rx : 1;
                                    ctx.translate(centp.x, centp.y), ctx.rotate(xAxisRotation), ctx.scale(sx, sy), ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag), ctx.scale(1 / sx, 1 / sy), ctx.rotate(-xAxisRotation), ctx.translate(-centp.x, -centp.y)
                                }
                            }
                            break;
                        case"Z":
                        case"z":
                            null != ctx && ctx.closePath(), pp.current = pp.start
                    }
                return bb
            }, this.getMarkers = function () {
                for (var points = this.PathParser.getMarkerPoints(), angles = this.PathParser.getMarkerAngles(), markers = [], i = 0; i < points.length; i++)
                    markers.push([points[i], angles[i]]);
                return markers
            }
        }, svg.Element.path.prototype = new svg.Element.PathElementBase, svg.Element.pattern = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.createPattern = function (ctx) {
                var width = this.attribute("width").toPixels("x", !0), height = this.attribute("height").toPixels("y", !0), tempSvg = new svg.Element.svg;
                tempSvg.attributes.viewBox = new svg.Property("viewBox", this.attribute("viewBox").value), tempSvg.attributes.width = new svg.Property("width", width + "px"), tempSvg.attributes.height = new svg.Property("height", height + "px"), tempSvg.attributes.transform = new svg.Property("transform", this.attribute("patternTransform").value), tempSvg.children = this.children;
                var c = document.createElement("canvas");
                c.width = width, c.height = height;
                var cctx = c.getContext("2d");
                this.attribute("x").hasValue() && this.attribute("y").hasValue() && cctx.translate(this.attribute("x").toPixels("x", !0), this.attribute("y").toPixels("y", !0));
                for (var x = -1; 1 >= x; x++)
                    for (var y = -1; 1 >= y; y++)
                        cctx.save(), cctx.translate(x * c.width, y * c.height), tempSvg.render(cctx), cctx.restore();
                var pattern = ctx.createPattern(c, "repeat");
                return pattern
            }
        }, svg.Element.pattern.prototype = new svg.Element.ElementBase, svg.Element.marker = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.baseRender = this.render, this.render = function (ctx, point, angle) {
                ctx.translate(point.x, point.y), "auto" == this.attribute("orient").valueOrDefault("auto") && ctx.rotate(angle), "strokeWidth" == this.attribute("markerUnits").valueOrDefault("strokeWidth") && ctx.scale(ctx.lineWidth, ctx.lineWidth), ctx.save();
                var tempSvg = new svg.Element.svg;
                tempSvg.attributes.viewBox = new svg.Property("viewBox", this.attribute("viewBox").value), tempSvg.attributes.refX = new svg.Property("refX", this.attribute("refX").value), tempSvg.attributes.refY = new svg.Property("refY", this.attribute("refY").value), tempSvg.attributes.width = new svg.Property("width", this.attribute("markerWidth").value), tempSvg.attributes.height = new svg.Property("height", this.attribute("markerHeight").value), tempSvg.attributes.fill = new svg.Property("fill", this.attribute("fill").valueOrDefault("black")), tempSvg.attributes.stroke = new svg.Property("stroke", this.attribute("stroke").valueOrDefault("none")), tempSvg.children = this.children, tempSvg.render(ctx), ctx.restore(), "strokeWidth" == this.attribute("markerUnits").valueOrDefault("strokeWidth") && ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth), "auto" == this.attribute("orient").valueOrDefault("auto") && ctx.rotate(-angle), ctx.translate(-point.x, -point.y)
            }
        }, svg.Element.marker.prototype = new svg.Element.ElementBase, svg.Element.defs = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.render = function () {
            }
        }, svg.Element.defs.prototype = new svg.Element.ElementBase, svg.Element.GradientBase = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.gradientUnits = this.attribute("gradientUnits").valueOrDefault("objectBoundingBox"), this.stops = [];
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                "stop" == child.type && this.stops.push(child)
            }
            this.getGradient = function () {
            }, this.createGradient = function (ctx, element, parentOpacityProp) {
                var stopsContainer = this;
                this.getHrefAttribute().hasValue() && (stopsContainer = this.getHrefAttribute().getDefinition());
                var addParentOpacity = function (color) {
                    if (parentOpacityProp.hasValue()) {
                        var p = new svg.Property("color", color);
                        return p.addOpacity(parentOpacityProp.value).value
                    }
                    return color
                }, g = this.getGradient(ctx, element);
                if (null == g)
                    return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
                for (var i = 0; i < stopsContainer.stops.length; i++)
                    g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
                if (this.attribute("gradientTransform").hasValue()) {
                    var rootView = svg.ViewPort.viewPorts[0], rect = new svg.Element.rect;
                    rect.attributes.x = new svg.Property("x", -svg.MAX_VIRTUAL_PIXELS / 3), rect.attributes.y = new svg.Property("y", -svg.MAX_VIRTUAL_PIXELS / 3), rect.attributes.width = new svg.Property("width", svg.MAX_VIRTUAL_PIXELS), rect.attributes.height = new svg.Property("height", svg.MAX_VIRTUAL_PIXELS);
                    var group = new svg.Element.g;
                    group.attributes.transform = new svg.Property("transform", this.attribute("gradientTransform").value), group.children = [rect];
                    var tempSvg = new svg.Element.svg;
                    tempSvg.attributes.x = new svg.Property("x", 0), tempSvg.attributes.y = new svg.Property("y", 0), tempSvg.attributes.width = new svg.Property("width", rootView.width), tempSvg.attributes.height = new svg.Property("height", rootView.height), tempSvg.children = [group];
                    var c = document.createElement("canvas");
                    c.width = rootView.width, c.height = rootView.height;
                    var tempCtx = c.getContext("2d");
                    return tempCtx.fillStyle = g, tempSvg.render(tempCtx), tempCtx.createPattern(c, "no-repeat")
                }
                return g
            }
        }, svg.Element.GradientBase.prototype = new svg.Element.ElementBase, svg.Element.linearGradient = function (node) {
            this.base = svg.Element.GradientBase, this.base(node), this.getGradient = function (ctx, element) {
                var bb = element.getBoundingBox();
                this.attribute("x1").hasValue() || this.attribute("y1").hasValue() || this.attribute("x2").hasValue() || this.attribute("y2").hasValue() || (this.attribute("x1", !0).value = 0, this.attribute("y1", !0).value = 0, this.attribute("x2", !0).value = 1, this.attribute("y2", !0).value = 0);
                var x1 = "objectBoundingBox" == this.gradientUnits ? bb.x() + bb.width() * this.attribute("x1").numValue() : this.attribute("x1").toPixels("x"), y1 = "objectBoundingBox" == this.gradientUnits ? bb.y() + bb.height() * this.attribute("y1").numValue() : this.attribute("y1").toPixels("y"), x2 = "objectBoundingBox" == this.gradientUnits ? bb.x() + bb.width() * this.attribute("x2").numValue() : this.attribute("x2").toPixels("x"), y2 = "objectBoundingBox" == this.gradientUnits ? bb.y() + bb.height() * this.attribute("y2").numValue() : this.attribute("y2").toPixels("y");
                return x1 == x2 && y1 == y2 ? null : ctx.createLinearGradient(x1, y1, x2, y2)
            }
        }, svg.Element.linearGradient.prototype = new svg.Element.GradientBase, svg.Element.radialGradient = function (node) {
            this.base = svg.Element.GradientBase, this.base(node), this.getGradient = function (ctx, element) {
                var bb = element.getBoundingBox();
                this.attribute("cx").hasValue() || (this.attribute("cx", !0).value = "50%"), this.attribute("cy").hasValue() || (this.attribute("cy", !0).value = "50%"), this.attribute("r").hasValue() || (this.attribute("r", !0).value = "50%");
                var cx = "objectBoundingBox" == this.gradientUnits ? bb.x() + bb.width() * this.attribute("cx").numValue() : this.attribute("cx").toPixels("x"), cy = "objectBoundingBox" == this.gradientUnits ? bb.y() + bb.height() * this.attribute("cy").numValue() : this.attribute("cy").toPixels("y"), fx = cx, fy = cy;
                this.attribute("fx").hasValue() && (fx = "objectBoundingBox" == this.gradientUnits ? bb.x() + bb.width() * this.attribute("fx").numValue() : this.attribute("fx").toPixels("x")), this.attribute("fy").hasValue() && (fy = "objectBoundingBox" == this.gradientUnits ? bb.y() + bb.height() * this.attribute("fy").numValue() : this.attribute("fy").toPixels("y"));
                var r = "objectBoundingBox" == this.gradientUnits ? (bb.width() + bb.height()) / 2 * this.attribute("r").numValue() : this.attribute("r").toPixels();
                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r)
            }
        }, svg.Element.radialGradient.prototype = new svg.Element.GradientBase, svg.Element.stop = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.offset = this.attribute("offset").numValue(), this.offset < 0 && (this.offset = 0), this.offset > 1 && (this.offset = 1);
            var stopColor = this.style("stop-color");
            this.style("stop-opacity").hasValue() && (stopColor = stopColor.addOpacity(this.style("stop-opacity").value)), this.color = stopColor.value
        }, svg.Element.stop.prototype = new svg.Element.ElementBase, svg.Element.AnimateBase = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), svg.Animations.push(this), this.duration = 0, this.begin = this.attribute("begin").toMilliseconds(), this.maxDuration = this.begin + this.attribute("dur").toMilliseconds(), this.getProperty = function () {
                var attributeType = this.attribute("attributeType").value, attributeName = this.attribute("attributeName").value;
                return"CSS" == attributeType ? this.parent.style(attributeName, !0) : this.parent.attribute(attributeName, !0)
            }, this.initialValue = null, this.initialUnits = "", this.removed = !1, this.calcValue = function () {
                return""
            }, this.update = function (delta) {
                if (null == this.initialValue && (this.initialValue = this.getProperty().value, this.initialUnits = this.getProperty().getUnits()), this.duration > this.maxDuration) {
                    if ("indefinite" != this.attribute("repeatCount").value && "indefinite" != this.attribute("repeatDur").value)
                        return"remove" != this.attribute("fill").valueOrDefault("remove") || this.removed ? !1 : (this.removed = !0, this.getProperty().value = this.initialValue, !0);
                    this.duration = 0
                }
                this.duration = this.duration + delta;
                var updated = !1;
                if (this.begin < this.duration) {
                    var newValue = this.calcValue();
                    if (this.attribute("type").hasValue()) {
                        var type = this.attribute("type").value;
                        newValue = type + "(" + newValue + ")"
                    }
                    this.getProperty().value = newValue, updated = !0
                }
                return updated
            }, this.from = this.attribute("from"), this.to = this.attribute("to"), this.values = this.attribute("values"), this.values.hasValue() && (this.values.value = this.values.value.split(";")), this.progress = function () {
                var ret = {progress: (this.duration - this.begin) / (this.maxDuration - this.begin)};
                if (this.values.hasValue()) {
                    var p = ret.progress * (this.values.value.length - 1), lb = Math.floor(p), ub = Math.ceil(p);
                    ret.from = new svg.Property("from", parseFloat(this.values.value[lb])), ret.to = new svg.Property("to", parseFloat(this.values.value[ub])), ret.progress = (p - lb) / (ub - lb)
                } else
                    ret.from = this.from, ret.to = this.to;
                return ret
            }
        }, svg.Element.AnimateBase.prototype = new svg.Element.ElementBase, svg.Element.animate = function (node) {
            this.base = svg.Element.AnimateBase, this.base(node), this.calcValue = function () {
                var p = this.progress(), newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
                return newValue + this.initialUnits
            }
        }, svg.Element.animate.prototype = new svg.Element.AnimateBase, svg.Element.animateColor = function (node) {
            this.base = svg.Element.AnimateBase, this.base(node), this.calcValue = function () {
                var p = this.progress(), from = new RGBColor(p.from.value), to = new RGBColor(p.to.value);
                if (from.ok && to.ok) {
                    var r = from.r + (to.r - from.r) * p.progress, g = from.g + (to.g - from.g) * p.progress, b = from.b + (to.b - from.b) * p.progress;
                    return"rgb(" + parseInt(r, 10) + "," + parseInt(g, 10) + "," + parseInt(b, 10) + ")"
                }
                return this.attribute("from").value
            }
        }, svg.Element.animateColor.prototype = new svg.Element.AnimateBase, svg.Element.animateTransform = function (node) {
            this.base = svg.Element.AnimateBase, this.base(node), this.calcValue = function () {
                for (var p = this.progress(), from = svg.ToNumberArray(p.from.value), to = svg.ToNumberArray(p.to.value), newValue = "", i = 0; i < from.length; i++)
                    newValue += from[i] + (to[i] - from[i]) * p.progress + " ";
                return newValue
            }
        }, svg.Element.animateTransform.prototype = new svg.Element.animate, svg.Element.font = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.horizAdvX = this.attribute("horiz-adv-x").numValue(), this.isRTL = !1, this.isArabic = !1, this.fontFace = null, this.missingGlyph = null, this.glyphs = [];
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                "font-face" == child.type ? (this.fontFace = child, child.style("font-family").hasValue() && (svg.Definitions[child.style("font-family").value] = this)) : "missing-glyph" == child.type ? this.missingGlyph = child : "glyph" == child.type && ("" != child.arabicForm ? (this.isRTL = !0, this.isArabic = !0, "undefined" == typeof this.glyphs[child.unicode] && (this.glyphs[child.unicode] = []), this.glyphs[child.unicode][child.arabicForm] = child) : this.glyphs[child.unicode] = child)
            }
        }, svg.Element.font.prototype = new svg.Element.ElementBase, svg.Element.fontface = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.ascent = this.attribute("ascent").value, this.descent = this.attribute("descent").value, this.unitsPerEm = this.attribute("units-per-em").numValue()
        }, svg.Element.fontface.prototype = new svg.Element.ElementBase, svg.Element.missingglyph = function (node) {
            this.base = svg.Element.path, this.base(node), this.horizAdvX = 0
        }, svg.Element.missingglyph.prototype = new svg.Element.path, svg.Element.glyph = function (node) {
            this.base = svg.Element.path, this.base(node), this.horizAdvX = this.attribute("horiz-adv-x").numValue(), this.unicode = this.attribute("unicode").value, this.arabicForm = this.attribute("arabic-form").value
        }, svg.Element.glyph.prototype = new svg.Element.path, svg.Element.text = function (node) {
            this.captureTextNodes = !0, this.base = svg.Element.RenderedElementBase, this.base(node), this.baseSetContext = this.setContext, this.setContext = function (ctx) {
                this.baseSetContext(ctx), this.style("dominant-baseline").hasValue() && (ctx.textBaseline = this.style("dominant-baseline").value), this.style("alignment-baseline").hasValue() && (ctx.textBaseline = this.style("alignment-baseline").value)
            }, this.getBoundingBox = function () {
                return new svg.BoundingBox(this.attribute("x").toPixels("x"), this.attribute("y").toPixels("y"), 0, 0)
            }, this.renderChildren = function (ctx) {
                this.x = this.attribute("x").toPixels("x"), this.y = this.attribute("y").toPixels("y"), this.x += this.getAnchorDelta(ctx, this, 0);
                for (var i = 0; i < this.children.length; i++)
                    this.renderChild(ctx, this, i)
            }, this.getAnchorDelta = function (ctx, parent, startI) {
                var textAnchor = this.style("text-anchor").valueOrDefault("start");
                if ("start" != textAnchor) {
                    for (var width = 0, i = startI; i < parent.children.length; i++) {
                        var child = parent.children[i];
                        if (i > startI && child.attribute("x").hasValue())
                            break;
                        width += child.measureTextRecursive(ctx)
                    }
                    return-1 * ("end" == textAnchor ? width : width / 2)
                }
                return 0
            }, this.renderChild = function (ctx, parent, i) {
                var child = parent.children[i];
                child.attribute("x").hasValue() ? child.x = child.attribute("x").toPixels("x") + this.getAnchorDelta(ctx, parent, i) : (this.attribute("dx").hasValue() && (this.x += this.attribute("dx").toPixels("x")), child.attribute("dx").hasValue() && (this.x += child.attribute("dx").toPixels("x")), child.x = this.x), this.x = child.x + child.measureText(ctx), child.attribute("y").hasValue() ? child.y = child.attribute("y").toPixels("y") : (this.attribute("dy").hasValue() && (this.y += this.attribute("dy").toPixels("y")), child.attribute("dy").hasValue() && (this.y += child.attribute("dy").toPixels("y")), child.y = this.y), this.y = child.y, child.render(ctx);
                for (var i = 0; i < child.children.length; i++)
                    this.renderChild(ctx, child, i)
            }
        }, svg.Element.text.prototype = new svg.Element.RenderedElementBase, svg.Element.TextElementBase = function (node) {
            this.base = svg.Element.RenderedElementBase, this.base(node), this.getGlyph = function (font, text, i) {
                var c = text[i], glyph = null;
                if (font.isArabic) {
                    var arabicForm = "isolated";
                    (0 == i || " " == text[i - 1]) && i < text.length - 2 && " " != text[i + 1] && (arabicForm = "terminal"), i > 0 && " " != text[i - 1] && i < text.length - 2 && " " != text[i + 1] && (arabicForm = "medial"), i > 0 && " " != text[i - 1] && (i == text.length - 1 || " " == text[i + 1]) && (arabicForm = "initial"), "undefined" != typeof font.glyphs[c] && (glyph = font.glyphs[c][arabicForm], null == glyph && "glyph" == font.glyphs[c].type && (glyph = font.glyphs[c]))
                } else
                    glyph = font.glyphs[c];
                return null == glyph && (glyph = font.missingGlyph), glyph
            }, this.renderChildren = function (ctx) {
                var customFont = this.parent.style("font-family").getDefinition();
                if (null == customFont)
                    "" != ctx.fillStyle && ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y), "" != ctx.strokeStyle && ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
                else {
                    var fontSize = this.parent.style("font-size").numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize), fontStyle = this.parent.style("font-style").valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle), text = this.getText();
                    customFont.isRTL && (text = text.split("").reverse().join(""));
                    for (var dx = svg.ToNumberArray(this.parent.attribute("dx").value), i = 0; i < text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i), scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y), ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize, "italic" == fontStyle && ctx.transform(1, 0, .4, 1, 0, 0), glyph.render(ctx), "italic" == fontStyle && ctx.transform(1, 0, -.4, 1, 0, 0), ctx.lineWidth = lw, ctx.scale(1 / scale, -1 / scale), ctx.translate(-this.x, -this.y), this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm, "undefined" == typeof dx[i] || isNaN(dx[i]) || (this.x += dx[i])
                    }
                }
            }, this.getText = function () {
            }, this.measureTextRecursive = function (ctx) {
                for (var width = this.measureText(ctx), i = 0; i < this.children.length; i++)
                    width += this.children[i].measureTextRecursive(ctx);
                return width
            }, this.measureText = function (ctx) {
                var customFont = this.parent.style("font-family").getDefinition();
                if (null != customFont) {
                    var fontSize = this.parent.style("font-size").numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize), measure = 0, text = this.getText();
                    customFont.isRTL && (text = text.split("").reverse().join(""));
                    for (var dx = svg.ToNumberArray(this.parent.attribute("dx").value), i = 0; i < text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm, "undefined" == typeof dx[i] || isNaN(dx[i]) || (measure += dx[i])
                    }
                    return measure
                }
                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText)
                    return 10 * textToMeasure.length;
                ctx.save(), this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                return ctx.restore(), width
            }
        }, svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase, svg.Element.tspan = function (node) {
            this.captureTextNodes = !0, this.base = svg.Element.TextElementBase, this.base(node), this.text = node.nodeValue || node.text || "", this.getText = function () {
                return this.text
            }
        }, svg.Element.tspan.prototype = new svg.Element.TextElementBase, svg.Element.tref = function (node) {
            this.base = svg.Element.TextElementBase, this.base(node), this.getText = function () {
                var element = this.getHrefAttribute().getDefinition();
                return null != element ? element.children[0].getText() : void 0
            }
        }, svg.Element.tref.prototype = new svg.Element.TextElementBase, svg.Element.a = function (node) {
            this.base = svg.Element.TextElementBase, this.base(node), this.hasText = !0;
            for (var i = 0; i < node.childNodes.length; i++)
                3 != node.childNodes[i].nodeType && (this.hasText = !1);
            this.text = this.hasText ? node.childNodes[0].nodeValue : "", this.getText = function () {
                return this.text
            }, this.baseRenderChildren = this.renderChildren, this.renderChildren = function (ctx) {
                if (this.hasText) {
                    this.baseRenderChildren(ctx);
                    var fontSize = new svg.Property("fontSize", svg.Font.Parse(svg.ctx.font).fontSize);
                    svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels("y"), this.x + this.measureText(ctx), this.y))
                } else {
                    var g = new svg.Element.g;
                    g.children = this.children, g.parent = this, g.render(ctx)
                }
            }, this.onclick = function () {
                window.open(this.getHrefAttribute().value)
            }, this.onmousemove = function () {
                svg.ctx.canvas.style.cursor = "pointer"
            }
        }, svg.Element.a.prototype = new svg.Element.TextElementBase, svg.Element.image = function (node) {
            this.base = svg.Element.RenderedElementBase, this.base(node);
            var href = this.getHrefAttribute().value, isSvg = href.match(/\.svg$/);
            if (svg.Images.push(this), this.loaded = !1, isSvg)
                this.img = svg.ajax(href), this.loaded = !0;
            else {
                this.img = document.createElement("img");
                var self = this;
                this.img.onload = function () {
                    self.loaded = !0
                }, this.img.onerror = function () {
                    "undefined" != typeof console && (console.log('ERROR: image "' + href + '" not found'), self.loaded = !0)
                }, this.img.src = href
            }
            this.renderChildren = function (ctx) {
                var x = this.attribute("x").toPixels("x"), y = this.attribute("y").toPixels("y"), width = this.attribute("width").toPixels("x"), height = this.attribute("height").toPixels("y");
                0 != width && 0 != height && (ctx.save(), isSvg ? ctx.drawSvg(this.img, x, y, width, height) : (ctx.translate(x, y), svg.AspectRatio(ctx, this.attribute("preserveAspectRatio").value, width, this.img.width, height, this.img.height, 0, 0), ctx.drawImage(this.img, 0, 0)), ctx.restore())
            }, this.getBoundingBox = function () {
                var x = this.attribute("x").toPixels("x"), y = this.attribute("y").toPixels("y"), width = this.attribute("width").toPixels("x"), height = this.attribute("height").toPixels("y");
                return new svg.BoundingBox(x, y, x + width, y + height)
            }
        }, svg.Element.image.prototype = new svg.Element.RenderedElementBase, svg.Element.g = function (node) {
            this.base = svg.Element.RenderedElementBase, this.base(node), this.getBoundingBox = function () {
                for (var bb = new svg.BoundingBox, i = 0; i < this.children.length; i++)
                    bb.addBoundingBox(this.children[i].getBoundingBox());
                return bb
            }
        }, svg.Element.g.prototype = new svg.Element.RenderedElementBase, svg.Element.symbol = function (node) {
            this.base = svg.Element.RenderedElementBase, this.base(node), this.baseSetContext = this.setContext, this.setContext = function (ctx) {
                if (this.baseSetContext(ctx), this.attribute("viewBox").hasValue()) {
                    var viewBox = svg.ToNumberArray(this.attribute("viewBox").value), minX = viewBox[0], minY = viewBox[1];
                    width = viewBox[2], height = viewBox[3], svg.AspectRatio(ctx, this.attribute("preserveAspectRatio").value, this.attribute("width").toPixels("x"), width, this.attribute("height").toPixels("y"), height, minX, minY), svg.ViewPort.SetCurrent(viewBox[2], viewBox[3])
                }
            }
        }, svg.Element.symbol.prototype = new svg.Element.RenderedElementBase, svg.Element.style = function (node) {
            this.base = svg.Element.ElementBase, this.base(node);
            for (var css = "", i = 0; i < node.childNodes.length; i++)
                css += node.childNodes[i].nodeValue;
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ""), css = svg.compressSpaces(css);
            for (var cssDefs = css.split("}"), i = 0; i < cssDefs.length; i++)
                if ("" != svg.trim(cssDefs[i]))
                    for (var cssDef = cssDefs[i].split("{"), cssClasses = cssDef[0].split(","), cssProps = cssDef[1].split(";"), j = 0; j < cssClasses.length; j++) {
                        var cssClass = svg.trim(cssClasses[j]);
                        if ("" != cssClass) {
                            for (var props = {}, k = 0; k < cssProps.length; k++) {
                                var prop = cssProps[k].indexOf(":"), name = cssProps[k].substr(0, prop), value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                null != name && null != value && (props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value)))
                            }
                            if (svg.Styles[cssClass] = props, "@font-face" == cssClass)
                                for (var fontFamily = props["font-family"].value.replace(/"/g, ""), srcs = props.src.value.split(","), s = 0; s < srcs.length; s++)
                                    if (srcs[s].indexOf('format("svg")') > 0)
                                        for (var urlStart = srcs[s].indexOf("url"), urlEnd = srcs[s].indexOf(")", urlStart), url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6), doc = svg.parseXml(svg.ajax(url)), fonts = doc.getElementsByTagName("font"), f = 0; f < fonts.length; f++) {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font
                                        }
                        }
                    }
        }, svg.Element.style.prototype = new svg.Element.ElementBase, svg.Element.use = function (node) {
            this.base = svg.Element.RenderedElementBase, this.base(node), this.baseSetContext = this.setContext, this.setContext = function (ctx) {
                this.baseSetContext(ctx), this.attribute("x").hasValue() && ctx.translate(this.attribute("x").toPixels("x"), 0), this.attribute("y").hasValue() && ctx.translate(0, this.attribute("y").toPixels("y"))
            }, this.getDefinition = function () {
                var element = this.getHrefAttribute().getDefinition();
                return this.attribute("width").hasValue() && (element.attribute("width", !0).value = this.attribute("width").value), this.attribute("height").hasValue() && (element.attribute("height", !0).value = this.attribute("height").value), element
            }, this.path = function (ctx) {
                var element = this.getDefinition();
                null != element && element.path(ctx)
            }, this.getBoundingBox = function () {
                var element = this.getDefinition();
                return null != element ? element.getBoundingBox() : void 0
            }, this.renderChildren = function (ctx) {
                var element = this.getDefinition();
                if (null != element) {
                    var oldParent = element.parent;
                    element.parent = null, element.render(ctx), element.parent = oldParent
                }
            }
        }, svg.Element.use.prototype = new svg.Element.RenderedElementBase, svg.Element.mask = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.apply = function (ctx, element) {
                var x = this.attribute("x").toPixels("x"), y = this.attribute("y").toPixels("y"), width = this.attribute("width").toPixels("x"), height = this.attribute("height").toPixels("y");
                if (0 == width && 0 == height) {
                    for (var bb = new svg.BoundingBox, i = 0; i < this.children.length; i++)
                        bb.addBoundingBox(this.children[i].getBoundingBox());
                    var x = Math.floor(bb.x1), y = Math.floor(bb.y1), width = Math.floor(bb.width()), height = Math.floor(bb.height())
                }
                var mask = element.attribute("mask").value;
                element.attribute("mask").value = "";
                var cMask = document.createElement("canvas");
                cMask.width = x + width, cMask.height = y + height;
                var maskCtx = cMask.getContext("2d");
                this.renderChildren(maskCtx);
                var c = document.createElement("canvas");
                c.width = x + width, c.height = y + height;
                var tempCtx = c.getContext("2d");
                element.render(tempCtx), tempCtx.globalCompositeOperation = "destination-in", tempCtx.fillStyle = maskCtx.createPattern(cMask, "no-repeat"), tempCtx.fillRect(0, 0, x + width, y + height), ctx.fillStyle = tempCtx.createPattern(c, "no-repeat"), ctx.fillRect(0, 0, x + width, y + height), element.attribute("mask").value = mask
            }, this.render = function () {
            }
        }, svg.Element.mask.prototype = new svg.Element.ElementBase, svg.Element.clipPath = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.apply = function (ctx) {
                for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    if ("undefined" != typeof child.path) {
                        var transform = null;
                        child.attribute("transform").hasValue() && (transform = new svg.Transform(child.attribute("transform").value), transform.apply(ctx)), child.path(ctx), ctx.clip(), transform && transform.unapply(ctx)
                    }
                }
            }, this.render = function () {
            }
        }, svg.Element.clipPath.prototype = new svg.Element.ElementBase, svg.Element.filter = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.apply = function (ctx, element) {
                var bb = element.getBoundingBox(), x = Math.floor(bb.x1), y = Math.floor(bb.y1), width = Math.floor(bb.width()), height = Math.floor(bb.height()), filter = element.style("filter").value;
                element.style("filter").value = "";
                for (var px = 0, py = 0, i = 0; i < this.children.length; i++) {
                    var efd = this.children[i].extraFilterDistance || 0;
                    px = Math.max(px, efd), py = Math.max(py, efd)
                }
                var c = document.createElement("canvas");
                c.width = width + 2 * px, c.height = height + 2 * py;
                var tempCtx = c.getContext("2d");
                tempCtx.translate(-x + px, -y + py), element.render(tempCtx);
                for (var i = 0; i < this.children.length; i++)
                    this.children[i].apply(tempCtx, 0, 0, width + 2 * px, height + 2 * py);
                ctx.drawImage(c, 0, 0, width + 2 * px, height + 2 * py, x - px, y - py, width + 2 * px, height + 2 * py), element.style("filter", !0).value = filter
            }, this.render = function () {
            }
        }, svg.Element.filter.prototype = new svg.Element.ElementBase, svg.Element.feMorphology = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.apply = function () {
            }
        }, svg.Element.feMorphology.prototype = new svg.Element.ElementBase, svg.Element.feColorMatrix = function (node) {
            function imGet(img, x, y, width, height, rgba) {
                return img[y * width * 4 + 4 * x + rgba]
            }
            function imSet(img, x, y, width, height, rgba, val) {
                img[y * width * 4 + 4 * x + rgba] = val
            }
            this.base = svg.Element.ElementBase, this.base(node), this.apply = function (ctx, x, y, width, height) {
                for (var srcData = ctx.getImageData(0, 0, width, height), y = 0; height > y; y++)
                    for (var x = 0; width > x; x++) {
                        var r = imGet(srcData.data, x, y, width, height, 0), g = imGet(srcData.data, x, y, width, height, 1), b = imGet(srcData.data, x, y, width, height, 2), gray = (r + g + b) / 3;
                        imSet(srcData.data, x, y, width, height, 0, gray), imSet(srcData.data, x, y, width, height, 1, gray), imSet(srcData.data, x, y, width, height, 2, gray)
                    }
                ctx.clearRect(0, 0, width, height), ctx.putImageData(srcData, 0, 0)
            }
        }, svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase, svg.Element.feGaussianBlur = function (node) {
            this.base = svg.Element.ElementBase, this.base(node), this.blurRadius = Math.floor(this.attribute("stdDeviation").numValue()), this.extraFilterDistance = this.blurRadius, this.apply = function (ctx, x, y, width, height) {
                return"undefined" == typeof stackBlurCanvasRGBA ? void("undefined" != typeof console && console.log("ERROR: StackBlur.js must be included for blur to work")) : (ctx.canvas.id = svg.UniqueId(), ctx.canvas.style.display = "none", document.body.appendChild(ctx.canvas), stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius), void document.body.removeChild(ctx.canvas))
            }
        }, svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase, svg.Element.title = function () {
        }, svg.Element.title.prototype = new svg.Element.ElementBase, svg.Element.desc = function () {
        }, svg.Element.desc.prototype = new svg.Element.ElementBase, svg.Element.MISSING = function (node) {
            "undefined" != typeof console && console.log("ERROR: Element '" + node.nodeName + "' not yet implemented.")
        }, svg.Element.MISSING.prototype = new svg.Element.ElementBase, svg.CreateElement = function (node) {
            var className = node.nodeName.replace(/^[^:]+:/, "");
            className = className.replace(/\-/g, "");
            var e = null;
            return e = "undefined" != typeof svg.Element[className] ? new svg.Element[className](node) : new svg.Element.MISSING(node), e.type = node.nodeName, e
        }, svg.load = function (ctx, url) {
            svg.loadXml(ctx, svg.ajax(url))
        }, svg.loadXml = function (ctx, xml) {
            svg.loadXmlDoc(ctx, svg.parseXml(xml))
        }, svg.loadXmlDoc = function (ctx, dom) {
            svg.init(ctx);
            var mapXY = function (p) {
                for (var e = ctx.canvas; e; )
                    p.x -= e.offsetLeft, p.y -= e.offsetTop, e = e.offsetParent;
                return window.scrollX && (p.x += window.scrollX), window.scrollY && (p.y += window.scrollY), p
            };
            1 != svg.opts.ignoreMouse && (ctx.canvas.onclick = function (e) {
                var p = mapXY(new svg.Point(null != e ? e.clientX : event.clientX, null != e ? e.clientY : event.clientY));
                svg.Mouse.onclick(p.x, p.y)
            }, ctx.canvas.onmousemove = function (e) {
                var p = mapXY(new svg.Point(null != e ? e.clientX : event.clientX, null != e ? e.clientY : event.clientY));
                svg.Mouse.onmousemove(p.x, p.y)
            });
            var e = svg.CreateElement(dom.documentElement);
            e.root = !0;
            var isFirstRender = !0, draw = function () {
                svg.ViewPort.Clear(), ctx.canvas.parentNode && svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight), 1 != svg.opts.ignoreDimensions && (e.style("width").hasValue() && (ctx.canvas.width = e.style("width").toPixels("x"), ctx.canvas.style.width = ctx.canvas.width + "px"), e.style("height").hasValue() && (ctx.canvas.height = e.style("height").toPixels("y"), ctx.canvas.style.height = ctx.canvas.height + "px"));
                var cWidth = ctx.canvas.clientWidth || ctx.canvas.width, cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                if (1 == svg.opts.ignoreDimensions && e.style("width").hasValue() && e.style("height").hasValue() && (cWidth = e.style("width").toPixels("x"), cHeight = e.style("height").toPixels("y")), svg.ViewPort.SetCurrent(cWidth, cHeight), null != svg.opts.offsetX && (e.attribute("x", !0).value = svg.opts.offsetX), null != svg.opts.offsetY && (e.attribute("y", !0).value = svg.opts.offsetY), null != svg.opts.scaleWidth && null != svg.opts.scaleHeight) {
                    var xRatio = 1, yRatio = 1, viewBox = svg.ToNumberArray(e.attribute("viewBox").value);
                    e.attribute("width").hasValue() ? xRatio = e.attribute("width").toPixels("x") / svg.opts.scaleWidth : isNaN(viewBox[2]) || (xRatio = viewBox[2] / svg.opts.scaleWidth), e.attribute("height").hasValue() ? yRatio = e.attribute("height").toPixels("y") / svg.opts.scaleHeight : isNaN(viewBox[3]) || (yRatio = viewBox[3] / svg.opts.scaleHeight), e.attribute("width", !0).value = svg.opts.scaleWidth, e.attribute("height", !0).value = svg.opts.scaleHeight, e.attribute("viewBox", !0).value = "0 0 " + cWidth * xRatio + " " + cHeight * yRatio, e.attribute("preserveAspectRatio", !0).value = "none"
                }
                1 != svg.opts.ignoreClear && ctx.clearRect(0, 0, cWidth, cHeight), e.render(ctx), isFirstRender && (isFirstRender = !1, "function" == typeof svg.opts.renderCallback && svg.opts.renderCallback(dom))
            }, waitingForImages = !0;
            svg.ImagesLoaded() && (waitingForImages = !1, draw()), svg.intervalID = setInterval(function () {
                var needUpdate = !1;
                if (waitingForImages && svg.ImagesLoaded() && (waitingForImages = !1, needUpdate = !0), 1 != svg.opts.ignoreMouse && (needUpdate |= svg.Mouse.hasEvents()), 1 != svg.opts.ignoreAnimation)
                    for (var i = 0; i < svg.Animations.length; i++)
                        needUpdate |= svg.Animations[i].update(1e3 / svg.FRAMERATE);
                "function" == typeof svg.opts.forceRedraw && 1 == svg.opts.forceRedraw() && (needUpdate = !0), needUpdate && (draw(), svg.Mouse.runEvents())
            }, 1e3 / svg.FRAMERATE)
        }, svg.stop = function () {
            svg.intervalID && clearInterval(svg.intervalID)
        }, svg.Mouse = new function () {
            this.events = [], this.hasEvents = function () {
                return 0 != this.events.length
            }, this.onclick = function (x, y) {
                this.events.push({type: "onclick", x: x, y: y, run: function (e) {
                        e.onclick && e.onclick();
                    }})
            }, this.onmousemove = function (x, y) {
                this.events.push({type: "onmousemove", x: x, y: y, run: function (e) {
                        e.onmousemove && e.onmousemove()
                    }})
            }, this.eventElements = [], this.checkPath = function (element, ctx) {
                for (var i = 0; i < this.events.length; i++) {
                    var e = this.events[i];
                    ctx.isPointInPath && ctx.isPointInPath(e.x, e.y) && (this.eventElements[i] = element)
                }
            }, this.checkBoundingBox = function (element, bb) {
                for (var i = 0; i < this.events.length; i++) {
                    var e = this.events[i];
                    bb.isPointInBox(e.x, e.y) && (this.eventElements[i] = element)
                }
            }, this.runEvents = function () {
                svg.ctx.canvas.style.cursor = "";
                for (var i = 0; i < this.events.length; i++)
                    for (var e = this.events[i], element = this.eventElements[i]; element; )
                        e.run(element), element = element.parent;
                this.events = [], this.eventElements = []
            }
        }, svg
    }
    this.canvg = function (target, s, opts) {
        if (null != target || null != s || null != opts) {
            opts = opts || {}, "string" == typeof target && (target = document.getElementById(target)), null != target.svg && target.svg.stop();
            var svg = build();
            (1 != target.childNodes.length || "OBJECT" != target.childNodes[0].nodeName) && (target.svg = svg), svg.opts = opts;
            var ctx = target.getContext("2d");
            "undefined" != typeof s.documentElement ? svg.loadXmlDoc(ctx, s) : "<" == s.substr(0, 1) ? svg.loadXml(ctx, s) : svg.load(ctx, s)
        } else
            for (var svgTags = document.getElementsByTagName("svg"), i = 0; i < svgTags.length; i++) {
                var svgTag = svgTags[i], c = document.createElement("canvas");
                c.width = svgTag.clientWidth, c.height = svgTag.clientHeight, svgTag.parentNode.insertBefore(c, svgTag), svgTag.parentNode.removeChild(svgTag);
                var div = document.createElement("div");
                div.appendChild(svgTag), canvg(c, div.innerHTML)
            }
    }
}(), "undefined" != typeof CanvasRenderingContext2D && (CanvasRenderingContext2D.prototype.drawSvg = function (s, dx, dy, dw, dh) {
    canvg(this.canvas, s, {ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0, ignoreClear: !0, offsetX: dx, offsetY: dy, scaleWidth: dw, scaleHeight: dh})
});
